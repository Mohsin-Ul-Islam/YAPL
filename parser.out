Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    COMMA
    DO
    FOR
    FUNCTION
    MODULUS
    OBJECT
    RETURN
    SKIP
    STRUCT

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement -> assignment_statement
Rule 3     statement -> expression_statement
Rule 4     statement -> iterative_statement
Rule 5     statement -> conditional_statement
Rule 6     statement -> compound_statement
Rule 7     statement -> print_statement
Rule 8     statement_list -> statement statement_list
Rule 9     statement_list -> <empty>
Rule 10    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
Rule 11    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 12    iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 13    compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE
Rule 14    expression_statement -> expression SEMICOLON
Rule 15    expression_statement -> SEMICOLON
Rule 16    print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON
Rule 17    assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON
Rule 18    assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 19    assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON
Rule 20    expression -> MINUS term
Rule 21    expression -> NOT term
Rule 22    expression -> expression EQUALS term
Rule 23    expression -> expression OR term
Rule 24    expression -> expression AND term
Rule 25    expression -> expression PLUS term
Rule 26    expression -> expression MINUS term
Rule 27    expression -> term
Rule 28    term -> term PRODUCT factor
Rule 29    term -> term DIVIDE factor
Rule 30    term -> factor
Rule 31    factor -> literal
Rule 32    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 33    literal -> IDENTIFIER
Rule 34    literal -> DOUBLE
Rule 35    literal -> INTEGER
Rule 36    literal -> STRING

Terminals, with rules where they appear

AND                  : 24
ASSIGN               : 18 19
BREAK                : 
COMMA                : 
DIVIDE               : 29
DO                   : 
DOUBLE               : 34
ELSE                 : 10
EQUALS               : 22
FOR                  : 
FUNCTION             : 
IDENTIFIER           : 17 18 19 33
IF                   : 10 11
IN                   : 17
INTEGER              : 35
LEFT_BRACE           : 13
LEFT_PAREN           : 10 11 12 16 32
LET                  : 19
LOG                  : 16
MINUS                : 20 26
MODULUS              : 
NOT                  : 21
OBJECT               : 
OR                   : 23
PLUS                 : 25
PRODUCT              : 28
PUT                  : 17
RETURN               : 
RIGHT_BRACE          : 13
RIGHT_PAREN          : 10 11 12 16 32
SEMICOLON            : 14 15 16 17 18 19
SKIP                 : 
STRING               : 36
STRUCT               : 
WHILE                : 12
error                : 

Nonterminals, with rules where they appear

assignment_statement : 2
compound_statement   : 6 10 10 11 12
conditional_statement : 5
expression           : 10 11 12 14 16 17 18 19 22 23 24 25 26 32
expression_statement : 3
factor               : 28 29 30
iterative_statement  : 4
literal              : 31
print_statement      : 7
program              : 0
statement            : 8
statement_list       : 1 8 13
term                 : 20 21 22 23 24 25 26 27 28 29

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (8) statement_list -> . statement statement_list
    (9) statement_list -> .
    (2) statement -> . assignment_statement
    (3) statement -> . expression_statement
    (4) statement -> . iterative_statement
    (5) statement -> . conditional_statement
    (6) statement -> . compound_statement
    (7) statement -> . print_statement
    (17) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (18) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (19) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (14) expression_statement -> . expression SEMICOLON
    (15) expression_statement -> . SEMICOLON
    (12) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (10) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (11) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (13) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (16) print_statement -> . LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    $end            reduce using rule 9 (statement_list -> .)
    PUT             shift and go to state 10
    IDENTIFIER      shift and go to state 12
    LET             shift and go to state 14
    SEMICOLON       shift and go to state 13
    WHILE           shift and go to state 15
    IF              shift and go to state 17
    LEFT_BRACE      shift and go to state 18
    LOG             shift and go to state 19
    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    expression                     shift and go to state 11
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .

    $end            reduce using rule 1 (program -> statement_list .)


state 3

    (8) statement_list -> statement . statement_list
    (8) statement_list -> . statement statement_list
    (9) statement_list -> .
    (2) statement -> . assignment_statement
    (3) statement -> . expression_statement
    (4) statement -> . iterative_statement
    (5) statement -> . conditional_statement
    (6) statement -> . compound_statement
    (7) statement -> . print_statement
    (17) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (18) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (19) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (14) expression_statement -> . expression SEMICOLON
    (15) expression_statement -> . SEMICOLON
    (12) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (10) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (11) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (13) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (16) print_statement -> . LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    $end            reduce using rule 9 (statement_list -> .)
    RIGHT_BRACE     reduce using rule 9 (statement_list -> .)
    PUT             shift and go to state 10
    IDENTIFIER      shift and go to state 12
    LET             shift and go to state 14
    SEMICOLON       shift and go to state 13
    WHILE           shift and go to state 15
    IF              shift and go to state 17
    LEFT_BRACE      shift and go to state 18
    LOG             shift and go to state 19
    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    statement                      shift and go to state 3
    statement_list                 shift and go to state 28
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    expression                     shift and go to state 11
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 4

    (2) statement -> assignment_statement .

    PUT             reduce using rule 2 (statement -> assignment_statement .)
    IDENTIFIER      reduce using rule 2 (statement -> assignment_statement .)
    LET             reduce using rule 2 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 2 (statement -> assignment_statement .)
    WHILE           reduce using rule 2 (statement -> assignment_statement .)
    IF              reduce using rule 2 (statement -> assignment_statement .)
    LEFT_BRACE      reduce using rule 2 (statement -> assignment_statement .)
    LOG             reduce using rule 2 (statement -> assignment_statement .)
    MINUS           reduce using rule 2 (statement -> assignment_statement .)
    NOT             reduce using rule 2 (statement -> assignment_statement .)
    LEFT_PAREN      reduce using rule 2 (statement -> assignment_statement .)
    DOUBLE          reduce using rule 2 (statement -> assignment_statement .)
    INTEGER         reduce using rule 2 (statement -> assignment_statement .)
    STRING          reduce using rule 2 (statement -> assignment_statement .)
    $end            reduce using rule 2 (statement -> assignment_statement .)
    RIGHT_BRACE     reduce using rule 2 (statement -> assignment_statement .)


state 5

    (3) statement -> expression_statement .

    PUT             reduce using rule 3 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 3 (statement -> expression_statement .)
    LET             reduce using rule 3 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 3 (statement -> expression_statement .)
    WHILE           reduce using rule 3 (statement -> expression_statement .)
    IF              reduce using rule 3 (statement -> expression_statement .)
    LEFT_BRACE      reduce using rule 3 (statement -> expression_statement .)
    LOG             reduce using rule 3 (statement -> expression_statement .)
    MINUS           reduce using rule 3 (statement -> expression_statement .)
    NOT             reduce using rule 3 (statement -> expression_statement .)
    LEFT_PAREN      reduce using rule 3 (statement -> expression_statement .)
    DOUBLE          reduce using rule 3 (statement -> expression_statement .)
    INTEGER         reduce using rule 3 (statement -> expression_statement .)
    STRING          reduce using rule 3 (statement -> expression_statement .)
    $end            reduce using rule 3 (statement -> expression_statement .)
    RIGHT_BRACE     reduce using rule 3 (statement -> expression_statement .)


state 6

    (4) statement -> iterative_statement .

    PUT             reduce using rule 4 (statement -> iterative_statement .)
    IDENTIFIER      reduce using rule 4 (statement -> iterative_statement .)
    LET             reduce using rule 4 (statement -> iterative_statement .)
    SEMICOLON       reduce using rule 4 (statement -> iterative_statement .)
    WHILE           reduce using rule 4 (statement -> iterative_statement .)
    IF              reduce using rule 4 (statement -> iterative_statement .)
    LEFT_BRACE      reduce using rule 4 (statement -> iterative_statement .)
    LOG             reduce using rule 4 (statement -> iterative_statement .)
    MINUS           reduce using rule 4 (statement -> iterative_statement .)
    NOT             reduce using rule 4 (statement -> iterative_statement .)
    LEFT_PAREN      reduce using rule 4 (statement -> iterative_statement .)
    DOUBLE          reduce using rule 4 (statement -> iterative_statement .)
    INTEGER         reduce using rule 4 (statement -> iterative_statement .)
    STRING          reduce using rule 4 (statement -> iterative_statement .)
    $end            reduce using rule 4 (statement -> iterative_statement .)
    RIGHT_BRACE     reduce using rule 4 (statement -> iterative_statement .)


state 7

    (5) statement -> conditional_statement .

    PUT             reduce using rule 5 (statement -> conditional_statement .)
    IDENTIFIER      reduce using rule 5 (statement -> conditional_statement .)
    LET             reduce using rule 5 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 5 (statement -> conditional_statement .)
    WHILE           reduce using rule 5 (statement -> conditional_statement .)
    IF              reduce using rule 5 (statement -> conditional_statement .)
    LEFT_BRACE      reduce using rule 5 (statement -> conditional_statement .)
    LOG             reduce using rule 5 (statement -> conditional_statement .)
    MINUS           reduce using rule 5 (statement -> conditional_statement .)
    NOT             reduce using rule 5 (statement -> conditional_statement .)
    LEFT_PAREN      reduce using rule 5 (statement -> conditional_statement .)
    DOUBLE          reduce using rule 5 (statement -> conditional_statement .)
    INTEGER         reduce using rule 5 (statement -> conditional_statement .)
    STRING          reduce using rule 5 (statement -> conditional_statement .)
    $end            reduce using rule 5 (statement -> conditional_statement .)
    RIGHT_BRACE     reduce using rule 5 (statement -> conditional_statement .)


state 8

    (6) statement -> compound_statement .

    PUT             reduce using rule 6 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 6 (statement -> compound_statement .)
    LET             reduce using rule 6 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 6 (statement -> compound_statement .)
    WHILE           reduce using rule 6 (statement -> compound_statement .)
    IF              reduce using rule 6 (statement -> compound_statement .)
    LEFT_BRACE      reduce using rule 6 (statement -> compound_statement .)
    LOG             reduce using rule 6 (statement -> compound_statement .)
    MINUS           reduce using rule 6 (statement -> compound_statement .)
    NOT             reduce using rule 6 (statement -> compound_statement .)
    LEFT_PAREN      reduce using rule 6 (statement -> compound_statement .)
    DOUBLE          reduce using rule 6 (statement -> compound_statement .)
    INTEGER         reduce using rule 6 (statement -> compound_statement .)
    STRING          reduce using rule 6 (statement -> compound_statement .)
    $end            reduce using rule 6 (statement -> compound_statement .)
    RIGHT_BRACE     reduce using rule 6 (statement -> compound_statement .)


state 9

    (7) statement -> print_statement .

    PUT             reduce using rule 7 (statement -> print_statement .)
    IDENTIFIER      reduce using rule 7 (statement -> print_statement .)
    LET             reduce using rule 7 (statement -> print_statement .)
    SEMICOLON       reduce using rule 7 (statement -> print_statement .)
    WHILE           reduce using rule 7 (statement -> print_statement .)
    IF              reduce using rule 7 (statement -> print_statement .)
    LEFT_BRACE      reduce using rule 7 (statement -> print_statement .)
    LOG             reduce using rule 7 (statement -> print_statement .)
    MINUS           reduce using rule 7 (statement -> print_statement .)
    NOT             reduce using rule 7 (statement -> print_statement .)
    LEFT_PAREN      reduce using rule 7 (statement -> print_statement .)
    DOUBLE          reduce using rule 7 (statement -> print_statement .)
    INTEGER         reduce using rule 7 (statement -> print_statement .)
    STRING          reduce using rule 7 (statement -> print_statement .)
    $end            reduce using rule 7 (statement -> print_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement -> print_statement .)


state 10

    (17) assignment_statement -> PUT . expression IN IDENTIFIER SEMICOLON
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    expression                     shift and go to state 29
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 11

    (14) expression_statement -> expression . SEMICOLON
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 31
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 12

    (18) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (33) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 37
    PRODUCT         reduce using rule 33 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 33 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 33 (literal -> IDENTIFIER .)
    OR              reduce using rule 33 (literal -> IDENTIFIER .)
    AND             reduce using rule 33 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 33 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 33 (literal -> IDENTIFIER .)


state 13

    (15) expression_statement -> SEMICOLON .

    PUT             reduce using rule 15 (expression_statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (expression_statement -> SEMICOLON .)
    LET             reduce using rule 15 (expression_statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 15 (expression_statement -> SEMICOLON .)
    WHILE           reduce using rule 15 (expression_statement -> SEMICOLON .)
    IF              reduce using rule 15 (expression_statement -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 15 (expression_statement -> SEMICOLON .)
    LOG             reduce using rule 15 (expression_statement -> SEMICOLON .)
    MINUS           reduce using rule 15 (expression_statement -> SEMICOLON .)
    NOT             reduce using rule 15 (expression_statement -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 15 (expression_statement -> SEMICOLON .)
    DOUBLE          reduce using rule 15 (expression_statement -> SEMICOLON .)
    INTEGER         reduce using rule 15 (expression_statement -> SEMICOLON .)
    STRING          reduce using rule 15 (expression_statement -> SEMICOLON .)
    $end            reduce using rule 15 (expression_statement -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 15 (expression_statement -> SEMICOLON .)


state 14

    (19) assignment_statement -> LET . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 38


state 15

    (12) iterative_statement -> WHILE . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 39


state 16

    (32) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    expression                     shift and go to state 40
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 17

    (10) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (11) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 41


state 18

    (13) compound_statement -> LEFT_BRACE . statement_list RIGHT_BRACE
    (8) statement_list -> . statement statement_list
    (9) statement_list -> .
    (2) statement -> . assignment_statement
    (3) statement -> . expression_statement
    (4) statement -> . iterative_statement
    (5) statement -> . conditional_statement
    (6) statement -> . compound_statement
    (7) statement -> . print_statement
    (17) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (18) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (19) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (14) expression_statement -> . expression SEMICOLON
    (15) expression_statement -> . SEMICOLON
    (12) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (10) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (11) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (13) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (16) print_statement -> . LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    RIGHT_BRACE     reduce using rule 9 (statement_list -> .)
    PUT             shift and go to state 10
    IDENTIFIER      shift and go to state 12
    LET             shift and go to state 14
    SEMICOLON       shift and go to state 13
    WHILE           shift and go to state 15
    IF              shift and go to state 17
    LEFT_BRACE      shift and go to state 18
    LOG             shift and go to state 19
    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    statement_list                 shift and go to state 42
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    expression                     shift and go to state 11
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 19

    (16) print_statement -> LOG . LEFT_PAREN expression RIGHT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 43


state 20

    (20) expression -> MINUS . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    term                           shift and go to state 44
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 21

    (27) expression -> term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 27 (expression -> term .)
    EQUALS          reduce using rule 27 (expression -> term .)
    OR              reduce using rule 27 (expression -> term .)
    AND             reduce using rule 27 (expression -> term .)
    PLUS            reduce using rule 27 (expression -> term .)
    MINUS           reduce using rule 27 (expression -> term .)
    IN              reduce using rule 27 (expression -> term .)
    RIGHT_PAREN     reduce using rule 27 (expression -> term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 22

    (21) expression -> NOT . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    term                           shift and go to state 47
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 23

    (30) term -> factor .

    PRODUCT         reduce using rule 30 (term -> factor .)
    DIVIDE          reduce using rule 30 (term -> factor .)
    SEMICOLON       reduce using rule 30 (term -> factor .)
    EQUALS          reduce using rule 30 (term -> factor .)
    OR              reduce using rule 30 (term -> factor .)
    AND             reduce using rule 30 (term -> factor .)
    PLUS            reduce using rule 30 (term -> factor .)
    MINUS           reduce using rule 30 (term -> factor .)
    IN              reduce using rule 30 (term -> factor .)
    RIGHT_PAREN     reduce using rule 30 (term -> factor .)


state 24

    (31) factor -> literal .

    PRODUCT         reduce using rule 31 (factor -> literal .)
    DIVIDE          reduce using rule 31 (factor -> literal .)
    SEMICOLON       reduce using rule 31 (factor -> literal .)
    EQUALS          reduce using rule 31 (factor -> literal .)
    OR              reduce using rule 31 (factor -> literal .)
    AND             reduce using rule 31 (factor -> literal .)
    PLUS            reduce using rule 31 (factor -> literal .)
    MINUS           reduce using rule 31 (factor -> literal .)
    IN              reduce using rule 31 (factor -> literal .)
    RIGHT_PAREN     reduce using rule 31 (factor -> literal .)


state 25

    (34) literal -> DOUBLE .

    PRODUCT         reduce using rule 34 (literal -> DOUBLE .)
    DIVIDE          reduce using rule 34 (literal -> DOUBLE .)
    SEMICOLON       reduce using rule 34 (literal -> DOUBLE .)
    EQUALS          reduce using rule 34 (literal -> DOUBLE .)
    OR              reduce using rule 34 (literal -> DOUBLE .)
    AND             reduce using rule 34 (literal -> DOUBLE .)
    PLUS            reduce using rule 34 (literal -> DOUBLE .)
    MINUS           reduce using rule 34 (literal -> DOUBLE .)
    IN              reduce using rule 34 (literal -> DOUBLE .)
    RIGHT_PAREN     reduce using rule 34 (literal -> DOUBLE .)


state 26

    (35) literal -> INTEGER .

    PRODUCT         reduce using rule 35 (literal -> INTEGER .)
    DIVIDE          reduce using rule 35 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 35 (literal -> INTEGER .)
    EQUALS          reduce using rule 35 (literal -> INTEGER .)
    OR              reduce using rule 35 (literal -> INTEGER .)
    AND             reduce using rule 35 (literal -> INTEGER .)
    PLUS            reduce using rule 35 (literal -> INTEGER .)
    MINUS           reduce using rule 35 (literal -> INTEGER .)
    IN              reduce using rule 35 (literal -> INTEGER .)
    RIGHT_PAREN     reduce using rule 35 (literal -> INTEGER .)


state 27

    (36) literal -> STRING .

    PRODUCT         reduce using rule 36 (literal -> STRING .)
    DIVIDE          reduce using rule 36 (literal -> STRING .)
    SEMICOLON       reduce using rule 36 (literal -> STRING .)
    EQUALS          reduce using rule 36 (literal -> STRING .)
    OR              reduce using rule 36 (literal -> STRING .)
    AND             reduce using rule 36 (literal -> STRING .)
    PLUS            reduce using rule 36 (literal -> STRING .)
    MINUS           reduce using rule 36 (literal -> STRING .)
    IN              reduce using rule 36 (literal -> STRING .)
    RIGHT_PAREN     reduce using rule 36 (literal -> STRING .)


state 28

    (8) statement_list -> statement statement_list .

    $end            reduce using rule 8 (statement_list -> statement statement_list .)
    RIGHT_BRACE     reduce using rule 8 (statement_list -> statement statement_list .)


state 29

    (17) assignment_statement -> PUT expression . IN IDENTIFIER SEMICOLON
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    IN              shift and go to state 48
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 30

    (33) literal -> IDENTIFIER .

    PRODUCT         reduce using rule 33 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 33 (literal -> IDENTIFIER .)
    IN              reduce using rule 33 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 33 (literal -> IDENTIFIER .)
    OR              reduce using rule 33 (literal -> IDENTIFIER .)
    AND             reduce using rule 33 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 33 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 33 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 33 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (literal -> IDENTIFIER .)


state 31

    (14) expression_statement -> expression SEMICOLON .

    PUT             reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    LET             reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    LOG             reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    STRING          reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    $end            reduce using rule 14 (expression_statement -> expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 14 (expression_statement -> expression SEMICOLON .)


state 32

    (22) expression -> expression EQUALS . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    term                           shift and go to state 49
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 33

    (23) expression -> expression OR . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    term                           shift and go to state 50
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 34

    (24) expression -> expression AND . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    term                           shift and go to state 51
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 35

    (25) expression -> expression PLUS . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    term                           shift and go to state 52
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 36

    (26) expression -> expression MINUS . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    term                           shift and go to state 53
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 37

    (18) assignment_statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    expression                     shift and go to state 54
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 38

    (19) assignment_statement -> LET IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 55


state 39

    (12) iterative_statement -> WHILE LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    expression                     shift and go to state 56
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 40

    (32) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 57
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 41

    (10) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE compound_statement
    (11) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    expression                     shift and go to state 58
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 42

    (13) compound_statement -> LEFT_BRACE statement_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 59


state 43

    (16) print_statement -> LOG LEFT_PAREN . expression RIGHT_PAREN SEMICOLON
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    expression                     shift and go to state 60
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 44

    (20) expression -> MINUS term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 20 (expression -> MINUS term .)
    EQUALS          reduce using rule 20 (expression -> MINUS term .)
    OR              reduce using rule 20 (expression -> MINUS term .)
    AND             reduce using rule 20 (expression -> MINUS term .)
    PLUS            reduce using rule 20 (expression -> MINUS term .)
    MINUS           reduce using rule 20 (expression -> MINUS term .)
    IN              reduce using rule 20 (expression -> MINUS term .)
    RIGHT_PAREN     reduce using rule 20 (expression -> MINUS term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 45

    (28) term -> term PRODUCT . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    factor                         shift and go to state 61
    literal                        shift and go to state 24

state 46

    (29) term -> term DIVIDE . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    factor                         shift and go to state 62
    literal                        shift and go to state 24

state 47

    (21) expression -> NOT term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 21 (expression -> NOT term .)
    EQUALS          reduce using rule 21 (expression -> NOT term .)
    OR              reduce using rule 21 (expression -> NOT term .)
    AND             reduce using rule 21 (expression -> NOT term .)
    PLUS            reduce using rule 21 (expression -> NOT term .)
    MINUS           reduce using rule 21 (expression -> NOT term .)
    IN              reduce using rule 21 (expression -> NOT term .)
    RIGHT_PAREN     reduce using rule 21 (expression -> NOT term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 48

    (17) assignment_statement -> PUT expression IN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 63


state 49

    (22) expression -> expression EQUALS term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 22 (expression -> expression EQUALS term .)
    EQUALS          reduce using rule 22 (expression -> expression EQUALS term .)
    OR              reduce using rule 22 (expression -> expression EQUALS term .)
    AND             reduce using rule 22 (expression -> expression EQUALS term .)
    PLUS            reduce using rule 22 (expression -> expression EQUALS term .)
    MINUS           reduce using rule 22 (expression -> expression EQUALS term .)
    IN              reduce using rule 22 (expression -> expression EQUALS term .)
    RIGHT_PAREN     reduce using rule 22 (expression -> expression EQUALS term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 50

    (23) expression -> expression OR term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 23 (expression -> expression OR term .)
    EQUALS          reduce using rule 23 (expression -> expression OR term .)
    OR              reduce using rule 23 (expression -> expression OR term .)
    AND             reduce using rule 23 (expression -> expression OR term .)
    PLUS            reduce using rule 23 (expression -> expression OR term .)
    MINUS           reduce using rule 23 (expression -> expression OR term .)
    IN              reduce using rule 23 (expression -> expression OR term .)
    RIGHT_PAREN     reduce using rule 23 (expression -> expression OR term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 51

    (24) expression -> expression AND term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 24 (expression -> expression AND term .)
    EQUALS          reduce using rule 24 (expression -> expression AND term .)
    OR              reduce using rule 24 (expression -> expression AND term .)
    AND             reduce using rule 24 (expression -> expression AND term .)
    PLUS            reduce using rule 24 (expression -> expression AND term .)
    MINUS           reduce using rule 24 (expression -> expression AND term .)
    IN              reduce using rule 24 (expression -> expression AND term .)
    RIGHT_PAREN     reduce using rule 24 (expression -> expression AND term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 52

    (25) expression -> expression PLUS term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 25 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 25 (expression -> expression PLUS term .)
    OR              reduce using rule 25 (expression -> expression PLUS term .)
    AND             reduce using rule 25 (expression -> expression PLUS term .)
    PLUS            reduce using rule 25 (expression -> expression PLUS term .)
    MINUS           reduce using rule 25 (expression -> expression PLUS term .)
    IN              reduce using rule 25 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 25 (expression -> expression PLUS term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 53

    (26) expression -> expression MINUS term .
    (28) term -> term . PRODUCT factor
    (29) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 26 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 26 (expression -> expression MINUS term .)
    OR              reduce using rule 26 (expression -> expression MINUS term .)
    AND             reduce using rule 26 (expression -> expression MINUS term .)
    PLUS            reduce using rule 26 (expression -> expression MINUS term .)
    MINUS           reduce using rule 26 (expression -> expression MINUS term .)
    IN              reduce using rule 26 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 26 (expression -> expression MINUS term .)
    PRODUCT         shift and go to state 45
    DIVIDE          shift and go to state 46


state 54

    (18) assignment_statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 64
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 55

    (19) assignment_statement -> LET IDENTIFIER ASSIGN . expression SEMICOLON
    (20) expression -> . MINUS term
    (21) expression -> . NOT term
    (22) expression -> . expression EQUALS term
    (23) expression -> . expression OR term
    (24) expression -> . expression AND term
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term PRODUCT factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . literal
    (32) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (33) literal -> . IDENTIFIER
    (34) literal -> . DOUBLE
    (35) literal -> . INTEGER
    (36) literal -> . STRING

    MINUS           shift and go to state 20
    NOT             shift and go to state 22
    LEFT_PAREN      shift and go to state 16
    IDENTIFIER      shift and go to state 30
    DOUBLE          shift and go to state 25
    INTEGER         shift and go to state 26
    STRING          shift and go to state 27

    expression                     shift and go to state 65
    term                           shift and go to state 21
    factor                         shift and go to state 23
    literal                        shift and go to state 24

state 56

    (12) iterative_statement -> WHILE LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 66
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 57

    (32) factor -> LEFT_PAREN expression RIGHT_PAREN .

    PRODUCT         reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IN              reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 32 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 58

    (10) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE compound_statement
    (11) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 67
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 59

    (13) compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .

    PUT             reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LET             reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    WHILE           reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IF              reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LOG             reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    MINUS           reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    NOT             reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    INTEGER         reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRING          reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    $end            reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    ELSE            reduce using rule 13 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)


state 60

    (16) print_statement -> LOG LEFT_PAREN expression . RIGHT_PAREN SEMICOLON
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 68
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 61

    (28) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 28 (term -> term PRODUCT factor .)
    DIVIDE          reduce using rule 28 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 28 (term -> term PRODUCT factor .)
    EQUALS          reduce using rule 28 (term -> term PRODUCT factor .)
    OR              reduce using rule 28 (term -> term PRODUCT factor .)
    AND             reduce using rule 28 (term -> term PRODUCT factor .)
    PLUS            reduce using rule 28 (term -> term PRODUCT factor .)
    MINUS           reduce using rule 28 (term -> term PRODUCT factor .)
    IN              reduce using rule 28 (term -> term PRODUCT factor .)
    RIGHT_PAREN     reduce using rule 28 (term -> term PRODUCT factor .)


state 62

    (29) term -> term DIVIDE factor .

    PRODUCT         reduce using rule 29 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 29 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 29 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 29 (term -> term DIVIDE factor .)
    OR              reduce using rule 29 (term -> term DIVIDE factor .)
    AND             reduce using rule 29 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 29 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 29 (term -> term DIVIDE factor .)
    IN              reduce using rule 29 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 29 (term -> term DIVIDE factor .)


state 63

    (17) assignment_statement -> PUT expression IN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 69


state 64

    (18) assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    PUT             reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 18 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 65

    (19) assignment_statement -> LET IDENTIFIER ASSIGN expression . SEMICOLON
    (22) expression -> expression . EQUALS term
    (23) expression -> expression . OR term
    (24) expression -> expression . AND term
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 70
    EQUALS          shift and go to state 32
    OR              shift and go to state 33
    AND             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36


state 66

    (12) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (13) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 18

    compound_statement             shift and go to state 71

state 67

    (10) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE compound_statement
    (11) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (13) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 18

    compound_statement             shift and go to state 72

state 68

    (16) print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 73


state 69

    (17) assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .

    PUT             reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LET             reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 17 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)


state 70

    (19) assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .

    PUT             reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 19 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)


state 71

    (12) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .

    PUT             reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 12 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 72

    (10) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE compound_statement
    (11) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .

    ELSE            shift and go to state 74
    PUT             reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 11 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 73

    (16) print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .

    PUT             reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 16 (print_statement -> LOG LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)


state 74

    (10) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . compound_statement
    (13) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 18

    compound_statement             shift and go to state 75

state 75

    (10) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .

    PUT             reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IDENTIFIER      reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LET             reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    SEMICOLON       reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IF              reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_BRACE      reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LOG             reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    MINUS           reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    NOT             reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_PAREN      reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DOUBLE          reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    INTEGER         reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRING          reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    $end            reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    RIGHT_BRACE     reduce using rule 10 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)

