Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    MODULUS
    OBJECT
    RETURN
    SKIP

Grammar

Rule 0     S' -> program
Rule 1     type_specifier -> TYPE_BOOL
Rule 2     type_specifier -> TYPE_INT
Rule 3     type_specifier -> TYPE_CHAR
Rule 4     type_specifier -> TYPE_DOUBLE
Rule 5     type_specifier -> TYPE_STRING
Rule 6     empty -> <empty>
Rule 7     arguments -> expression COMMA arguments
Rule 8     function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
Rule 9     conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
Rule 10    struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
Rule 11    variable_declaration_list -> variable_declaration variable_declaration_list
Rule 12    expression_statement -> expression SEMICOLON
Rule 13    expression_statement -> SEMICOLON
Rule 14    statement -> assignment_statement
Rule 15    statement -> expression_statement
Rule 16    statement -> iterative_statement
Rule 17    statement -> conditional_statement
Rule 18    statement -> compound_statement
Rule 19    statement -> print_statement
Rule 20    statement -> function_call
Rule 21    statement -> variable_declaration
Rule 22    iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
Rule 23    iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 24    statement_list -> statement statement_list
Rule 25    print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 26    assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON
Rule 27    compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE
Rule 28    function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
Rule 29    declaration_list -> statement declaration_list
Rule 30    variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON
Rule 31    iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
Rule 32    program -> declaration_list
Rule 33    expression -> IDENTIFIER INCREMENT
Rule 34    factor -> literal
Rule 35    term -> term PRODUCT factor
Rule 36    arguments -> expression
Rule 37    function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 38    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 39    variable_declaration_list -> empty
Rule 40    assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 41    declaration_list -> function_declaration declaration_list
Rule 42    variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON
Rule 43    iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
Rule 44    literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
Rule 45    function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
Rule 46    statement_list -> empty
Rule 47    expression -> IDENTIFIER DECREMENT
Rule 48    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 49    term -> term DIVIDE factor
Rule 50    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
Rule 51    assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
Rule 52    declaration_list -> struct_declaration declaration_list
Rule 53    variable_declaration -> type_specifier IDENTIFIER SEMICOLON
Rule 54    iterative_statement -> FOR expression TO expression compound_statement
Rule 55    literal -> IDENTIFIER DOT IDENTIFIER
Rule 56    expression -> MINUS term
Rule 57    term -> factor
Rule 58    declaration_list -> empty
Rule 59    variable_declaration -> LET IDENTIFIER SEMICOLON
Rule 60    iterative_statement -> FOR expression TO expression STEP expression compound_statement
Rule 61    literal -> IDENTIFIER
Rule 62    expression -> expression NOT ASSIGN term
Rule 63    variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON
Rule 64    iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
Rule 65    literal -> DOUBLE
Rule 66    literal -> INTEGER
Rule 67    literal -> STRING
Rule 68    literal -> TRUE
Rule 69    literal -> FALSE
Rule 70    expression -> NOT term
Rule 71    iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
Rule 72    expression -> expression EXP term
Rule 73    iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
Rule 74    expression -> expression GTE term
Rule 75    iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
Rule 76    expression -> expression LTE term
Rule 77    expression -> expression IS GREATER THAN term
Rule 78    expression -> expression IS LESS THAN term
Rule 79    expression -> expression GT term
Rule 80    expression -> expression LT term
Rule 81    expression -> expression IS term
Rule 82    expression -> expression EQUALS term
Rule 83    expression -> expression OR term
Rule 84    expression -> expression AND term
Rule 85    expression -> expression PLUS term
Rule 86    expression -> expression MINUS term
Rule 87    expression -> term

Terminals, with rules where they appear

AND                  : 84
ASSIGN               : 30 40 42 51 62
BREAK                : 
COMMA                : 7
DECREMENT            : 47
DIVIDE               : 49
DO                   : 22
DOT                  : 51 55
DOUBLE               : 65
ELSE                 : 9 50
EQUALS               : 82
EXP                  : 72
FALSE                : 69
FOR                  : 31 43 54 60 64 71 73 75
FUNCTION             : 28 45
GREATER              : 77
GT                   : 79
GTE                  : 74
IDENTIFIER           : 8 10 26 28 30 33 37 40 42 44 44 45 47 51 51 53 55 55 59 61 63 63
IF                   : 9 38 50
IN                   : 26
INCREMENT            : 33
INTEGER              : 66
IS                   : 77 78 81
LEFT_BRACE           : 10 27
LEFT_BRACKET         : 44
LEFT_PAREN           : 8 9 22 23 25 28 31 37 38 43 45 48 50 64 71 73 75
LESS                 : 78
LET                  : 30 59
LOG                  : 25
LT                   : 80
LTE                  : 76
MINUS                : 56 86
MODULUS              : 
NOT                  : 62 70
OBJECT               : 
OR                   : 83
PLUS                 : 85
PRODUCT              : 35
PUT                  : 26
QUOTE                : 44 44
RETURN               : 
RIGHT_BRACE          : 10 27
RIGHT_BRACKET        : 44
RIGHT_PAREN          : 8 9 22 23 25 28 31 37 38 43 45 48 50 64 71 73 75
SEMICOLON            : 8 12 13 25 26 30 37 40 42 51 53 59 63 64 71 73 73 75 75
SKIP                 : 
STEP                 : 43 60
STRING               : 67
STRUCT               : 10
THAN                 : 77 78
TO                   : 31 43 54 60
TRUE                 : 68
TYPE_BOOL            : 1
TYPE_CHAR            : 3
TYPE_DOUBLE          : 4
TYPE_INT             : 2
TYPE_STRING          : 5
WHILE                : 22 23
error                : 

Nonterminals, with rules where they appear

arguments            : 7 25 28 37
assignment_statement : 14 64 73
compound_statement   : 9 9 18 22 23 28 31 38 43 45 50 54 60 64 71 73 75
conditional_statement : 17 50
declaration_list     : 29 32 41 52
empty                : 39 46 58
expression           : 7 9 12 22 23 26 30 31 31 36 38 40 42 43 43 43 48 50 51 54 54 60 60 60 62 64 71 71 72 73 73 74 75 75 75 76 77 78 79 80 81 82 83 84 85 86
expression_statement : 15
factor               : 35 49 57
function_call        : 20
function_declaration : 41
iterative_statement  : 16
literal              : 34
print_statement      : 19
program              : 0
statement            : 24 29
statement_list       : 24 27
struct_declaration   : 52
term                 : 35 49 56 62 70 72 74 76 77 78 79 80 81 82 83 84 85 86 87
type_specifier       : 42 53
variable_declaration : 11 21 64 71
variable_declaration_list : 10 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (32) program -> . declaration_list
    (29) declaration_list -> . statement declaration_list
    (41) declaration_list -> . function_declaration declaration_list
    (52) declaration_list -> . struct_declaration declaration_list
    (58) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (64) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    statement                      shift and go to state 3
    function_declaration           shift and go to state 4
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 1

    (0) S' -> program .



state 2

    (32) program -> declaration_list .

    $end            reduce using rule 32 (program -> declaration_list .)


state 3

    (29) declaration_list -> statement . declaration_list
    (29) declaration_list -> . statement declaration_list
    (41) declaration_list -> . function_declaration declaration_list
    (52) declaration_list -> . struct_declaration declaration_list
    (58) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (64) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement                      shift and go to state 3
    declaration_list               shift and go to state 45
    function_declaration           shift and go to state 4
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 4

    (41) declaration_list -> function_declaration . declaration_list
    (29) declaration_list -> . statement declaration_list
    (41) declaration_list -> . function_declaration declaration_list
    (52) declaration_list -> . struct_declaration declaration_list
    (58) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (64) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    function_declaration           shift and go to state 4
    declaration_list               shift and go to state 46
    statement                      shift and go to state 3
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 5

    (52) declaration_list -> struct_declaration . declaration_list
    (29) declaration_list -> . statement declaration_list
    (41) declaration_list -> . function_declaration declaration_list
    (52) declaration_list -> . struct_declaration declaration_list
    (58) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (64) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    struct_declaration             shift and go to state 5
    declaration_list               shift and go to state 47
    statement                      shift and go to state 3
    function_declaration           shift and go to state 4
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 6

    (58) declaration_list -> empty .

    $end            reduce using rule 58 (declaration_list -> empty .)


state 7

    (14) statement -> assignment_statement .

    FUNCTION        reduce using rule 14 (statement -> assignment_statement .)
    STRUCT          reduce using rule 14 (statement -> assignment_statement .)
    PUT             reduce using rule 14 (statement -> assignment_statement .)
    IDENTIFIER      reduce using rule 14 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 14 (statement -> assignment_statement .)
    DO              reduce using rule 14 (statement -> assignment_statement .)
    WHILE           reduce using rule 14 (statement -> assignment_statement .)
    FOR             reduce using rule 14 (statement -> assignment_statement .)
    IF              reduce using rule 14 (statement -> assignment_statement .)
    LEFT_BRACE      reduce using rule 14 (statement -> assignment_statement .)
    LOG             reduce using rule 14 (statement -> assignment_statement .)
    LET             reduce using rule 14 (statement -> assignment_statement .)
    MINUS           reduce using rule 14 (statement -> assignment_statement .)
    NOT             reduce using rule 14 (statement -> assignment_statement .)
    TYPE_BOOL       reduce using rule 14 (statement -> assignment_statement .)
    TYPE_INT        reduce using rule 14 (statement -> assignment_statement .)
    TYPE_CHAR       reduce using rule 14 (statement -> assignment_statement .)
    TYPE_DOUBLE     reduce using rule 14 (statement -> assignment_statement .)
    TYPE_STRING     reduce using rule 14 (statement -> assignment_statement .)
    LEFT_PAREN      reduce using rule 14 (statement -> assignment_statement .)
    DOUBLE          reduce using rule 14 (statement -> assignment_statement .)
    INTEGER         reduce using rule 14 (statement -> assignment_statement .)
    STRING          reduce using rule 14 (statement -> assignment_statement .)
    TRUE            reduce using rule 14 (statement -> assignment_statement .)
    FALSE           reduce using rule 14 (statement -> assignment_statement .)
    $end            reduce using rule 14 (statement -> assignment_statement .)
    RIGHT_BRACE     reduce using rule 14 (statement -> assignment_statement .)


state 8

    (15) statement -> expression_statement .

    FUNCTION        reduce using rule 15 (statement -> expression_statement .)
    STRUCT          reduce using rule 15 (statement -> expression_statement .)
    PUT             reduce using rule 15 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 15 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 15 (statement -> expression_statement .)
    DO              reduce using rule 15 (statement -> expression_statement .)
    WHILE           reduce using rule 15 (statement -> expression_statement .)
    FOR             reduce using rule 15 (statement -> expression_statement .)
    IF              reduce using rule 15 (statement -> expression_statement .)
    LEFT_BRACE      reduce using rule 15 (statement -> expression_statement .)
    LOG             reduce using rule 15 (statement -> expression_statement .)
    LET             reduce using rule 15 (statement -> expression_statement .)
    MINUS           reduce using rule 15 (statement -> expression_statement .)
    NOT             reduce using rule 15 (statement -> expression_statement .)
    TYPE_BOOL       reduce using rule 15 (statement -> expression_statement .)
    TYPE_INT        reduce using rule 15 (statement -> expression_statement .)
    TYPE_CHAR       reduce using rule 15 (statement -> expression_statement .)
    TYPE_DOUBLE     reduce using rule 15 (statement -> expression_statement .)
    TYPE_STRING     reduce using rule 15 (statement -> expression_statement .)
    LEFT_PAREN      reduce using rule 15 (statement -> expression_statement .)
    DOUBLE          reduce using rule 15 (statement -> expression_statement .)
    INTEGER         reduce using rule 15 (statement -> expression_statement .)
    STRING          reduce using rule 15 (statement -> expression_statement .)
    TRUE            reduce using rule 15 (statement -> expression_statement .)
    FALSE           reduce using rule 15 (statement -> expression_statement .)
    $end            reduce using rule 15 (statement -> expression_statement .)
    RIGHT_BRACE     reduce using rule 15 (statement -> expression_statement .)


state 9

    (16) statement -> iterative_statement .

    FUNCTION        reduce using rule 16 (statement -> iterative_statement .)
    STRUCT          reduce using rule 16 (statement -> iterative_statement .)
    PUT             reduce using rule 16 (statement -> iterative_statement .)
    IDENTIFIER      reduce using rule 16 (statement -> iterative_statement .)
    SEMICOLON       reduce using rule 16 (statement -> iterative_statement .)
    DO              reduce using rule 16 (statement -> iterative_statement .)
    WHILE           reduce using rule 16 (statement -> iterative_statement .)
    FOR             reduce using rule 16 (statement -> iterative_statement .)
    IF              reduce using rule 16 (statement -> iterative_statement .)
    LEFT_BRACE      reduce using rule 16 (statement -> iterative_statement .)
    LOG             reduce using rule 16 (statement -> iterative_statement .)
    LET             reduce using rule 16 (statement -> iterative_statement .)
    MINUS           reduce using rule 16 (statement -> iterative_statement .)
    NOT             reduce using rule 16 (statement -> iterative_statement .)
    TYPE_BOOL       reduce using rule 16 (statement -> iterative_statement .)
    TYPE_INT        reduce using rule 16 (statement -> iterative_statement .)
    TYPE_CHAR       reduce using rule 16 (statement -> iterative_statement .)
    TYPE_DOUBLE     reduce using rule 16 (statement -> iterative_statement .)
    TYPE_STRING     reduce using rule 16 (statement -> iterative_statement .)
    LEFT_PAREN      reduce using rule 16 (statement -> iterative_statement .)
    DOUBLE          reduce using rule 16 (statement -> iterative_statement .)
    INTEGER         reduce using rule 16 (statement -> iterative_statement .)
    STRING          reduce using rule 16 (statement -> iterative_statement .)
    TRUE            reduce using rule 16 (statement -> iterative_statement .)
    FALSE           reduce using rule 16 (statement -> iterative_statement .)
    $end            reduce using rule 16 (statement -> iterative_statement .)
    RIGHT_BRACE     reduce using rule 16 (statement -> iterative_statement .)


state 10

    (17) statement -> conditional_statement .

    FUNCTION        reduce using rule 17 (statement -> conditional_statement .)
    STRUCT          reduce using rule 17 (statement -> conditional_statement .)
    PUT             reduce using rule 17 (statement -> conditional_statement .)
    IDENTIFIER      reduce using rule 17 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 17 (statement -> conditional_statement .)
    DO              reduce using rule 17 (statement -> conditional_statement .)
    WHILE           reduce using rule 17 (statement -> conditional_statement .)
    FOR             reduce using rule 17 (statement -> conditional_statement .)
    IF              reduce using rule 17 (statement -> conditional_statement .)
    LEFT_BRACE      reduce using rule 17 (statement -> conditional_statement .)
    LOG             reduce using rule 17 (statement -> conditional_statement .)
    LET             reduce using rule 17 (statement -> conditional_statement .)
    MINUS           reduce using rule 17 (statement -> conditional_statement .)
    NOT             reduce using rule 17 (statement -> conditional_statement .)
    TYPE_BOOL       reduce using rule 17 (statement -> conditional_statement .)
    TYPE_INT        reduce using rule 17 (statement -> conditional_statement .)
    TYPE_CHAR       reduce using rule 17 (statement -> conditional_statement .)
    TYPE_DOUBLE     reduce using rule 17 (statement -> conditional_statement .)
    TYPE_STRING     reduce using rule 17 (statement -> conditional_statement .)
    LEFT_PAREN      reduce using rule 17 (statement -> conditional_statement .)
    DOUBLE          reduce using rule 17 (statement -> conditional_statement .)
    INTEGER         reduce using rule 17 (statement -> conditional_statement .)
    STRING          reduce using rule 17 (statement -> conditional_statement .)
    TRUE            reduce using rule 17 (statement -> conditional_statement .)
    FALSE           reduce using rule 17 (statement -> conditional_statement .)
    $end            reduce using rule 17 (statement -> conditional_statement .)
    RIGHT_BRACE     reduce using rule 17 (statement -> conditional_statement .)


state 11

    (18) statement -> compound_statement .

    FUNCTION        reduce using rule 18 (statement -> compound_statement .)
    STRUCT          reduce using rule 18 (statement -> compound_statement .)
    PUT             reduce using rule 18 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 18 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 18 (statement -> compound_statement .)
    DO              reduce using rule 18 (statement -> compound_statement .)
    WHILE           reduce using rule 18 (statement -> compound_statement .)
    FOR             reduce using rule 18 (statement -> compound_statement .)
    IF              reduce using rule 18 (statement -> compound_statement .)
    LEFT_BRACE      reduce using rule 18 (statement -> compound_statement .)
    LOG             reduce using rule 18 (statement -> compound_statement .)
    LET             reduce using rule 18 (statement -> compound_statement .)
    MINUS           reduce using rule 18 (statement -> compound_statement .)
    NOT             reduce using rule 18 (statement -> compound_statement .)
    TYPE_BOOL       reduce using rule 18 (statement -> compound_statement .)
    TYPE_INT        reduce using rule 18 (statement -> compound_statement .)
    TYPE_CHAR       reduce using rule 18 (statement -> compound_statement .)
    TYPE_DOUBLE     reduce using rule 18 (statement -> compound_statement .)
    TYPE_STRING     reduce using rule 18 (statement -> compound_statement .)
    LEFT_PAREN      reduce using rule 18 (statement -> compound_statement .)
    DOUBLE          reduce using rule 18 (statement -> compound_statement .)
    INTEGER         reduce using rule 18 (statement -> compound_statement .)
    STRING          reduce using rule 18 (statement -> compound_statement .)
    TRUE            reduce using rule 18 (statement -> compound_statement .)
    FALSE           reduce using rule 18 (statement -> compound_statement .)
    $end            reduce using rule 18 (statement -> compound_statement .)
    RIGHT_BRACE     reduce using rule 18 (statement -> compound_statement .)


state 12

    (19) statement -> print_statement .

    FUNCTION        reduce using rule 19 (statement -> print_statement .)
    STRUCT          reduce using rule 19 (statement -> print_statement .)
    PUT             reduce using rule 19 (statement -> print_statement .)
    IDENTIFIER      reduce using rule 19 (statement -> print_statement .)
    SEMICOLON       reduce using rule 19 (statement -> print_statement .)
    DO              reduce using rule 19 (statement -> print_statement .)
    WHILE           reduce using rule 19 (statement -> print_statement .)
    FOR             reduce using rule 19 (statement -> print_statement .)
    IF              reduce using rule 19 (statement -> print_statement .)
    LEFT_BRACE      reduce using rule 19 (statement -> print_statement .)
    LOG             reduce using rule 19 (statement -> print_statement .)
    LET             reduce using rule 19 (statement -> print_statement .)
    MINUS           reduce using rule 19 (statement -> print_statement .)
    NOT             reduce using rule 19 (statement -> print_statement .)
    TYPE_BOOL       reduce using rule 19 (statement -> print_statement .)
    TYPE_INT        reduce using rule 19 (statement -> print_statement .)
    TYPE_CHAR       reduce using rule 19 (statement -> print_statement .)
    TYPE_DOUBLE     reduce using rule 19 (statement -> print_statement .)
    TYPE_STRING     reduce using rule 19 (statement -> print_statement .)
    LEFT_PAREN      reduce using rule 19 (statement -> print_statement .)
    DOUBLE          reduce using rule 19 (statement -> print_statement .)
    INTEGER         reduce using rule 19 (statement -> print_statement .)
    STRING          reduce using rule 19 (statement -> print_statement .)
    TRUE            reduce using rule 19 (statement -> print_statement .)
    FALSE           reduce using rule 19 (statement -> print_statement .)
    $end            reduce using rule 19 (statement -> print_statement .)
    RIGHT_BRACE     reduce using rule 19 (statement -> print_statement .)


state 13

    (20) statement -> function_call .

    FUNCTION        reduce using rule 20 (statement -> function_call .)
    STRUCT          reduce using rule 20 (statement -> function_call .)
    PUT             reduce using rule 20 (statement -> function_call .)
    IDENTIFIER      reduce using rule 20 (statement -> function_call .)
    SEMICOLON       reduce using rule 20 (statement -> function_call .)
    DO              reduce using rule 20 (statement -> function_call .)
    WHILE           reduce using rule 20 (statement -> function_call .)
    FOR             reduce using rule 20 (statement -> function_call .)
    IF              reduce using rule 20 (statement -> function_call .)
    LEFT_BRACE      reduce using rule 20 (statement -> function_call .)
    LOG             reduce using rule 20 (statement -> function_call .)
    LET             reduce using rule 20 (statement -> function_call .)
    MINUS           reduce using rule 20 (statement -> function_call .)
    NOT             reduce using rule 20 (statement -> function_call .)
    TYPE_BOOL       reduce using rule 20 (statement -> function_call .)
    TYPE_INT        reduce using rule 20 (statement -> function_call .)
    TYPE_CHAR       reduce using rule 20 (statement -> function_call .)
    TYPE_DOUBLE     reduce using rule 20 (statement -> function_call .)
    TYPE_STRING     reduce using rule 20 (statement -> function_call .)
    LEFT_PAREN      reduce using rule 20 (statement -> function_call .)
    DOUBLE          reduce using rule 20 (statement -> function_call .)
    INTEGER         reduce using rule 20 (statement -> function_call .)
    STRING          reduce using rule 20 (statement -> function_call .)
    TRUE            reduce using rule 20 (statement -> function_call .)
    FALSE           reduce using rule 20 (statement -> function_call .)
    $end            reduce using rule 20 (statement -> function_call .)
    RIGHT_BRACE     reduce using rule 20 (statement -> function_call .)


state 14

    (21) statement -> variable_declaration .

    FUNCTION        reduce using rule 21 (statement -> variable_declaration .)
    STRUCT          reduce using rule 21 (statement -> variable_declaration .)
    PUT             reduce using rule 21 (statement -> variable_declaration .)
    IDENTIFIER      reduce using rule 21 (statement -> variable_declaration .)
    SEMICOLON       reduce using rule 21 (statement -> variable_declaration .)
    DO              reduce using rule 21 (statement -> variable_declaration .)
    WHILE           reduce using rule 21 (statement -> variable_declaration .)
    FOR             reduce using rule 21 (statement -> variable_declaration .)
    IF              reduce using rule 21 (statement -> variable_declaration .)
    LEFT_BRACE      reduce using rule 21 (statement -> variable_declaration .)
    LOG             reduce using rule 21 (statement -> variable_declaration .)
    LET             reduce using rule 21 (statement -> variable_declaration .)
    MINUS           reduce using rule 21 (statement -> variable_declaration .)
    NOT             reduce using rule 21 (statement -> variable_declaration .)
    TYPE_BOOL       reduce using rule 21 (statement -> variable_declaration .)
    TYPE_INT        reduce using rule 21 (statement -> variable_declaration .)
    TYPE_CHAR       reduce using rule 21 (statement -> variable_declaration .)
    TYPE_DOUBLE     reduce using rule 21 (statement -> variable_declaration .)
    TYPE_STRING     reduce using rule 21 (statement -> variable_declaration .)
    LEFT_PAREN      reduce using rule 21 (statement -> variable_declaration .)
    DOUBLE          reduce using rule 21 (statement -> variable_declaration .)
    INTEGER         reduce using rule 21 (statement -> variable_declaration .)
    STRING          reduce using rule 21 (statement -> variable_declaration .)
    TRUE            reduce using rule 21 (statement -> variable_declaration .)
    FALSE           reduce using rule 21 (statement -> variable_declaration .)
    $end            reduce using rule 21 (statement -> variable_declaration .)
    RIGHT_BRACE     reduce using rule 21 (statement -> variable_declaration .)


state 15

    (28) function_declaration -> FUNCTION . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> FUNCTION . IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement

    IDENTIFIER      shift and go to state 48


state 16

    (40) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (51) assignment_statement -> IDENTIFIER . DOT IDENTIFIER ASSIGN expression SEMICOLON
    (8) function_call -> IDENTIFIER . LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (63) variable_declaration -> IDENTIFIER . IDENTIFIER SEMICOLON
    (33) expression -> IDENTIFIER . INCREMENT
    (47) expression -> IDENTIFIER . DECREMENT
    (44) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> IDENTIFIER . DOT IDENTIFIER
    (61) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 50
    DOT             shift and go to state 51
    LEFT_PAREN      shift and go to state 52
    IDENTIFIER      shift and go to state 49
    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    LEFT_BRACKET    shift and go to state 55
    PRODUCT         reduce using rule 61 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (literal -> IDENTIFIER .)
    NOT             reduce using rule 61 (literal -> IDENTIFIER .)
    EXP             reduce using rule 61 (literal -> IDENTIFIER .)
    GTE             reduce using rule 61 (literal -> IDENTIFIER .)
    LTE             reduce using rule 61 (literal -> IDENTIFIER .)
    IS              reduce using rule 61 (literal -> IDENTIFIER .)
    GT              reduce using rule 61 (literal -> IDENTIFIER .)
    LT              reduce using rule 61 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 61 (literal -> IDENTIFIER .)
    OR              reduce using rule 61 (literal -> IDENTIFIER .)
    AND             reduce using rule 61 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 61 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 61 (literal -> IDENTIFIER .)


state 17

    (48) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 56
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 18

    (10) struct_declaration -> STRUCT . IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE

    IDENTIFIER      shift and go to state 58


state 19

    (27) compound_statement -> LEFT_BRACE . statement_list RIGHT_BRACE
    (24) statement_list -> . statement statement_list
    (46) statement_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (64) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement_list                 shift and go to state 59
    statement                      shift and go to state 60
    empty                          shift and go to state 61
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 20

    (26) assignment_statement -> PUT . expression IN IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 62
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 21

    (12) expression_statement -> expression . SEMICOLON
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 63
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 22

    (13) expression_statement -> SEMICOLON .

    FUNCTION        reduce using rule 13 (expression_statement -> SEMICOLON .)
    STRUCT          reduce using rule 13 (expression_statement -> SEMICOLON .)
    PUT             reduce using rule 13 (expression_statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (expression_statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 13 (expression_statement -> SEMICOLON .)
    DO              reduce using rule 13 (expression_statement -> SEMICOLON .)
    WHILE           reduce using rule 13 (expression_statement -> SEMICOLON .)
    FOR             reduce using rule 13 (expression_statement -> SEMICOLON .)
    IF              reduce using rule 13 (expression_statement -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 13 (expression_statement -> SEMICOLON .)
    LOG             reduce using rule 13 (expression_statement -> SEMICOLON .)
    LET             reduce using rule 13 (expression_statement -> SEMICOLON .)
    MINUS           reduce using rule 13 (expression_statement -> SEMICOLON .)
    NOT             reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_BOOL       reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_INT        reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_STRING     reduce using rule 13 (expression_statement -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 13 (expression_statement -> SEMICOLON .)
    DOUBLE          reduce using rule 13 (expression_statement -> SEMICOLON .)
    INTEGER         reduce using rule 13 (expression_statement -> SEMICOLON .)
    STRING          reduce using rule 13 (expression_statement -> SEMICOLON .)
    TRUE            reduce using rule 13 (expression_statement -> SEMICOLON .)
    FALSE           reduce using rule 13 (expression_statement -> SEMICOLON .)
    $end            reduce using rule 13 (expression_statement -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 13 (expression_statement -> SEMICOLON .)


state 23

    (22) iterative_statement -> DO . compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 76

state 24

    (23) iterative_statement -> WHILE . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 77


state 25

    (31) iterative_statement -> FOR . LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR . LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> FOR . expression TO expression compound_statement
    (60) iterative_statement -> FOR . expression TO expression STEP expression compound_statement
    (64) iterative_statement -> FOR . LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR . LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR . LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR . LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 78
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 79
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 26

    (9) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement

    LEFT_PAREN      shift and go to state 80


state 27

    (25) print_statement -> LOG . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 81


state 28

    (30) variable_declaration -> LET . IDENTIFIER ASSIGN expression SEMICOLON
    (59) variable_declaration -> LET . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 82


state 29

    (42) variable_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> type_specifier . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 83


state 30

    (56) expression -> MINUS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 84
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 31

    (87) expression -> term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 87 (expression -> term .)
    NOT             reduce using rule 87 (expression -> term .)
    EXP             reduce using rule 87 (expression -> term .)
    GTE             reduce using rule 87 (expression -> term .)
    LTE             reduce using rule 87 (expression -> term .)
    IS              reduce using rule 87 (expression -> term .)
    GT              reduce using rule 87 (expression -> term .)
    LT              reduce using rule 87 (expression -> term .)
    EQUALS          reduce using rule 87 (expression -> term .)
    OR              reduce using rule 87 (expression -> term .)
    AND             reduce using rule 87 (expression -> term .)
    PLUS            reduce using rule 87 (expression -> term .)
    MINUS           reduce using rule 87 (expression -> term .)
    RIGHT_PAREN     reduce using rule 87 (expression -> term .)
    IN              reduce using rule 87 (expression -> term .)
    TO              reduce using rule 87 (expression -> term .)
    COMMA           reduce using rule 87 (expression -> term .)
    STEP            reduce using rule 87 (expression -> term .)
    LEFT_BRACE      reduce using rule 87 (expression -> term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 32

    (70) expression -> NOT . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 88
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 33

    (1) type_specifier -> TYPE_BOOL .

    IDENTIFIER      reduce using rule 1 (type_specifier -> TYPE_BOOL .)


state 34

    (2) type_specifier -> TYPE_INT .

    IDENTIFIER      reduce using rule 2 (type_specifier -> TYPE_INT .)


state 35

    (3) type_specifier -> TYPE_CHAR .

    IDENTIFIER      reduce using rule 3 (type_specifier -> TYPE_CHAR .)


state 36

    (4) type_specifier -> TYPE_DOUBLE .

    IDENTIFIER      reduce using rule 4 (type_specifier -> TYPE_DOUBLE .)


state 37

    (5) type_specifier -> TYPE_STRING .

    IDENTIFIER      reduce using rule 5 (type_specifier -> TYPE_STRING .)


state 38

    (57) term -> factor .

    PRODUCT         reduce using rule 57 (term -> factor .)
    DIVIDE          reduce using rule 57 (term -> factor .)
    SEMICOLON       reduce using rule 57 (term -> factor .)
    NOT             reduce using rule 57 (term -> factor .)
    EXP             reduce using rule 57 (term -> factor .)
    GTE             reduce using rule 57 (term -> factor .)
    LTE             reduce using rule 57 (term -> factor .)
    IS              reduce using rule 57 (term -> factor .)
    GT              reduce using rule 57 (term -> factor .)
    LT              reduce using rule 57 (term -> factor .)
    EQUALS          reduce using rule 57 (term -> factor .)
    OR              reduce using rule 57 (term -> factor .)
    AND             reduce using rule 57 (term -> factor .)
    PLUS            reduce using rule 57 (term -> factor .)
    MINUS           reduce using rule 57 (term -> factor .)
    RIGHT_PAREN     reduce using rule 57 (term -> factor .)
    IN              reduce using rule 57 (term -> factor .)
    TO              reduce using rule 57 (term -> factor .)
    COMMA           reduce using rule 57 (term -> factor .)
    STEP            reduce using rule 57 (term -> factor .)
    LEFT_BRACE      reduce using rule 57 (term -> factor .)


state 39

    (34) factor -> literal .

    PRODUCT         reduce using rule 34 (factor -> literal .)
    DIVIDE          reduce using rule 34 (factor -> literal .)
    SEMICOLON       reduce using rule 34 (factor -> literal .)
    NOT             reduce using rule 34 (factor -> literal .)
    EXP             reduce using rule 34 (factor -> literal .)
    GTE             reduce using rule 34 (factor -> literal .)
    LTE             reduce using rule 34 (factor -> literal .)
    IS              reduce using rule 34 (factor -> literal .)
    GT              reduce using rule 34 (factor -> literal .)
    LT              reduce using rule 34 (factor -> literal .)
    EQUALS          reduce using rule 34 (factor -> literal .)
    OR              reduce using rule 34 (factor -> literal .)
    AND             reduce using rule 34 (factor -> literal .)
    PLUS            reduce using rule 34 (factor -> literal .)
    MINUS           reduce using rule 34 (factor -> literal .)
    RIGHT_PAREN     reduce using rule 34 (factor -> literal .)
    IN              reduce using rule 34 (factor -> literal .)
    TO              reduce using rule 34 (factor -> literal .)
    COMMA           reduce using rule 34 (factor -> literal .)
    STEP            reduce using rule 34 (factor -> literal .)
    LEFT_BRACE      reduce using rule 34 (factor -> literal .)


state 40

    (65) literal -> DOUBLE .

    PRODUCT         reduce using rule 65 (literal -> DOUBLE .)
    DIVIDE          reduce using rule 65 (literal -> DOUBLE .)
    SEMICOLON       reduce using rule 65 (literal -> DOUBLE .)
    NOT             reduce using rule 65 (literal -> DOUBLE .)
    EXP             reduce using rule 65 (literal -> DOUBLE .)
    GTE             reduce using rule 65 (literal -> DOUBLE .)
    LTE             reduce using rule 65 (literal -> DOUBLE .)
    IS              reduce using rule 65 (literal -> DOUBLE .)
    GT              reduce using rule 65 (literal -> DOUBLE .)
    LT              reduce using rule 65 (literal -> DOUBLE .)
    EQUALS          reduce using rule 65 (literal -> DOUBLE .)
    OR              reduce using rule 65 (literal -> DOUBLE .)
    AND             reduce using rule 65 (literal -> DOUBLE .)
    PLUS            reduce using rule 65 (literal -> DOUBLE .)
    MINUS           reduce using rule 65 (literal -> DOUBLE .)
    RIGHT_PAREN     reduce using rule 65 (literal -> DOUBLE .)
    IN              reduce using rule 65 (literal -> DOUBLE .)
    TO              reduce using rule 65 (literal -> DOUBLE .)
    COMMA           reduce using rule 65 (literal -> DOUBLE .)
    STEP            reduce using rule 65 (literal -> DOUBLE .)
    LEFT_BRACE      reduce using rule 65 (literal -> DOUBLE .)


state 41

    (66) literal -> INTEGER .

    PRODUCT         reduce using rule 66 (literal -> INTEGER .)
    DIVIDE          reduce using rule 66 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 66 (literal -> INTEGER .)
    NOT             reduce using rule 66 (literal -> INTEGER .)
    EXP             reduce using rule 66 (literal -> INTEGER .)
    GTE             reduce using rule 66 (literal -> INTEGER .)
    LTE             reduce using rule 66 (literal -> INTEGER .)
    IS              reduce using rule 66 (literal -> INTEGER .)
    GT              reduce using rule 66 (literal -> INTEGER .)
    LT              reduce using rule 66 (literal -> INTEGER .)
    EQUALS          reduce using rule 66 (literal -> INTEGER .)
    OR              reduce using rule 66 (literal -> INTEGER .)
    AND             reduce using rule 66 (literal -> INTEGER .)
    PLUS            reduce using rule 66 (literal -> INTEGER .)
    MINUS           reduce using rule 66 (literal -> INTEGER .)
    RIGHT_PAREN     reduce using rule 66 (literal -> INTEGER .)
    IN              reduce using rule 66 (literal -> INTEGER .)
    TO              reduce using rule 66 (literal -> INTEGER .)
    COMMA           reduce using rule 66 (literal -> INTEGER .)
    STEP            reduce using rule 66 (literal -> INTEGER .)
    LEFT_BRACE      reduce using rule 66 (literal -> INTEGER .)


state 42

    (67) literal -> STRING .

    PRODUCT         reduce using rule 67 (literal -> STRING .)
    DIVIDE          reduce using rule 67 (literal -> STRING .)
    SEMICOLON       reduce using rule 67 (literal -> STRING .)
    NOT             reduce using rule 67 (literal -> STRING .)
    EXP             reduce using rule 67 (literal -> STRING .)
    GTE             reduce using rule 67 (literal -> STRING .)
    LTE             reduce using rule 67 (literal -> STRING .)
    IS              reduce using rule 67 (literal -> STRING .)
    GT              reduce using rule 67 (literal -> STRING .)
    LT              reduce using rule 67 (literal -> STRING .)
    EQUALS          reduce using rule 67 (literal -> STRING .)
    OR              reduce using rule 67 (literal -> STRING .)
    AND             reduce using rule 67 (literal -> STRING .)
    PLUS            reduce using rule 67 (literal -> STRING .)
    MINUS           reduce using rule 67 (literal -> STRING .)
    RIGHT_PAREN     reduce using rule 67 (literal -> STRING .)
    IN              reduce using rule 67 (literal -> STRING .)
    TO              reduce using rule 67 (literal -> STRING .)
    COMMA           reduce using rule 67 (literal -> STRING .)
    STEP            reduce using rule 67 (literal -> STRING .)
    LEFT_BRACE      reduce using rule 67 (literal -> STRING .)


state 43

    (68) literal -> TRUE .

    PRODUCT         reduce using rule 68 (literal -> TRUE .)
    DIVIDE          reduce using rule 68 (literal -> TRUE .)
    SEMICOLON       reduce using rule 68 (literal -> TRUE .)
    NOT             reduce using rule 68 (literal -> TRUE .)
    EXP             reduce using rule 68 (literal -> TRUE .)
    GTE             reduce using rule 68 (literal -> TRUE .)
    LTE             reduce using rule 68 (literal -> TRUE .)
    IS              reduce using rule 68 (literal -> TRUE .)
    GT              reduce using rule 68 (literal -> TRUE .)
    LT              reduce using rule 68 (literal -> TRUE .)
    EQUALS          reduce using rule 68 (literal -> TRUE .)
    OR              reduce using rule 68 (literal -> TRUE .)
    AND             reduce using rule 68 (literal -> TRUE .)
    PLUS            reduce using rule 68 (literal -> TRUE .)
    MINUS           reduce using rule 68 (literal -> TRUE .)
    RIGHT_PAREN     reduce using rule 68 (literal -> TRUE .)
    IN              reduce using rule 68 (literal -> TRUE .)
    TO              reduce using rule 68 (literal -> TRUE .)
    COMMA           reduce using rule 68 (literal -> TRUE .)
    STEP            reduce using rule 68 (literal -> TRUE .)
    LEFT_BRACE      reduce using rule 68 (literal -> TRUE .)


state 44

    (69) literal -> FALSE .

    PRODUCT         reduce using rule 69 (literal -> FALSE .)
    DIVIDE          reduce using rule 69 (literal -> FALSE .)
    SEMICOLON       reduce using rule 69 (literal -> FALSE .)
    NOT             reduce using rule 69 (literal -> FALSE .)
    EXP             reduce using rule 69 (literal -> FALSE .)
    GTE             reduce using rule 69 (literal -> FALSE .)
    LTE             reduce using rule 69 (literal -> FALSE .)
    IS              reduce using rule 69 (literal -> FALSE .)
    GT              reduce using rule 69 (literal -> FALSE .)
    LT              reduce using rule 69 (literal -> FALSE .)
    EQUALS          reduce using rule 69 (literal -> FALSE .)
    OR              reduce using rule 69 (literal -> FALSE .)
    AND             reduce using rule 69 (literal -> FALSE .)
    PLUS            reduce using rule 69 (literal -> FALSE .)
    MINUS           reduce using rule 69 (literal -> FALSE .)
    RIGHT_PAREN     reduce using rule 69 (literal -> FALSE .)
    IN              reduce using rule 69 (literal -> FALSE .)
    TO              reduce using rule 69 (literal -> FALSE .)
    COMMA           reduce using rule 69 (literal -> FALSE .)
    STEP            reduce using rule 69 (literal -> FALSE .)
    LEFT_BRACE      reduce using rule 69 (literal -> FALSE .)


state 45

    (29) declaration_list -> statement declaration_list .

    $end            reduce using rule 29 (declaration_list -> statement declaration_list .)


state 46

    (41) declaration_list -> function_declaration declaration_list .

    $end            reduce using rule 41 (declaration_list -> function_declaration declaration_list .)


state 47

    (52) declaration_list -> struct_declaration declaration_list .

    $end            reduce using rule 52 (declaration_list -> struct_declaration declaration_list .)


state 48

    (28) function_declaration -> FUNCTION IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> FUNCTION IDENTIFIER . LEFT_PAREN RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 89


state 49

    (63) variable_declaration -> IDENTIFIER IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 90


state 50

    (40) assignment_statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 91
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 51

    (51) assignment_statement -> IDENTIFIER DOT . IDENTIFIER ASSIGN expression SEMICOLON
    (55) literal -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 92


state 52

    (8) function_call -> IDENTIFIER LEFT_PAREN . RIGHT_PAREN SEMICOLON
    (37) function_call -> IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 93
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 94
    expression                     shift and go to state 95
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 53

    (33) expression -> IDENTIFIER INCREMENT .

    SEMICOLON       reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    NOT             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    EXP             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    GTE             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LTE             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IS              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    GT              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LT              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    EQUALS          reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    OR              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    AND             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    PLUS            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    MINUS           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    RIGHT_PAREN     reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IN              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TO              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    COMMA           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    STEP            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LEFT_BRACE      reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)


state 54

    (47) expression -> IDENTIFIER DECREMENT .

    SEMICOLON       reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    NOT             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    EXP             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    GTE             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    LTE             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    IS              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    GT              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    LT              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    EQUALS          reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    OR              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    AND             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    PLUS            reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    MINUS           reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    RIGHT_PAREN     reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    IN              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    TO              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    COMMA           reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    STEP            reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    LEFT_BRACE      reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)


state 55

    (44) literal -> IDENTIFIER LEFT_BRACKET . QUOTE IDENTIFIER QUOTE RIGHT_BRACKET

    QUOTE           shift and go to state 96


state 56

    (48) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 97
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 57

    (33) expression -> IDENTIFIER . INCREMENT
    (47) expression -> IDENTIFIER . DECREMENT
    (44) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> IDENTIFIER . DOT IDENTIFIER
    (61) literal -> IDENTIFIER .

    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    LEFT_BRACKET    shift and go to state 55
    DOT             shift and go to state 98
    PRODUCT         reduce using rule 61 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 61 (literal -> IDENTIFIER .)
    NOT             reduce using rule 61 (literal -> IDENTIFIER .)
    EXP             reduce using rule 61 (literal -> IDENTIFIER .)
    GTE             reduce using rule 61 (literal -> IDENTIFIER .)
    LTE             reduce using rule 61 (literal -> IDENTIFIER .)
    IS              reduce using rule 61 (literal -> IDENTIFIER .)
    GT              reduce using rule 61 (literal -> IDENTIFIER .)
    LT              reduce using rule 61 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 61 (literal -> IDENTIFIER .)
    OR              reduce using rule 61 (literal -> IDENTIFIER .)
    AND             reduce using rule 61 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 61 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 61 (literal -> IDENTIFIER .)
    IN              reduce using rule 61 (literal -> IDENTIFIER .)
    TO              reduce using rule 61 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 61 (literal -> IDENTIFIER .)
    STEP            reduce using rule 61 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 61 (literal -> IDENTIFIER .)


state 58

    (10) struct_declaration -> STRUCT IDENTIFIER . LEFT_BRACE variable_declaration_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 99


state 59

    (27) compound_statement -> LEFT_BRACE statement_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 100


state 60

    (24) statement_list -> statement . statement_list
    (24) statement_list -> . statement statement_list
    (46) statement_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (64) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement                      shift and go to state 60
    statement_list                 shift and go to state 101
    empty                          shift and go to state 61
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 61

    (46) statement_list -> empty .

    RIGHT_BRACE     reduce using rule 46 (statement_list -> empty .)


state 62

    (26) assignment_statement -> PUT expression . IN IDENTIFIER SEMICOLON
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    IN              shift and go to state 102
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 63

    (12) expression_statement -> expression SEMICOLON .

    FUNCTION        reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    STRUCT          reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    PUT             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    DO              reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LOG             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LET             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_STRING     reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    STRING          reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TRUE            reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    FALSE           reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    $end            reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 12 (expression_statement -> expression SEMICOLON .)


state 64

    (62) expression -> expression NOT . ASSIGN term

    ASSIGN          shift and go to state 103


state 65

    (72) expression -> expression EXP . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 104
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 66

    (74) expression -> expression GTE . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 105
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 67

    (76) expression -> expression LTE . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 106
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 68

    (77) expression -> expression IS . GREATER THAN term
    (78) expression -> expression IS . LESS THAN term
    (81) expression -> expression IS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    GREATER         shift and go to state 107
    LESS            shift and go to state 109
    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 108
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 69

    (79) expression -> expression GT . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 110
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 70

    (80) expression -> expression LT . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 111
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 71

    (82) expression -> expression EQUALS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 112
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 72

    (83) expression -> expression OR . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 113
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 73

    (84) expression -> expression AND . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 114
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 74

    (85) expression -> expression PLUS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 115
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 75

    (86) expression -> expression MINUS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 116
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 76

    (22) iterative_statement -> DO compound_statement . WHILE LEFT_PAREN expression RIGHT_PAREN

    WHILE           shift and go to state 117


state 77

    (23) iterative_statement -> WHILE LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 118
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 78

    (31) iterative_statement -> FOR LEFT_PAREN . expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN . expression TO expression STEP expression RIGHT_PAREN compound_statement
    (64) iterative_statement -> FOR LEFT_PAREN . variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR LEFT_PAREN . variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR LEFT_PAREN . expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN . expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (48) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 121
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LET             shift and go to state 28
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 119
    variable_declaration           shift and go to state 120
    term                           shift and go to state 31
    type_specifier                 shift and go to state 29
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 79

    (54) iterative_statement -> FOR expression . TO expression compound_statement
    (60) iterative_statement -> FOR expression . TO expression STEP expression compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    TO              shift and go to state 122
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 80

    (9) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 123
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 81

    (25) print_statement -> LOG LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 124
    expression                     shift and go to state 95
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 82

    (30) variable_declaration -> LET IDENTIFIER . ASSIGN expression SEMICOLON
    (59) variable_declaration -> LET IDENTIFIER . SEMICOLON

    ASSIGN          shift and go to state 125
    SEMICOLON       shift and go to state 126


state 83

    (42) variable_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON
    (53) variable_declaration -> type_specifier IDENTIFIER . SEMICOLON

    ASSIGN          shift and go to state 127
    SEMICOLON       shift and go to state 128


state 84

    (56) expression -> MINUS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 56 (expression -> MINUS term .)
    NOT             reduce using rule 56 (expression -> MINUS term .)
    EXP             reduce using rule 56 (expression -> MINUS term .)
    GTE             reduce using rule 56 (expression -> MINUS term .)
    LTE             reduce using rule 56 (expression -> MINUS term .)
    IS              reduce using rule 56 (expression -> MINUS term .)
    GT              reduce using rule 56 (expression -> MINUS term .)
    LT              reduce using rule 56 (expression -> MINUS term .)
    EQUALS          reduce using rule 56 (expression -> MINUS term .)
    OR              reduce using rule 56 (expression -> MINUS term .)
    AND             reduce using rule 56 (expression -> MINUS term .)
    PLUS            reduce using rule 56 (expression -> MINUS term .)
    MINUS           reduce using rule 56 (expression -> MINUS term .)
    RIGHT_PAREN     reduce using rule 56 (expression -> MINUS term .)
    IN              reduce using rule 56 (expression -> MINUS term .)
    TO              reduce using rule 56 (expression -> MINUS term .)
    COMMA           reduce using rule 56 (expression -> MINUS term .)
    STEP            reduce using rule 56 (expression -> MINUS term .)
    LEFT_BRACE      reduce using rule 56 (expression -> MINUS term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 85

    (44) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> IDENTIFIER . DOT IDENTIFIER
    (61) literal -> IDENTIFIER .

    LEFT_BRACKET    shift and go to state 55
    DOT             shift and go to state 98
    PRODUCT         reduce using rule 61 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (literal -> IDENTIFIER .)
    NOT             reduce using rule 61 (literal -> IDENTIFIER .)
    EXP             reduce using rule 61 (literal -> IDENTIFIER .)
    GTE             reduce using rule 61 (literal -> IDENTIFIER .)
    LTE             reduce using rule 61 (literal -> IDENTIFIER .)
    IS              reduce using rule 61 (literal -> IDENTIFIER .)
    GT              reduce using rule 61 (literal -> IDENTIFIER .)
    LT              reduce using rule 61 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 61 (literal -> IDENTIFIER .)
    OR              reduce using rule 61 (literal -> IDENTIFIER .)
    AND             reduce using rule 61 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 61 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 61 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 61 (literal -> IDENTIFIER .)
    IN              reduce using rule 61 (literal -> IDENTIFIER .)
    TO              reduce using rule 61 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 61 (literal -> IDENTIFIER .)
    STEP            reduce using rule 61 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 61 (literal -> IDENTIFIER .)


state 86

    (35) term -> term PRODUCT . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    factor                         shift and go to state 129
    literal                        shift and go to state 39

state 87

    (49) term -> term DIVIDE . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    factor                         shift and go to state 130
    literal                        shift and go to state 39

state 88

    (70) expression -> NOT term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 70 (expression -> NOT term .)
    NOT             reduce using rule 70 (expression -> NOT term .)
    EXP             reduce using rule 70 (expression -> NOT term .)
    GTE             reduce using rule 70 (expression -> NOT term .)
    LTE             reduce using rule 70 (expression -> NOT term .)
    IS              reduce using rule 70 (expression -> NOT term .)
    GT              reduce using rule 70 (expression -> NOT term .)
    LT              reduce using rule 70 (expression -> NOT term .)
    EQUALS          reduce using rule 70 (expression -> NOT term .)
    OR              reduce using rule 70 (expression -> NOT term .)
    AND             reduce using rule 70 (expression -> NOT term .)
    PLUS            reduce using rule 70 (expression -> NOT term .)
    MINUS           reduce using rule 70 (expression -> NOT term .)
    RIGHT_PAREN     reduce using rule 70 (expression -> NOT term .)
    IN              reduce using rule 70 (expression -> NOT term .)
    TO              reduce using rule 70 (expression -> NOT term .)
    COMMA           reduce using rule 70 (expression -> NOT term .)
    STEP            reduce using rule 70 (expression -> NOT term .)
    LEFT_BRACE      reduce using rule 70 (expression -> NOT term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 89

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN . RIGHT_PAREN compound_statement
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 132
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 131
    expression                     shift and go to state 95
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 90

    (63) variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    DO              reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    IF              reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LET             reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    $end            reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 63 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)


state 91

    (40) assignment_statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 133
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 92

    (51) assignment_statement -> IDENTIFIER DOT IDENTIFIER . ASSIGN expression SEMICOLON
    (55) literal -> IDENTIFIER DOT IDENTIFIER .

    ASSIGN          shift and go to state 134
    PRODUCT         reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    NOT             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EXP             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GTE             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LTE             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IS              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GT              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LT              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EQUALS          reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    OR              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    AND             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    MINUS           reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)


state 93

    (8) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 94

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 136


state 95

    (7) arguments -> expression . COMMA arguments
    (36) arguments -> expression .
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    COMMA           shift and go to state 137
    RIGHT_PAREN     reduce using rule 36 (arguments -> expression .)
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 96

    (44) literal -> IDENTIFIER LEFT_BRACKET QUOTE . IDENTIFIER QUOTE RIGHT_BRACKET

    IDENTIFIER      shift and go to state 138


state 97

    (48) factor -> LEFT_PAREN expression RIGHT_PAREN .

    PRODUCT         reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EXP             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GTE             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LTE             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IS              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GT              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LT              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IN              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TO              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    STEP            reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 98

    (55) literal -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 139


state 99

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE . variable_declaration_list RIGHT_BRACE
    (11) variable_declaration_list -> . variable_declaration variable_declaration_list
    (39) variable_declaration_list -> . empty
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (6) empty -> .
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING

    LET             shift and go to state 28
    IDENTIFIER      shift and go to state 140
    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37

    variable_declaration_list      shift and go to state 141
    variable_declaration           shift and go to state 142
    empty                          shift and go to state 143
    type_specifier                 shift and go to state 29

state 100

    (27) compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .

    FUNCTION        reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRUCT          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    PUT             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DO              reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    WHILE           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FOR             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IF              reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LOG             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LET             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    MINUS           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    NOT             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_BOOL       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_INT        reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_CHAR       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_DOUBLE     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_STRING     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    INTEGER         reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRING          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TRUE            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FALSE           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    $end            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    ELSE            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)


state 101

    (24) statement_list -> statement statement_list .

    RIGHT_BRACE     reduce using rule 24 (statement_list -> statement statement_list .)


state 102

    (26) assignment_statement -> PUT expression IN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 144


state 103

    (62) expression -> expression NOT ASSIGN . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 145
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 104

    (72) expression -> expression EXP term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 72 (expression -> expression EXP term .)
    NOT             reduce using rule 72 (expression -> expression EXP term .)
    EXP             reduce using rule 72 (expression -> expression EXP term .)
    GTE             reduce using rule 72 (expression -> expression EXP term .)
    LTE             reduce using rule 72 (expression -> expression EXP term .)
    IS              reduce using rule 72 (expression -> expression EXP term .)
    GT              reduce using rule 72 (expression -> expression EXP term .)
    LT              reduce using rule 72 (expression -> expression EXP term .)
    EQUALS          reduce using rule 72 (expression -> expression EXP term .)
    OR              reduce using rule 72 (expression -> expression EXP term .)
    AND             reduce using rule 72 (expression -> expression EXP term .)
    PLUS            reduce using rule 72 (expression -> expression EXP term .)
    MINUS           reduce using rule 72 (expression -> expression EXP term .)
    RIGHT_PAREN     reduce using rule 72 (expression -> expression EXP term .)
    IN              reduce using rule 72 (expression -> expression EXP term .)
    TO              reduce using rule 72 (expression -> expression EXP term .)
    COMMA           reduce using rule 72 (expression -> expression EXP term .)
    STEP            reduce using rule 72 (expression -> expression EXP term .)
    LEFT_BRACE      reduce using rule 72 (expression -> expression EXP term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 105

    (74) expression -> expression GTE term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 74 (expression -> expression GTE term .)
    NOT             reduce using rule 74 (expression -> expression GTE term .)
    EXP             reduce using rule 74 (expression -> expression GTE term .)
    GTE             reduce using rule 74 (expression -> expression GTE term .)
    LTE             reduce using rule 74 (expression -> expression GTE term .)
    IS              reduce using rule 74 (expression -> expression GTE term .)
    GT              reduce using rule 74 (expression -> expression GTE term .)
    LT              reduce using rule 74 (expression -> expression GTE term .)
    EQUALS          reduce using rule 74 (expression -> expression GTE term .)
    OR              reduce using rule 74 (expression -> expression GTE term .)
    AND             reduce using rule 74 (expression -> expression GTE term .)
    PLUS            reduce using rule 74 (expression -> expression GTE term .)
    MINUS           reduce using rule 74 (expression -> expression GTE term .)
    RIGHT_PAREN     reduce using rule 74 (expression -> expression GTE term .)
    IN              reduce using rule 74 (expression -> expression GTE term .)
    TO              reduce using rule 74 (expression -> expression GTE term .)
    COMMA           reduce using rule 74 (expression -> expression GTE term .)
    STEP            reduce using rule 74 (expression -> expression GTE term .)
    LEFT_BRACE      reduce using rule 74 (expression -> expression GTE term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 106

    (76) expression -> expression LTE term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 76 (expression -> expression LTE term .)
    NOT             reduce using rule 76 (expression -> expression LTE term .)
    EXP             reduce using rule 76 (expression -> expression LTE term .)
    GTE             reduce using rule 76 (expression -> expression LTE term .)
    LTE             reduce using rule 76 (expression -> expression LTE term .)
    IS              reduce using rule 76 (expression -> expression LTE term .)
    GT              reduce using rule 76 (expression -> expression LTE term .)
    LT              reduce using rule 76 (expression -> expression LTE term .)
    EQUALS          reduce using rule 76 (expression -> expression LTE term .)
    OR              reduce using rule 76 (expression -> expression LTE term .)
    AND             reduce using rule 76 (expression -> expression LTE term .)
    PLUS            reduce using rule 76 (expression -> expression LTE term .)
    MINUS           reduce using rule 76 (expression -> expression LTE term .)
    RIGHT_PAREN     reduce using rule 76 (expression -> expression LTE term .)
    IN              reduce using rule 76 (expression -> expression LTE term .)
    TO              reduce using rule 76 (expression -> expression LTE term .)
    COMMA           reduce using rule 76 (expression -> expression LTE term .)
    STEP            reduce using rule 76 (expression -> expression LTE term .)
    LEFT_BRACE      reduce using rule 76 (expression -> expression LTE term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 107

    (77) expression -> expression IS GREATER . THAN term

    THAN            shift and go to state 146


state 108

    (81) expression -> expression IS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 81 (expression -> expression IS term .)
    NOT             reduce using rule 81 (expression -> expression IS term .)
    EXP             reduce using rule 81 (expression -> expression IS term .)
    GTE             reduce using rule 81 (expression -> expression IS term .)
    LTE             reduce using rule 81 (expression -> expression IS term .)
    IS              reduce using rule 81 (expression -> expression IS term .)
    GT              reduce using rule 81 (expression -> expression IS term .)
    LT              reduce using rule 81 (expression -> expression IS term .)
    EQUALS          reduce using rule 81 (expression -> expression IS term .)
    OR              reduce using rule 81 (expression -> expression IS term .)
    AND             reduce using rule 81 (expression -> expression IS term .)
    PLUS            reduce using rule 81 (expression -> expression IS term .)
    MINUS           reduce using rule 81 (expression -> expression IS term .)
    RIGHT_PAREN     reduce using rule 81 (expression -> expression IS term .)
    IN              reduce using rule 81 (expression -> expression IS term .)
    TO              reduce using rule 81 (expression -> expression IS term .)
    COMMA           reduce using rule 81 (expression -> expression IS term .)
    STEP            reduce using rule 81 (expression -> expression IS term .)
    LEFT_BRACE      reduce using rule 81 (expression -> expression IS term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 109

    (78) expression -> expression IS LESS . THAN term

    THAN            shift and go to state 147


state 110

    (79) expression -> expression GT term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 79 (expression -> expression GT term .)
    NOT             reduce using rule 79 (expression -> expression GT term .)
    EXP             reduce using rule 79 (expression -> expression GT term .)
    GTE             reduce using rule 79 (expression -> expression GT term .)
    LTE             reduce using rule 79 (expression -> expression GT term .)
    IS              reduce using rule 79 (expression -> expression GT term .)
    GT              reduce using rule 79 (expression -> expression GT term .)
    LT              reduce using rule 79 (expression -> expression GT term .)
    EQUALS          reduce using rule 79 (expression -> expression GT term .)
    OR              reduce using rule 79 (expression -> expression GT term .)
    AND             reduce using rule 79 (expression -> expression GT term .)
    PLUS            reduce using rule 79 (expression -> expression GT term .)
    MINUS           reduce using rule 79 (expression -> expression GT term .)
    RIGHT_PAREN     reduce using rule 79 (expression -> expression GT term .)
    IN              reduce using rule 79 (expression -> expression GT term .)
    TO              reduce using rule 79 (expression -> expression GT term .)
    COMMA           reduce using rule 79 (expression -> expression GT term .)
    STEP            reduce using rule 79 (expression -> expression GT term .)
    LEFT_BRACE      reduce using rule 79 (expression -> expression GT term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 111

    (80) expression -> expression LT term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 80 (expression -> expression LT term .)
    NOT             reduce using rule 80 (expression -> expression LT term .)
    EXP             reduce using rule 80 (expression -> expression LT term .)
    GTE             reduce using rule 80 (expression -> expression LT term .)
    LTE             reduce using rule 80 (expression -> expression LT term .)
    IS              reduce using rule 80 (expression -> expression LT term .)
    GT              reduce using rule 80 (expression -> expression LT term .)
    LT              reduce using rule 80 (expression -> expression LT term .)
    EQUALS          reduce using rule 80 (expression -> expression LT term .)
    OR              reduce using rule 80 (expression -> expression LT term .)
    AND             reduce using rule 80 (expression -> expression LT term .)
    PLUS            reduce using rule 80 (expression -> expression LT term .)
    MINUS           reduce using rule 80 (expression -> expression LT term .)
    RIGHT_PAREN     reduce using rule 80 (expression -> expression LT term .)
    IN              reduce using rule 80 (expression -> expression LT term .)
    TO              reduce using rule 80 (expression -> expression LT term .)
    COMMA           reduce using rule 80 (expression -> expression LT term .)
    STEP            reduce using rule 80 (expression -> expression LT term .)
    LEFT_BRACE      reduce using rule 80 (expression -> expression LT term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 112

    (82) expression -> expression EQUALS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 82 (expression -> expression EQUALS term .)
    NOT             reduce using rule 82 (expression -> expression EQUALS term .)
    EXP             reduce using rule 82 (expression -> expression EQUALS term .)
    GTE             reduce using rule 82 (expression -> expression EQUALS term .)
    LTE             reduce using rule 82 (expression -> expression EQUALS term .)
    IS              reduce using rule 82 (expression -> expression EQUALS term .)
    GT              reduce using rule 82 (expression -> expression EQUALS term .)
    LT              reduce using rule 82 (expression -> expression EQUALS term .)
    EQUALS          reduce using rule 82 (expression -> expression EQUALS term .)
    OR              reduce using rule 82 (expression -> expression EQUALS term .)
    AND             reduce using rule 82 (expression -> expression EQUALS term .)
    PLUS            reduce using rule 82 (expression -> expression EQUALS term .)
    MINUS           reduce using rule 82 (expression -> expression EQUALS term .)
    RIGHT_PAREN     reduce using rule 82 (expression -> expression EQUALS term .)
    IN              reduce using rule 82 (expression -> expression EQUALS term .)
    TO              reduce using rule 82 (expression -> expression EQUALS term .)
    COMMA           reduce using rule 82 (expression -> expression EQUALS term .)
    STEP            reduce using rule 82 (expression -> expression EQUALS term .)
    LEFT_BRACE      reduce using rule 82 (expression -> expression EQUALS term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 113

    (83) expression -> expression OR term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 83 (expression -> expression OR term .)
    NOT             reduce using rule 83 (expression -> expression OR term .)
    EXP             reduce using rule 83 (expression -> expression OR term .)
    GTE             reduce using rule 83 (expression -> expression OR term .)
    LTE             reduce using rule 83 (expression -> expression OR term .)
    IS              reduce using rule 83 (expression -> expression OR term .)
    GT              reduce using rule 83 (expression -> expression OR term .)
    LT              reduce using rule 83 (expression -> expression OR term .)
    EQUALS          reduce using rule 83 (expression -> expression OR term .)
    OR              reduce using rule 83 (expression -> expression OR term .)
    AND             reduce using rule 83 (expression -> expression OR term .)
    PLUS            reduce using rule 83 (expression -> expression OR term .)
    MINUS           reduce using rule 83 (expression -> expression OR term .)
    RIGHT_PAREN     reduce using rule 83 (expression -> expression OR term .)
    IN              reduce using rule 83 (expression -> expression OR term .)
    TO              reduce using rule 83 (expression -> expression OR term .)
    COMMA           reduce using rule 83 (expression -> expression OR term .)
    STEP            reduce using rule 83 (expression -> expression OR term .)
    LEFT_BRACE      reduce using rule 83 (expression -> expression OR term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 114

    (84) expression -> expression AND term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 84 (expression -> expression AND term .)
    NOT             reduce using rule 84 (expression -> expression AND term .)
    EXP             reduce using rule 84 (expression -> expression AND term .)
    GTE             reduce using rule 84 (expression -> expression AND term .)
    LTE             reduce using rule 84 (expression -> expression AND term .)
    IS              reduce using rule 84 (expression -> expression AND term .)
    GT              reduce using rule 84 (expression -> expression AND term .)
    LT              reduce using rule 84 (expression -> expression AND term .)
    EQUALS          reduce using rule 84 (expression -> expression AND term .)
    OR              reduce using rule 84 (expression -> expression AND term .)
    AND             reduce using rule 84 (expression -> expression AND term .)
    PLUS            reduce using rule 84 (expression -> expression AND term .)
    MINUS           reduce using rule 84 (expression -> expression AND term .)
    RIGHT_PAREN     reduce using rule 84 (expression -> expression AND term .)
    IN              reduce using rule 84 (expression -> expression AND term .)
    TO              reduce using rule 84 (expression -> expression AND term .)
    COMMA           reduce using rule 84 (expression -> expression AND term .)
    STEP            reduce using rule 84 (expression -> expression AND term .)
    LEFT_BRACE      reduce using rule 84 (expression -> expression AND term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 115

    (85) expression -> expression PLUS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 85 (expression -> expression PLUS term .)
    NOT             reduce using rule 85 (expression -> expression PLUS term .)
    EXP             reduce using rule 85 (expression -> expression PLUS term .)
    GTE             reduce using rule 85 (expression -> expression PLUS term .)
    LTE             reduce using rule 85 (expression -> expression PLUS term .)
    IS              reduce using rule 85 (expression -> expression PLUS term .)
    GT              reduce using rule 85 (expression -> expression PLUS term .)
    LT              reduce using rule 85 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 85 (expression -> expression PLUS term .)
    OR              reduce using rule 85 (expression -> expression PLUS term .)
    AND             reduce using rule 85 (expression -> expression PLUS term .)
    PLUS            reduce using rule 85 (expression -> expression PLUS term .)
    MINUS           reduce using rule 85 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 85 (expression -> expression PLUS term .)
    IN              reduce using rule 85 (expression -> expression PLUS term .)
    TO              reduce using rule 85 (expression -> expression PLUS term .)
    COMMA           reduce using rule 85 (expression -> expression PLUS term .)
    STEP            reduce using rule 85 (expression -> expression PLUS term .)
    LEFT_BRACE      reduce using rule 85 (expression -> expression PLUS term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 116

    (86) expression -> expression MINUS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 86 (expression -> expression MINUS term .)
    NOT             reduce using rule 86 (expression -> expression MINUS term .)
    EXP             reduce using rule 86 (expression -> expression MINUS term .)
    GTE             reduce using rule 86 (expression -> expression MINUS term .)
    LTE             reduce using rule 86 (expression -> expression MINUS term .)
    IS              reduce using rule 86 (expression -> expression MINUS term .)
    GT              reduce using rule 86 (expression -> expression MINUS term .)
    LT              reduce using rule 86 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 86 (expression -> expression MINUS term .)
    OR              reduce using rule 86 (expression -> expression MINUS term .)
    AND             reduce using rule 86 (expression -> expression MINUS term .)
    PLUS            reduce using rule 86 (expression -> expression MINUS term .)
    MINUS           reduce using rule 86 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 86 (expression -> expression MINUS term .)
    IN              reduce using rule 86 (expression -> expression MINUS term .)
    TO              reduce using rule 86 (expression -> expression MINUS term .)
    COMMA           reduce using rule 86 (expression -> expression MINUS term .)
    STEP            reduce using rule 86 (expression -> expression MINUS term .)
    LEFT_BRACE      reduce using rule 86 (expression -> expression MINUS term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 117

    (22) iterative_statement -> DO compound_statement WHILE . LEFT_PAREN expression RIGHT_PAREN

    LEFT_PAREN      shift and go to state 148


state 118

    (23) iterative_statement -> WHILE LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 149
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 119

    (31) iterative_statement -> FOR LEFT_PAREN expression . TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN expression . TO expression STEP expression RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR LEFT_PAREN expression . SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN expression . SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (48) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    TO              shift and go to state 150
    SEMICOLON       shift and go to state 151
    RIGHT_PAREN     shift and go to state 97
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 120

    (64) iterative_statement -> FOR LEFT_PAREN variable_declaration . expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR LEFT_PAREN variable_declaration . expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 152
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 121

    (33) expression -> IDENTIFIER . INCREMENT
    (47) expression -> IDENTIFIER . DECREMENT
    (63) variable_declaration -> IDENTIFIER . IDENTIFIER SEMICOLON
    (44) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> IDENTIFIER . DOT IDENTIFIER
    (61) literal -> IDENTIFIER .

    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    IDENTIFIER      shift and go to state 49
    LEFT_BRACKET    shift and go to state 55
    DOT             shift and go to state 98
    PRODUCT         reduce using rule 61 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (literal -> IDENTIFIER .)
    TO              reduce using rule 61 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 61 (literal -> IDENTIFIER .)
    NOT             reduce using rule 61 (literal -> IDENTIFIER .)
    EXP             reduce using rule 61 (literal -> IDENTIFIER .)
    GTE             reduce using rule 61 (literal -> IDENTIFIER .)
    LTE             reduce using rule 61 (literal -> IDENTIFIER .)
    IS              reduce using rule 61 (literal -> IDENTIFIER .)
    GT              reduce using rule 61 (literal -> IDENTIFIER .)
    LT              reduce using rule 61 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 61 (literal -> IDENTIFIER .)
    OR              reduce using rule 61 (literal -> IDENTIFIER .)
    AND             reduce using rule 61 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 61 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 61 (literal -> IDENTIFIER .)


state 122

    (54) iterative_statement -> FOR expression TO . expression compound_statement
    (60) iterative_statement -> FOR expression TO . expression STEP expression compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 153
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 123

    (9) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (50) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE conditional_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 154
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 124

    (25) print_statement -> LOG LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 155


state 125

    (30) variable_declaration -> LET IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 156
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 126

    (59) variable_declaration -> LET IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    DO              reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    IF              reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LET             reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    $end            reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 59 (variable_declaration -> LET IDENTIFIER SEMICOLON .)


state 127

    (42) variable_declaration -> type_specifier IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 157
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 128

    (53) variable_declaration -> type_specifier IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DO              reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IF              reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LET             reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    $end            reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 53 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)


state 129

    (35) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 35 (term -> term PRODUCT factor .)
    DIVIDE          reduce using rule 35 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 35 (term -> term PRODUCT factor .)
    NOT             reduce using rule 35 (term -> term PRODUCT factor .)
    EXP             reduce using rule 35 (term -> term PRODUCT factor .)
    GTE             reduce using rule 35 (term -> term PRODUCT factor .)
    LTE             reduce using rule 35 (term -> term PRODUCT factor .)
    IS              reduce using rule 35 (term -> term PRODUCT factor .)
    GT              reduce using rule 35 (term -> term PRODUCT factor .)
    LT              reduce using rule 35 (term -> term PRODUCT factor .)
    EQUALS          reduce using rule 35 (term -> term PRODUCT factor .)
    OR              reduce using rule 35 (term -> term PRODUCT factor .)
    AND             reduce using rule 35 (term -> term PRODUCT factor .)
    PLUS            reduce using rule 35 (term -> term PRODUCT factor .)
    MINUS           reduce using rule 35 (term -> term PRODUCT factor .)
    RIGHT_PAREN     reduce using rule 35 (term -> term PRODUCT factor .)
    IN              reduce using rule 35 (term -> term PRODUCT factor .)
    TO              reduce using rule 35 (term -> term PRODUCT factor .)
    COMMA           reduce using rule 35 (term -> term PRODUCT factor .)
    STEP            reduce using rule 35 (term -> term PRODUCT factor .)
    LEFT_BRACE      reduce using rule 35 (term -> term PRODUCT factor .)


state 130

    (49) term -> term DIVIDE factor .

    PRODUCT         reduce using rule 49 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 49 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 49 (term -> term DIVIDE factor .)
    NOT             reduce using rule 49 (term -> term DIVIDE factor .)
    EXP             reduce using rule 49 (term -> term DIVIDE factor .)
    GTE             reduce using rule 49 (term -> term DIVIDE factor .)
    LTE             reduce using rule 49 (term -> term DIVIDE factor .)
    IS              reduce using rule 49 (term -> term DIVIDE factor .)
    GT              reduce using rule 49 (term -> term DIVIDE factor .)
    LT              reduce using rule 49 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 49 (term -> term DIVIDE factor .)
    OR              reduce using rule 49 (term -> term DIVIDE factor .)
    AND             reduce using rule 49 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 49 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 49 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 49 (term -> term DIVIDE factor .)
    IN              reduce using rule 49 (term -> term DIVIDE factor .)
    TO              reduce using rule 49 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 49 (term -> term DIVIDE factor .)
    STEP            reduce using rule 49 (term -> term DIVIDE factor .)
    LEFT_BRACE      reduce using rule 49 (term -> term DIVIDE factor .)


state 131

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 158


state 132

    (45) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 159

state 133

    (40) assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_PAREN     reduce using rule 40 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 134

    (51) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 160
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 135

    (8) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)


state 136

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 161


state 137

    (7) arguments -> expression COMMA . arguments
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 95
    arguments                      shift and go to state 162
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 138

    (44) literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER . QUOTE RIGHT_BRACKET

    QUOTE           shift and go to state 163


state 139

    (55) literal -> IDENTIFIER DOT IDENTIFIER .

    PRODUCT         reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    NOT             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EXP             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GTE             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LTE             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IS              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GT              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LT              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EQUALS          reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    OR              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    AND             reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    MINUS           reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IN              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TO              reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    COMMA           reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    STEP            reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LEFT_BRACE      reduce using rule 55 (literal -> IDENTIFIER DOT IDENTIFIER .)


state 140

    (63) variable_declaration -> IDENTIFIER . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 49


state 141

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 164


state 142

    (11) variable_declaration_list -> variable_declaration . variable_declaration_list
    (11) variable_declaration_list -> . variable_declaration variable_declaration_list
    (39) variable_declaration_list -> . empty
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (42) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (53) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (59) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (63) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (6) empty -> .
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING

    LET             shift and go to state 28
    IDENTIFIER      shift and go to state 140
    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37

    variable_declaration           shift and go to state 142
    variable_declaration_list      shift and go to state 165
    empty                          shift and go to state 143
    type_specifier                 shift and go to state 29

state 143

    (39) variable_declaration_list -> empty .

    RIGHT_BRACE     reduce using rule 39 (variable_declaration_list -> empty .)


state 144

    (26) assignment_statement -> PUT expression IN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 166


state 145

    (62) expression -> expression NOT ASSIGN term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    NOT             reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    EXP             reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    GTE             reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    LTE             reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    IS              reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    GT              reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    LT              reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    EQUALS          reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    OR              reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    AND             reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    PLUS            reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    MINUS           reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    RIGHT_PAREN     reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    IN              reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    TO              reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    COMMA           reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    STEP            reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    LEFT_BRACE      reduce using rule 62 (expression -> expression NOT ASSIGN term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 146

    (77) expression -> expression IS GREATER THAN . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 167
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 147

    (78) expression -> expression IS LESS THAN . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 85
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 168
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 148

    (22) iterative_statement -> DO compound_statement WHILE LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 169
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 149

    (23) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 170

state 150

    (31) iterative_statement -> FOR LEFT_PAREN expression TO . expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN expression TO . expression STEP expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 171
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 151

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON . expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON . expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 172
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 152

    (64) iterative_statement -> FOR LEFT_PAREN variable_declaration expression . SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR LEFT_PAREN variable_declaration expression . SEMICOLON expression RIGHT_PAREN compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 173
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 153

    (54) iterative_statement -> FOR expression TO expression . compound_statement
    (60) iterative_statement -> FOR expression TO expression . STEP expression compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    STEP            shift and go to state 175
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 174

state 154

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 176

state 155

    (25) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 177


state 156

    (30) variable_declaration -> LET IDENTIFIER ASSIGN expression . SEMICOLON
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 178
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 157

    (42) variable_declaration -> type_specifier IDENTIFIER ASSIGN expression . SEMICOLON
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 179
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 158

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 180

state 159

    (45) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DO              reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IF              reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LET             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    $end            reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)


state 160

    (51) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression . SEMICOLON
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 181
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 161

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 162

    (7) arguments -> expression COMMA arguments .

    RIGHT_PAREN     reduce using rule 7 (arguments -> expression COMMA arguments .)


state 163

    (44) literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 182


state 164

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .

    FUNCTION        reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    STRUCT          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    PUT             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    DO              reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    WHILE           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    FOR             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    IF              reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LOG             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LET             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    MINUS           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    NOT             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_BOOL       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_INT        reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_CHAR       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_DOUBLE     reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_STRING     reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    INTEGER         reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    STRING          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TRUE            reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    FALSE           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    $end            reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)


state 165

    (11) variable_declaration_list -> variable_declaration variable_declaration_list .

    RIGHT_BRACE     reduce using rule 11 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 166

    (26) assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DO              reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LET             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_PAREN     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)


state 167

    (77) expression -> expression IS GREATER THAN term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    NOT             reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    EXP             reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    GTE             reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    LTE             reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    IS              reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    GT              reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    LT              reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    EQUALS          reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    OR              reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    AND             reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    PLUS            reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    MINUS           reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    RIGHT_PAREN     reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    IN              reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    TO              reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    COMMA           reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    STEP            reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    LEFT_BRACE      reduce using rule 77 (expression -> expression IS GREATER THAN term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 168

    (78) expression -> expression IS LESS THAN term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 78 (expression -> expression IS LESS THAN term .)
    NOT             reduce using rule 78 (expression -> expression IS LESS THAN term .)
    EXP             reduce using rule 78 (expression -> expression IS LESS THAN term .)
    GTE             reduce using rule 78 (expression -> expression IS LESS THAN term .)
    LTE             reduce using rule 78 (expression -> expression IS LESS THAN term .)
    IS              reduce using rule 78 (expression -> expression IS LESS THAN term .)
    GT              reduce using rule 78 (expression -> expression IS LESS THAN term .)
    LT              reduce using rule 78 (expression -> expression IS LESS THAN term .)
    EQUALS          reduce using rule 78 (expression -> expression IS LESS THAN term .)
    OR              reduce using rule 78 (expression -> expression IS LESS THAN term .)
    AND             reduce using rule 78 (expression -> expression IS LESS THAN term .)
    PLUS            reduce using rule 78 (expression -> expression IS LESS THAN term .)
    MINUS           reduce using rule 78 (expression -> expression IS LESS THAN term .)
    RIGHT_PAREN     reduce using rule 78 (expression -> expression IS LESS THAN term .)
    IN              reduce using rule 78 (expression -> expression IS LESS THAN term .)
    TO              reduce using rule 78 (expression -> expression IS LESS THAN term .)
    COMMA           reduce using rule 78 (expression -> expression IS LESS THAN term .)
    STEP            reduce using rule 78 (expression -> expression IS LESS THAN term .)
    LEFT_BRACE      reduce using rule 78 (expression -> expression IS LESS THAN term .)
    PRODUCT         shift and go to state 86
    DIVIDE          shift and go to state 87


state 169

    (22) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression . RIGHT_PAREN
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 183
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 170

    (23) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 171

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression . RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression . STEP expression RIGHT_PAREN compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 184
    STEP            shift and go to state 185
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 172

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression . SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression . SEMICOLON expression RIGHT_PAREN compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 186
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 173

    (64) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON . assignment_statement RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON . expression RIGHT_PAREN compound_statement
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 189
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 187
    assignment_statement           shift and go to state 188
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 174

    (54) iterative_statement -> FOR expression TO expression compound_statement .

    FUNCTION        reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRUCT          reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    PUT             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    IDENTIFIER      reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    SEMICOLON       reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    DO              reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    WHILE           reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    FOR             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    IF              reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_BRACE      reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LOG             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LET             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    MINUS           reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    NOT             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_BOOL       reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_INT        reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_CHAR       reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_STRING     reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_PAREN      reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    DOUBLE          reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    INTEGER         reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRING          reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TRUE            reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    FALSE           reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    $end            reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    RIGHT_BRACE     reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)


state 175

    (60) iterative_statement -> FOR expression TO expression STEP . expression compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 190
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 176

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .
    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE conditional_statement

    ELSE            shift and go to state 191
    FUNCTION        reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 177

    (25) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 178

    (30) variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)


state 179

    (42) variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 42 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)


state 180

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DO              reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IF              reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LET             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    $end            reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)


state 181

    (51) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_PAREN     reduce using rule 51 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)


state 182

    (44) literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .

    PRODUCT         reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    DIVIDE          reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    NOT             reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    EXP             reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    GTE             reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LTE             reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    IS              reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    GT              reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LT              reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    EQUALS          reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    OR              reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    AND             reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    PLUS            reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    MINUS           reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    IN              reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TO              reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    COMMA           reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    STEP            reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LEFT_BRACE      reduce using rule 44 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)


state 183

    (22) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .

    FUNCTION        reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRUCT          reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    PUT             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IDENTIFIER      reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DO              reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    WHILE           reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FOR             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IF              reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LOG             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LET             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_BOOL       reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_INT        reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_CHAR       reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_DOUBLE     reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_STRING     reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DOUBLE          reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    INTEGER         reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRING          reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TRUE            reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FALSE           reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    $end            reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)


state 184

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 192

state 185

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP . expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 193
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 186

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON . assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON . expression RIGHT_PAREN compound_statement
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (40) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (62) expression -> . expression NOT ASSIGN term
    (70) expression -> . NOT term
    (72) expression -> . expression EXP term
    (74) expression -> . expression GTE term
    (76) expression -> . expression LTE term
    (77) expression -> . expression IS GREATER THAN term
    (78) expression -> . expression IS LESS THAN term
    (79) expression -> . expression GT term
    (80) expression -> . expression LT term
    (81) expression -> . expression IS term
    (82) expression -> . expression EQUALS term
    (83) expression -> . expression OR term
    (84) expression -> . expression AND term
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> . IDENTIFIER DOT IDENTIFIER
    (61) literal -> . IDENTIFIER
    (65) literal -> . DOUBLE
    (66) literal -> . INTEGER
    (67) literal -> . STRING
    (68) literal -> . TRUE
    (69) literal -> . FALSE

    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 189
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 194
    assignment_statement           shift and go to state 195
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 187

    (71) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression . RIGHT_PAREN compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 196
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 188

    (64) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 197


state 189

    (40) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (51) assignment_statement -> IDENTIFIER . DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> IDENTIFIER . INCREMENT
    (47) expression -> IDENTIFIER . DECREMENT
    (44) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (55) literal -> IDENTIFIER . DOT IDENTIFIER
    (61) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 50
    DOT             shift and go to state 51
    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    LEFT_BRACKET    shift and go to state 55
    PRODUCT         reduce using rule 61 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 61 (literal -> IDENTIFIER .)
    NOT             reduce using rule 61 (literal -> IDENTIFIER .)
    EXP             reduce using rule 61 (literal -> IDENTIFIER .)
    GTE             reduce using rule 61 (literal -> IDENTIFIER .)
    LTE             reduce using rule 61 (literal -> IDENTIFIER .)
    IS              reduce using rule 61 (literal -> IDENTIFIER .)
    GT              reduce using rule 61 (literal -> IDENTIFIER .)
    LT              reduce using rule 61 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 61 (literal -> IDENTIFIER .)
    OR              reduce using rule 61 (literal -> IDENTIFIER .)
    AND             reduce using rule 61 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 61 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 61 (literal -> IDENTIFIER .)


state 190

    (60) iterative_statement -> FOR expression TO expression STEP expression . compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 198

state 191

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . compound_statement
    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement

    LEFT_BRACE      shift and go to state 19
    IF              shift and go to state 26

    compound_statement             shift and go to state 199
    conditional_statement          shift and go to state 200

state 192

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)


state 193

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression . RIGHT_PAREN compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 201
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 194

    (75) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression . RIGHT_PAREN compound_statement
    (62) expression -> expression . NOT ASSIGN term
    (72) expression -> expression . EXP term
    (74) expression -> expression . GTE term
    (76) expression -> expression . LTE term
    (77) expression -> expression . IS GREATER THAN term
    (78) expression -> expression . IS LESS THAN term
    (79) expression -> expression . GT term
    (80) expression -> expression . LT term
    (81) expression -> expression . IS term
    (82) expression -> expression . EQUALS term
    (83) expression -> expression . OR term
    (84) expression -> expression . AND term
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 202
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 195

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 203


state 196

    (71) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 204

state 197

    (64) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 205

state 198

    (60) iterative_statement -> FOR expression TO expression STEP expression compound_statement .

    FUNCTION        reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRUCT          reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    PUT             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IDENTIFIER      reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    SEMICOLON       reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DO              reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    WHILE           reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FOR             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IF              reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_BRACE      reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LOG             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LET             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    MINUS           reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    NOT             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_BOOL       reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_INT        reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_CHAR       reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_STRING     reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_PAREN      reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DOUBLE          reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    INTEGER         reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRING          reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TRUE            reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FALSE           reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    $end            reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    RIGHT_BRACE     reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)


state 199

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .

    FUNCTION        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRUCT          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    PUT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IDENTIFIER      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    SEMICOLON       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DO              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FOR             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IF              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_BRACE      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LOG             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LET             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    MINUS           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    NOT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_BOOL       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_INT        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_CHAR       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_DOUBLE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_STRING     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_PAREN      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DOUBLE          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    INTEGER         reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRING          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TRUE            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FALSE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    $end            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    RIGHT_BRACE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)


state 200

    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .

    FUNCTION        reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    STRUCT          reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    PUT             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    IDENTIFIER      reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    SEMICOLON       reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    DO              reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    WHILE           reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    FOR             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    IF              reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LEFT_BRACE      reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LOG             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LET             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    MINUS           reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    NOT             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_BOOL       reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_INT        reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_CHAR       reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_DOUBLE     reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_STRING     reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LEFT_PAREN      reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    DOUBLE          reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    INTEGER         reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    STRING          reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TRUE            reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    FALSE           reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    $end            reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    RIGHT_BRACE     reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)


state 201

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 206

state 202

    (75) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 207

state 203

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 208

state 204

    (71) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)


state 205

    (64) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DO              reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IF              reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LET             reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    $end            reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 64 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)


state 206

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)


state 207

    (75) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)


state 208

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DO              reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IF              reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LET             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    $end            reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)

