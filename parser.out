Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    MODULUS
    OBJECT
    RETURN
    SKIP
    STRUCT
    TYPE_BOOL
    TYPE_CHAR
    TYPE_DOUBLE
    TYPE_INT
    TYPE_STRING

Grammar

Rule 0     S' -> program
Rule 1     arguments -> expression COMMA arguments
Rule 2     function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
Rule 3     assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON
Rule 4     conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
Rule 5     expression_statement -> expression SEMICOLON
Rule 6     expression_statement -> SEMICOLON
Rule 7     statement -> assignment_statement
Rule 8     statement -> expression_statement
Rule 9     statement -> iterative_statement
Rule 10    statement -> conditional_statement
Rule 11    statement -> compound_statement
Rule 12    statement -> print_statement
Rule 13    statement -> function_statement
Rule 14    statement -> function_call
Rule 15    iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
Rule 16    iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
Rule 17    iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 18    statement_list -> statement statement_list
Rule 19    statement_list -> <empty>
Rule 20    print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 21    function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
Rule 22    compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE
Rule 23    program -> statement_list
Rule 24    expression -> IDENTIFIER INCREMENT
Rule 25    factor -> literal
Rule 26    term -> term PRODUCT factor
Rule 27    arguments -> expression
Rule 28    function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 29    assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 30    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 31    iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
Rule 32    literal -> IDENTIFIER
Rule 33    function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
Rule 34    expression -> IDENTIFIER DECREMENT
Rule 35    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 36    term -> term DIVIDE factor
Rule 37    assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON
Rule 38    iterative_statement -> FOR expression TO expression compound_statement
Rule 39    literal -> DOUBLE
Rule 40    literal -> INTEGER
Rule 41    literal -> STRING
Rule 42    expression -> MINUS term
Rule 43    term -> factor
Rule 44    iterative_statement -> FOR expression TO expression STEP expression compound_statement
Rule 45    expression -> NOT term
Rule 46    expression -> expression GTE term
Rule 47    expression -> expression LTE term
Rule 48    expression -> expression IS GREATER THAN term
Rule 49    expression -> expression IS LESS THAN term
Rule 50    expression -> expression GT term
Rule 51    expression -> expression LT term
Rule 52    expression -> expression IS term
Rule 53    expression -> expression EQUALS term
Rule 54    expression -> expression OR term
Rule 55    expression -> expression AND term
Rule 56    expression -> expression PLUS term
Rule 57    expression -> expression MINUS term
Rule 58    expression -> term

Terminals, with rules where they appear

AND                  : 55
ASSIGN               : 29 37
BREAK                : 
COMMA                : 1
DECREMENT            : 34
DIVIDE               : 36
DO                   : 15
DOUBLE               : 39
ELSE                 : 4
EQUALS               : 53
FOR                  : 16 31 38 44
FUNCTION             : 21 33
GREATER              : 48
GT                   : 50
GTE                  : 46
IDENTIFIER           : 2 3 21 24 28 29 32 33 34 37
IF                   : 4 30
IN                   : 3
INCREMENT            : 24
INTEGER              : 40
IS                   : 48 49 52
LEFT_BRACE           : 22
LEFT_PAREN           : 2 4 15 16 17 20 21 28 30 31 33 35
LESS                 : 49
LET                  : 37
LOG                  : 20
LT                   : 51
LTE                  : 47
MINUS                : 42 57
MODULUS              : 
NOT                  : 45
OBJECT               : 
OR                   : 54
PLUS                 : 56
PRODUCT              : 26
PUT                  : 3
RETURN               : 
RIGHT_BRACE          : 22
RIGHT_PAREN          : 2 4 15 16 17 20 21 28 30 31 33 35
SEMICOLON            : 2 3 5 6 20 28 29 37
SKIP                 : 
STEP                 : 31 44
STRING               : 41
STRUCT               : 
THAN                 : 48 49
TO                   : 16 31 38 44
TYPE_BOOL            : 
TYPE_CHAR            : 
TYPE_DOUBLE          : 
TYPE_INT             : 
TYPE_STRING          : 
WHILE                : 15 17
error                : 

Nonterminals, with rules where they appear

arguments            : 1 20 21 28
assignment_statement : 7
compound_statement   : 4 4 11 15 16 17 21 30 31 33 38 44
conditional_statement : 10
expression           : 1 3 4 5 15 16 16 17 27 29 30 31 31 31 35 37 38 38 44 44 44 46 47 48 49 50 51 52 53 54 55 56 57
expression_statement : 8
factor               : 26 36 43
function_call        : 14
function_statement   : 13
iterative_statement  : 9
literal              : 25
print_statement      : 12
program              : 0
statement            : 18
statement_list       : 18 22 23
term                 : 26 36 42 45 46 47 48 49 50 51 52 53 54 55 56 57 58

Parsing method: LALR

state 0

    (0) S' -> . program
    (23) program -> . statement_list
    (18) statement_list -> . statement statement_list
    (19) statement_list -> .
    (7) statement -> . assignment_statement
    (8) statement -> . expression_statement
    (9) statement -> . iterative_statement
    (10) statement -> . conditional_statement
    (11) statement -> . compound_statement
    (12) statement -> . print_statement
    (13) statement -> . function_statement
    (14) statement -> . function_call
    (3) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (29) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (37) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (5) expression_statement -> . expression SEMICOLON
    (6) expression_statement -> . SEMICOLON
    (15) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (16) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (17) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (38) iterative_statement -> . FOR expression TO expression compound_statement
    (44) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (4) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (30) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (20) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (21) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (33) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (2) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (28) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    $end            reduce using rule 19 (statement_list -> .)
    PUT             shift and go to state 12
    IDENTIFIER      shift and go to state 14
    LET             shift and go to state 16
    SEMICOLON       shift and go to state 15
    DO              shift and go to state 17
    FOR             shift and go to state 20
    WHILE           shift and go to state 18
    IF              shift and go to state 21
    LEFT_BRACE      shift and go to state 22
    LOG             shift and go to state 23
    FUNCTION        shift and go to state 24
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    function_statement             shift and go to state 10
    function_call                  shift and go to state 11
    expression                     shift and go to state 13
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 1

    (0) S' -> program .



state 2

    (23) program -> statement_list .

    $end            reduce using rule 23 (program -> statement_list .)


state 3

    (18) statement_list -> statement . statement_list
    (18) statement_list -> . statement statement_list
    (19) statement_list -> .
    (7) statement -> . assignment_statement
    (8) statement -> . expression_statement
    (9) statement -> . iterative_statement
    (10) statement -> . conditional_statement
    (11) statement -> . compound_statement
    (12) statement -> . print_statement
    (13) statement -> . function_statement
    (14) statement -> . function_call
    (3) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (29) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (37) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (5) expression_statement -> . expression SEMICOLON
    (6) expression_statement -> . SEMICOLON
    (15) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (16) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (17) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (38) iterative_statement -> . FOR expression TO expression compound_statement
    (44) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (4) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (30) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (20) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (21) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (33) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (2) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (28) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    $end            reduce using rule 19 (statement_list -> .)
    RIGHT_BRACE     reduce using rule 19 (statement_list -> .)
    PUT             shift and go to state 12
    IDENTIFIER      shift and go to state 14
    LET             shift and go to state 16
    SEMICOLON       shift and go to state 15
    DO              shift and go to state 17
    FOR             shift and go to state 20
    WHILE           shift and go to state 18
    IF              shift and go to state 21
    LEFT_BRACE      shift and go to state 22
    LOG             shift and go to state 23
    FUNCTION        shift and go to state 24
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    statement                      shift and go to state 3
    statement_list                 shift and go to state 33
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    function_statement             shift and go to state 10
    function_call                  shift and go to state 11
    expression                     shift and go to state 13
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 4

    (7) statement -> assignment_statement .

    PUT             reduce using rule 7 (statement -> assignment_statement .)
    IDENTIFIER      reduce using rule 7 (statement -> assignment_statement .)
    LET             reduce using rule 7 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 7 (statement -> assignment_statement .)
    DO              reduce using rule 7 (statement -> assignment_statement .)
    FOR             reduce using rule 7 (statement -> assignment_statement .)
    WHILE           reduce using rule 7 (statement -> assignment_statement .)
    IF              reduce using rule 7 (statement -> assignment_statement .)
    LEFT_BRACE      reduce using rule 7 (statement -> assignment_statement .)
    LOG             reduce using rule 7 (statement -> assignment_statement .)
    FUNCTION        reduce using rule 7 (statement -> assignment_statement .)
    MINUS           reduce using rule 7 (statement -> assignment_statement .)
    NOT             reduce using rule 7 (statement -> assignment_statement .)
    LEFT_PAREN      reduce using rule 7 (statement -> assignment_statement .)
    DOUBLE          reduce using rule 7 (statement -> assignment_statement .)
    INTEGER         reduce using rule 7 (statement -> assignment_statement .)
    STRING          reduce using rule 7 (statement -> assignment_statement .)
    $end            reduce using rule 7 (statement -> assignment_statement .)
    RIGHT_BRACE     reduce using rule 7 (statement -> assignment_statement .)


state 5

    (8) statement -> expression_statement .

    PUT             reduce using rule 8 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 8 (statement -> expression_statement .)
    LET             reduce using rule 8 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 8 (statement -> expression_statement .)
    DO              reduce using rule 8 (statement -> expression_statement .)
    FOR             reduce using rule 8 (statement -> expression_statement .)
    WHILE           reduce using rule 8 (statement -> expression_statement .)
    IF              reduce using rule 8 (statement -> expression_statement .)
    LEFT_BRACE      reduce using rule 8 (statement -> expression_statement .)
    LOG             reduce using rule 8 (statement -> expression_statement .)
    FUNCTION        reduce using rule 8 (statement -> expression_statement .)
    MINUS           reduce using rule 8 (statement -> expression_statement .)
    NOT             reduce using rule 8 (statement -> expression_statement .)
    LEFT_PAREN      reduce using rule 8 (statement -> expression_statement .)
    DOUBLE          reduce using rule 8 (statement -> expression_statement .)
    INTEGER         reduce using rule 8 (statement -> expression_statement .)
    STRING          reduce using rule 8 (statement -> expression_statement .)
    $end            reduce using rule 8 (statement -> expression_statement .)
    RIGHT_BRACE     reduce using rule 8 (statement -> expression_statement .)


state 6

    (9) statement -> iterative_statement .

    PUT             reduce using rule 9 (statement -> iterative_statement .)
    IDENTIFIER      reduce using rule 9 (statement -> iterative_statement .)
    LET             reduce using rule 9 (statement -> iterative_statement .)
    SEMICOLON       reduce using rule 9 (statement -> iterative_statement .)
    DO              reduce using rule 9 (statement -> iterative_statement .)
    FOR             reduce using rule 9 (statement -> iterative_statement .)
    WHILE           reduce using rule 9 (statement -> iterative_statement .)
    IF              reduce using rule 9 (statement -> iterative_statement .)
    LEFT_BRACE      reduce using rule 9 (statement -> iterative_statement .)
    LOG             reduce using rule 9 (statement -> iterative_statement .)
    FUNCTION        reduce using rule 9 (statement -> iterative_statement .)
    MINUS           reduce using rule 9 (statement -> iterative_statement .)
    NOT             reduce using rule 9 (statement -> iterative_statement .)
    LEFT_PAREN      reduce using rule 9 (statement -> iterative_statement .)
    DOUBLE          reduce using rule 9 (statement -> iterative_statement .)
    INTEGER         reduce using rule 9 (statement -> iterative_statement .)
    STRING          reduce using rule 9 (statement -> iterative_statement .)
    $end            reduce using rule 9 (statement -> iterative_statement .)
    RIGHT_BRACE     reduce using rule 9 (statement -> iterative_statement .)


state 7

    (10) statement -> conditional_statement .

    PUT             reduce using rule 10 (statement -> conditional_statement .)
    IDENTIFIER      reduce using rule 10 (statement -> conditional_statement .)
    LET             reduce using rule 10 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 10 (statement -> conditional_statement .)
    DO              reduce using rule 10 (statement -> conditional_statement .)
    FOR             reduce using rule 10 (statement -> conditional_statement .)
    WHILE           reduce using rule 10 (statement -> conditional_statement .)
    IF              reduce using rule 10 (statement -> conditional_statement .)
    LEFT_BRACE      reduce using rule 10 (statement -> conditional_statement .)
    LOG             reduce using rule 10 (statement -> conditional_statement .)
    FUNCTION        reduce using rule 10 (statement -> conditional_statement .)
    MINUS           reduce using rule 10 (statement -> conditional_statement .)
    NOT             reduce using rule 10 (statement -> conditional_statement .)
    LEFT_PAREN      reduce using rule 10 (statement -> conditional_statement .)
    DOUBLE          reduce using rule 10 (statement -> conditional_statement .)
    INTEGER         reduce using rule 10 (statement -> conditional_statement .)
    STRING          reduce using rule 10 (statement -> conditional_statement .)
    $end            reduce using rule 10 (statement -> conditional_statement .)
    RIGHT_BRACE     reduce using rule 10 (statement -> conditional_statement .)


state 8

    (11) statement -> compound_statement .

    PUT             reduce using rule 11 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 11 (statement -> compound_statement .)
    LET             reduce using rule 11 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 11 (statement -> compound_statement .)
    DO              reduce using rule 11 (statement -> compound_statement .)
    FOR             reduce using rule 11 (statement -> compound_statement .)
    WHILE           reduce using rule 11 (statement -> compound_statement .)
    IF              reduce using rule 11 (statement -> compound_statement .)
    LEFT_BRACE      reduce using rule 11 (statement -> compound_statement .)
    LOG             reduce using rule 11 (statement -> compound_statement .)
    FUNCTION        reduce using rule 11 (statement -> compound_statement .)
    MINUS           reduce using rule 11 (statement -> compound_statement .)
    NOT             reduce using rule 11 (statement -> compound_statement .)
    LEFT_PAREN      reduce using rule 11 (statement -> compound_statement .)
    DOUBLE          reduce using rule 11 (statement -> compound_statement .)
    INTEGER         reduce using rule 11 (statement -> compound_statement .)
    STRING          reduce using rule 11 (statement -> compound_statement .)
    $end            reduce using rule 11 (statement -> compound_statement .)
    RIGHT_BRACE     reduce using rule 11 (statement -> compound_statement .)


state 9

    (12) statement -> print_statement .

    PUT             reduce using rule 12 (statement -> print_statement .)
    IDENTIFIER      reduce using rule 12 (statement -> print_statement .)
    LET             reduce using rule 12 (statement -> print_statement .)
    SEMICOLON       reduce using rule 12 (statement -> print_statement .)
    DO              reduce using rule 12 (statement -> print_statement .)
    FOR             reduce using rule 12 (statement -> print_statement .)
    WHILE           reduce using rule 12 (statement -> print_statement .)
    IF              reduce using rule 12 (statement -> print_statement .)
    LEFT_BRACE      reduce using rule 12 (statement -> print_statement .)
    LOG             reduce using rule 12 (statement -> print_statement .)
    FUNCTION        reduce using rule 12 (statement -> print_statement .)
    MINUS           reduce using rule 12 (statement -> print_statement .)
    NOT             reduce using rule 12 (statement -> print_statement .)
    LEFT_PAREN      reduce using rule 12 (statement -> print_statement .)
    DOUBLE          reduce using rule 12 (statement -> print_statement .)
    INTEGER         reduce using rule 12 (statement -> print_statement .)
    STRING          reduce using rule 12 (statement -> print_statement .)
    $end            reduce using rule 12 (statement -> print_statement .)
    RIGHT_BRACE     reduce using rule 12 (statement -> print_statement .)


state 10

    (13) statement -> function_statement .

    PUT             reduce using rule 13 (statement -> function_statement .)
    IDENTIFIER      reduce using rule 13 (statement -> function_statement .)
    LET             reduce using rule 13 (statement -> function_statement .)
    SEMICOLON       reduce using rule 13 (statement -> function_statement .)
    DO              reduce using rule 13 (statement -> function_statement .)
    FOR             reduce using rule 13 (statement -> function_statement .)
    WHILE           reduce using rule 13 (statement -> function_statement .)
    IF              reduce using rule 13 (statement -> function_statement .)
    LEFT_BRACE      reduce using rule 13 (statement -> function_statement .)
    LOG             reduce using rule 13 (statement -> function_statement .)
    FUNCTION        reduce using rule 13 (statement -> function_statement .)
    MINUS           reduce using rule 13 (statement -> function_statement .)
    NOT             reduce using rule 13 (statement -> function_statement .)
    LEFT_PAREN      reduce using rule 13 (statement -> function_statement .)
    DOUBLE          reduce using rule 13 (statement -> function_statement .)
    INTEGER         reduce using rule 13 (statement -> function_statement .)
    STRING          reduce using rule 13 (statement -> function_statement .)
    $end            reduce using rule 13 (statement -> function_statement .)
    RIGHT_BRACE     reduce using rule 13 (statement -> function_statement .)


state 11

    (14) statement -> function_call .

    PUT             reduce using rule 14 (statement -> function_call .)
    IDENTIFIER      reduce using rule 14 (statement -> function_call .)
    LET             reduce using rule 14 (statement -> function_call .)
    SEMICOLON       reduce using rule 14 (statement -> function_call .)
    DO              reduce using rule 14 (statement -> function_call .)
    FOR             reduce using rule 14 (statement -> function_call .)
    WHILE           reduce using rule 14 (statement -> function_call .)
    IF              reduce using rule 14 (statement -> function_call .)
    LEFT_BRACE      reduce using rule 14 (statement -> function_call .)
    LOG             reduce using rule 14 (statement -> function_call .)
    FUNCTION        reduce using rule 14 (statement -> function_call .)
    MINUS           reduce using rule 14 (statement -> function_call .)
    NOT             reduce using rule 14 (statement -> function_call .)
    LEFT_PAREN      reduce using rule 14 (statement -> function_call .)
    DOUBLE          reduce using rule 14 (statement -> function_call .)
    INTEGER         reduce using rule 14 (statement -> function_call .)
    STRING          reduce using rule 14 (statement -> function_call .)
    $end            reduce using rule 14 (statement -> function_call .)
    RIGHT_BRACE     reduce using rule 14 (statement -> function_call .)


state 12

    (3) assignment_statement -> PUT . expression IN IDENTIFIER SEMICOLON
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 34
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 13

    (5) expression_statement -> expression . SEMICOLON
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 36
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 14

    (29) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (2) function_call -> IDENTIFIER . LEFT_PAREN RIGHT_PAREN SEMICOLON
    (28) function_call -> IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (24) expression -> IDENTIFIER . INCREMENT
    (34) expression -> IDENTIFIER . DECREMENT
    (32) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 47
    LEFT_PAREN      shift and go to state 48
    INCREMENT       shift and go to state 49
    DECREMENT       shift and go to state 50
    PRODUCT         reduce using rule 32 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 32 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 32 (literal -> IDENTIFIER .)
    GTE             reduce using rule 32 (literal -> IDENTIFIER .)
    LTE             reduce using rule 32 (literal -> IDENTIFIER .)
    IS              reduce using rule 32 (literal -> IDENTIFIER .)
    GT              reduce using rule 32 (literal -> IDENTIFIER .)
    LT              reduce using rule 32 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 32 (literal -> IDENTIFIER .)
    OR              reduce using rule 32 (literal -> IDENTIFIER .)
    AND             reduce using rule 32 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 32 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 32 (literal -> IDENTIFIER .)


state 15

    (6) expression_statement -> SEMICOLON .

    PUT             reduce using rule 6 (expression_statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (expression_statement -> SEMICOLON .)
    LET             reduce using rule 6 (expression_statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 6 (expression_statement -> SEMICOLON .)
    DO              reduce using rule 6 (expression_statement -> SEMICOLON .)
    FOR             reduce using rule 6 (expression_statement -> SEMICOLON .)
    WHILE           reduce using rule 6 (expression_statement -> SEMICOLON .)
    IF              reduce using rule 6 (expression_statement -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 6 (expression_statement -> SEMICOLON .)
    LOG             reduce using rule 6 (expression_statement -> SEMICOLON .)
    FUNCTION        reduce using rule 6 (expression_statement -> SEMICOLON .)
    MINUS           reduce using rule 6 (expression_statement -> SEMICOLON .)
    NOT             reduce using rule 6 (expression_statement -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 6 (expression_statement -> SEMICOLON .)
    DOUBLE          reduce using rule 6 (expression_statement -> SEMICOLON .)
    INTEGER         reduce using rule 6 (expression_statement -> SEMICOLON .)
    STRING          reduce using rule 6 (expression_statement -> SEMICOLON .)
    $end            reduce using rule 6 (expression_statement -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 6 (expression_statement -> SEMICOLON .)


state 16

    (37) assignment_statement -> LET . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 51


state 17

    (15) iterative_statement -> DO . compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 52

state 18

    (17) iterative_statement -> WHILE . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 53


state 19

    (35) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 54
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 20

    (16) iterative_statement -> FOR . LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> FOR . LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (38) iterative_statement -> FOR . expression TO expression compound_statement
    (44) iterative_statement -> FOR . expression TO expression STEP expression compound_statement
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 55
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 56
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 21

    (4) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (30) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 57


state 22

    (22) compound_statement -> LEFT_BRACE . statement_list RIGHT_BRACE
    (18) statement_list -> . statement statement_list
    (19) statement_list -> .
    (7) statement -> . assignment_statement
    (8) statement -> . expression_statement
    (9) statement -> . iterative_statement
    (10) statement -> . conditional_statement
    (11) statement -> . compound_statement
    (12) statement -> . print_statement
    (13) statement -> . function_statement
    (14) statement -> . function_call
    (3) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (29) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (37) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (5) expression_statement -> . expression SEMICOLON
    (6) expression_statement -> . SEMICOLON
    (15) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (16) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (17) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (38) iterative_statement -> . FOR expression TO expression compound_statement
    (44) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (4) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (30) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (20) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (21) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (33) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (2) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (28) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    RIGHT_BRACE     reduce using rule 19 (statement_list -> .)
    PUT             shift and go to state 12
    IDENTIFIER      shift and go to state 14
    LET             shift and go to state 16
    SEMICOLON       shift and go to state 15
    DO              shift and go to state 17
    FOR             shift and go to state 20
    WHILE           shift and go to state 18
    IF              shift and go to state 21
    LEFT_BRACE      shift and go to state 22
    LOG             shift and go to state 23
    FUNCTION        shift and go to state 24
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    statement_list                 shift and go to state 58
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    function_statement             shift and go to state 10
    function_call                  shift and go to state 11
    expression                     shift and go to state 13
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 23

    (20) print_statement -> LOG . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 59


state 24

    (21) function_statement -> FUNCTION . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (33) function_statement -> FUNCTION . IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement

    IDENTIFIER      shift and go to state 60


state 25

    (42) expression -> MINUS . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 61
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 26

    (58) expression -> term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 58 (expression -> term .)
    GTE             reduce using rule 58 (expression -> term .)
    LTE             reduce using rule 58 (expression -> term .)
    IS              reduce using rule 58 (expression -> term .)
    GT              reduce using rule 58 (expression -> term .)
    LT              reduce using rule 58 (expression -> term .)
    EQUALS          reduce using rule 58 (expression -> term .)
    OR              reduce using rule 58 (expression -> term .)
    AND             reduce using rule 58 (expression -> term .)
    PLUS            reduce using rule 58 (expression -> term .)
    MINUS           reduce using rule 58 (expression -> term .)
    IN              reduce using rule 58 (expression -> term .)
    RIGHT_PAREN     reduce using rule 58 (expression -> term .)
    TO              reduce using rule 58 (expression -> term .)
    COMMA           reduce using rule 58 (expression -> term .)
    STEP            reduce using rule 58 (expression -> term .)
    LEFT_BRACE      reduce using rule 58 (expression -> term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 27

    (45) expression -> NOT . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 65
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 28

    (43) term -> factor .

    PRODUCT         reduce using rule 43 (term -> factor .)
    DIVIDE          reduce using rule 43 (term -> factor .)
    SEMICOLON       reduce using rule 43 (term -> factor .)
    GTE             reduce using rule 43 (term -> factor .)
    LTE             reduce using rule 43 (term -> factor .)
    IS              reduce using rule 43 (term -> factor .)
    GT              reduce using rule 43 (term -> factor .)
    LT              reduce using rule 43 (term -> factor .)
    EQUALS          reduce using rule 43 (term -> factor .)
    OR              reduce using rule 43 (term -> factor .)
    AND             reduce using rule 43 (term -> factor .)
    PLUS            reduce using rule 43 (term -> factor .)
    MINUS           reduce using rule 43 (term -> factor .)
    IN              reduce using rule 43 (term -> factor .)
    RIGHT_PAREN     reduce using rule 43 (term -> factor .)
    TO              reduce using rule 43 (term -> factor .)
    COMMA           reduce using rule 43 (term -> factor .)
    STEP            reduce using rule 43 (term -> factor .)
    LEFT_BRACE      reduce using rule 43 (term -> factor .)


state 29

    (25) factor -> literal .

    PRODUCT         reduce using rule 25 (factor -> literal .)
    DIVIDE          reduce using rule 25 (factor -> literal .)
    SEMICOLON       reduce using rule 25 (factor -> literal .)
    GTE             reduce using rule 25 (factor -> literal .)
    LTE             reduce using rule 25 (factor -> literal .)
    IS              reduce using rule 25 (factor -> literal .)
    GT              reduce using rule 25 (factor -> literal .)
    LT              reduce using rule 25 (factor -> literal .)
    EQUALS          reduce using rule 25 (factor -> literal .)
    OR              reduce using rule 25 (factor -> literal .)
    AND             reduce using rule 25 (factor -> literal .)
    PLUS            reduce using rule 25 (factor -> literal .)
    MINUS           reduce using rule 25 (factor -> literal .)
    IN              reduce using rule 25 (factor -> literal .)
    RIGHT_PAREN     reduce using rule 25 (factor -> literal .)
    TO              reduce using rule 25 (factor -> literal .)
    COMMA           reduce using rule 25 (factor -> literal .)
    STEP            reduce using rule 25 (factor -> literal .)
    LEFT_BRACE      reduce using rule 25 (factor -> literal .)


state 30

    (39) literal -> DOUBLE .

    PRODUCT         reduce using rule 39 (literal -> DOUBLE .)
    DIVIDE          reduce using rule 39 (literal -> DOUBLE .)
    SEMICOLON       reduce using rule 39 (literal -> DOUBLE .)
    GTE             reduce using rule 39 (literal -> DOUBLE .)
    LTE             reduce using rule 39 (literal -> DOUBLE .)
    IS              reduce using rule 39 (literal -> DOUBLE .)
    GT              reduce using rule 39 (literal -> DOUBLE .)
    LT              reduce using rule 39 (literal -> DOUBLE .)
    EQUALS          reduce using rule 39 (literal -> DOUBLE .)
    OR              reduce using rule 39 (literal -> DOUBLE .)
    AND             reduce using rule 39 (literal -> DOUBLE .)
    PLUS            reduce using rule 39 (literal -> DOUBLE .)
    MINUS           reduce using rule 39 (literal -> DOUBLE .)
    IN              reduce using rule 39 (literal -> DOUBLE .)
    RIGHT_PAREN     reduce using rule 39 (literal -> DOUBLE .)
    TO              reduce using rule 39 (literal -> DOUBLE .)
    COMMA           reduce using rule 39 (literal -> DOUBLE .)
    STEP            reduce using rule 39 (literal -> DOUBLE .)
    LEFT_BRACE      reduce using rule 39 (literal -> DOUBLE .)


state 31

    (40) literal -> INTEGER .

    PRODUCT         reduce using rule 40 (literal -> INTEGER .)
    DIVIDE          reduce using rule 40 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 40 (literal -> INTEGER .)
    GTE             reduce using rule 40 (literal -> INTEGER .)
    LTE             reduce using rule 40 (literal -> INTEGER .)
    IS              reduce using rule 40 (literal -> INTEGER .)
    GT              reduce using rule 40 (literal -> INTEGER .)
    LT              reduce using rule 40 (literal -> INTEGER .)
    EQUALS          reduce using rule 40 (literal -> INTEGER .)
    OR              reduce using rule 40 (literal -> INTEGER .)
    AND             reduce using rule 40 (literal -> INTEGER .)
    PLUS            reduce using rule 40 (literal -> INTEGER .)
    MINUS           reduce using rule 40 (literal -> INTEGER .)
    IN              reduce using rule 40 (literal -> INTEGER .)
    RIGHT_PAREN     reduce using rule 40 (literal -> INTEGER .)
    TO              reduce using rule 40 (literal -> INTEGER .)
    COMMA           reduce using rule 40 (literal -> INTEGER .)
    STEP            reduce using rule 40 (literal -> INTEGER .)
    LEFT_BRACE      reduce using rule 40 (literal -> INTEGER .)


state 32

    (41) literal -> STRING .

    PRODUCT         reduce using rule 41 (literal -> STRING .)
    DIVIDE          reduce using rule 41 (literal -> STRING .)
    SEMICOLON       reduce using rule 41 (literal -> STRING .)
    GTE             reduce using rule 41 (literal -> STRING .)
    LTE             reduce using rule 41 (literal -> STRING .)
    IS              reduce using rule 41 (literal -> STRING .)
    GT              reduce using rule 41 (literal -> STRING .)
    LT              reduce using rule 41 (literal -> STRING .)
    EQUALS          reduce using rule 41 (literal -> STRING .)
    OR              reduce using rule 41 (literal -> STRING .)
    AND             reduce using rule 41 (literal -> STRING .)
    PLUS            reduce using rule 41 (literal -> STRING .)
    MINUS           reduce using rule 41 (literal -> STRING .)
    IN              reduce using rule 41 (literal -> STRING .)
    RIGHT_PAREN     reduce using rule 41 (literal -> STRING .)
    TO              reduce using rule 41 (literal -> STRING .)
    COMMA           reduce using rule 41 (literal -> STRING .)
    STEP            reduce using rule 41 (literal -> STRING .)
    LEFT_BRACE      reduce using rule 41 (literal -> STRING .)


state 33

    (18) statement_list -> statement statement_list .

    $end            reduce using rule 18 (statement_list -> statement statement_list .)
    RIGHT_BRACE     reduce using rule 18 (statement_list -> statement statement_list .)


state 34

    (3) assignment_statement -> PUT expression . IN IDENTIFIER SEMICOLON
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    IN              shift and go to state 66
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 35

    (24) expression -> IDENTIFIER . INCREMENT
    (34) expression -> IDENTIFIER . DECREMENT
    (32) literal -> IDENTIFIER .

    INCREMENT       shift and go to state 49
    DECREMENT       shift and go to state 50
    PRODUCT         reduce using rule 32 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 32 (literal -> IDENTIFIER .)
    IN              reduce using rule 32 (literal -> IDENTIFIER .)
    GTE             reduce using rule 32 (literal -> IDENTIFIER .)
    LTE             reduce using rule 32 (literal -> IDENTIFIER .)
    IS              reduce using rule 32 (literal -> IDENTIFIER .)
    GT              reduce using rule 32 (literal -> IDENTIFIER .)
    LT              reduce using rule 32 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 32 (literal -> IDENTIFIER .)
    OR              reduce using rule 32 (literal -> IDENTIFIER .)
    AND             reduce using rule 32 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 32 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 32 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 32 (literal -> IDENTIFIER .)
    TO              reduce using rule 32 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 32 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 32 (literal -> IDENTIFIER .)
    STEP            reduce using rule 32 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 32 (literal -> IDENTIFIER .)


state 36

    (5) expression_statement -> expression SEMICOLON .

    PUT             reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    LET             reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    DO              reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    LOG             reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    FUNCTION        reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    STRING          reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    $end            reduce using rule 5 (expression_statement -> expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 5 (expression_statement -> expression SEMICOLON .)


state 37

    (46) expression -> expression GTE . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 67
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 38

    (47) expression -> expression LTE . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 68
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 39

    (48) expression -> expression IS . GREATER THAN term
    (49) expression -> expression IS . LESS THAN term
    (52) expression -> expression IS . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    GREATER         shift and go to state 69
    LESS            shift and go to state 71
    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 70
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 40

    (50) expression -> expression GT . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 72
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 41

    (51) expression -> expression LT . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 73
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 42

    (53) expression -> expression EQUALS . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 74
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 43

    (54) expression -> expression OR . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 75
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 44

    (55) expression -> expression AND . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 76
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 45

    (56) expression -> expression PLUS . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 77
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 46

    (57) expression -> expression MINUS . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 78
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 47

    (29) assignment_statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 79
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 48

    (2) function_call -> IDENTIFIER LEFT_PAREN . RIGHT_PAREN SEMICOLON
    (28) function_call -> IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (1) arguments -> . expression COMMA arguments
    (27) arguments -> . expression
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    RIGHT_PAREN     shift and go to state 80
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    arguments                      shift and go to state 81
    expression                     shift and go to state 82
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 49

    (24) expression -> IDENTIFIER INCREMENT .

    SEMICOLON       reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    GTE             reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    LTE             reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    IS              reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    GT              reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    LT              reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    EQUALS          reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    OR              reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    AND             reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    PLUS            reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    MINUS           reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    IN              reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    RIGHT_PAREN     reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    TO              reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    COMMA           reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    STEP            reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)
    LEFT_BRACE      reduce using rule 24 (expression -> IDENTIFIER INCREMENT .)


state 50

    (34) expression -> IDENTIFIER DECREMENT .

    SEMICOLON       reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    GTE             reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    LTE             reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    IS              reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    GT              reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    LT              reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    EQUALS          reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    OR              reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    AND             reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    PLUS            reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    MINUS           reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    IN              reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    RIGHT_PAREN     reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    TO              reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    COMMA           reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    STEP            reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)
    LEFT_BRACE      reduce using rule 34 (expression -> IDENTIFIER DECREMENT .)


state 51

    (37) assignment_statement -> LET IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 83


state 52

    (15) iterative_statement -> DO compound_statement . WHILE LEFT_PAREN expression RIGHT_PAREN

    WHILE           shift and go to state 84


state 53

    (17) iterative_statement -> WHILE LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 85
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 54

    (35) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 86
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 55

    (16) iterative_statement -> FOR LEFT_PAREN . expression TO expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> FOR LEFT_PAREN . expression TO expression STEP expression RIGHT_PAREN compound_statement
    (35) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 87
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 56

    (38) iterative_statement -> FOR expression . TO expression compound_statement
    (44) iterative_statement -> FOR expression . TO expression STEP expression compound_statement
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    TO              shift and go to state 88
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 57

    (4) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE compound_statement
    (30) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 89
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 58

    (22) compound_statement -> LEFT_BRACE statement_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 90


state 59

    (20) print_statement -> LOG LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (1) arguments -> . expression COMMA arguments
    (27) arguments -> . expression
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    arguments                      shift and go to state 91
    expression                     shift and go to state 82
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 60

    (21) function_statement -> FUNCTION IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (33) function_statement -> FUNCTION IDENTIFIER . LEFT_PAREN RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 92


state 61

    (42) expression -> MINUS term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 42 (expression -> MINUS term .)
    GTE             reduce using rule 42 (expression -> MINUS term .)
    LTE             reduce using rule 42 (expression -> MINUS term .)
    IS              reduce using rule 42 (expression -> MINUS term .)
    GT              reduce using rule 42 (expression -> MINUS term .)
    LT              reduce using rule 42 (expression -> MINUS term .)
    EQUALS          reduce using rule 42 (expression -> MINUS term .)
    OR              reduce using rule 42 (expression -> MINUS term .)
    AND             reduce using rule 42 (expression -> MINUS term .)
    PLUS            reduce using rule 42 (expression -> MINUS term .)
    MINUS           reduce using rule 42 (expression -> MINUS term .)
    IN              reduce using rule 42 (expression -> MINUS term .)
    RIGHT_PAREN     reduce using rule 42 (expression -> MINUS term .)
    TO              reduce using rule 42 (expression -> MINUS term .)
    COMMA           reduce using rule 42 (expression -> MINUS term .)
    STEP            reduce using rule 42 (expression -> MINUS term .)
    LEFT_BRACE      reduce using rule 42 (expression -> MINUS term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 62

    (32) literal -> IDENTIFIER .

    PRODUCT         reduce using rule 32 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 32 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 32 (literal -> IDENTIFIER .)
    GTE             reduce using rule 32 (literal -> IDENTIFIER .)
    LTE             reduce using rule 32 (literal -> IDENTIFIER .)
    IS              reduce using rule 32 (literal -> IDENTIFIER .)
    GT              reduce using rule 32 (literal -> IDENTIFIER .)
    LT              reduce using rule 32 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 32 (literal -> IDENTIFIER .)
    OR              reduce using rule 32 (literal -> IDENTIFIER .)
    AND             reduce using rule 32 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 32 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 32 (literal -> IDENTIFIER .)
    IN              reduce using rule 32 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 32 (literal -> IDENTIFIER .)
    TO              reduce using rule 32 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 32 (literal -> IDENTIFIER .)
    STEP            reduce using rule 32 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 32 (literal -> IDENTIFIER .)


state 63

    (26) term -> term PRODUCT . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    factor                         shift and go to state 93
    literal                        shift and go to state 29

state 64

    (36) term -> term DIVIDE . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    factor                         shift and go to state 94
    literal                        shift and go to state 29

state 65

    (45) expression -> NOT term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 45 (expression -> NOT term .)
    GTE             reduce using rule 45 (expression -> NOT term .)
    LTE             reduce using rule 45 (expression -> NOT term .)
    IS              reduce using rule 45 (expression -> NOT term .)
    GT              reduce using rule 45 (expression -> NOT term .)
    LT              reduce using rule 45 (expression -> NOT term .)
    EQUALS          reduce using rule 45 (expression -> NOT term .)
    OR              reduce using rule 45 (expression -> NOT term .)
    AND             reduce using rule 45 (expression -> NOT term .)
    PLUS            reduce using rule 45 (expression -> NOT term .)
    MINUS           reduce using rule 45 (expression -> NOT term .)
    IN              reduce using rule 45 (expression -> NOT term .)
    RIGHT_PAREN     reduce using rule 45 (expression -> NOT term .)
    TO              reduce using rule 45 (expression -> NOT term .)
    COMMA           reduce using rule 45 (expression -> NOT term .)
    STEP            reduce using rule 45 (expression -> NOT term .)
    LEFT_BRACE      reduce using rule 45 (expression -> NOT term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 66

    (3) assignment_statement -> PUT expression IN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 95


state 67

    (46) expression -> expression GTE term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 46 (expression -> expression GTE term .)
    GTE             reduce using rule 46 (expression -> expression GTE term .)
    LTE             reduce using rule 46 (expression -> expression GTE term .)
    IS              reduce using rule 46 (expression -> expression GTE term .)
    GT              reduce using rule 46 (expression -> expression GTE term .)
    LT              reduce using rule 46 (expression -> expression GTE term .)
    EQUALS          reduce using rule 46 (expression -> expression GTE term .)
    OR              reduce using rule 46 (expression -> expression GTE term .)
    AND             reduce using rule 46 (expression -> expression GTE term .)
    PLUS            reduce using rule 46 (expression -> expression GTE term .)
    MINUS           reduce using rule 46 (expression -> expression GTE term .)
    IN              reduce using rule 46 (expression -> expression GTE term .)
    RIGHT_PAREN     reduce using rule 46 (expression -> expression GTE term .)
    TO              reduce using rule 46 (expression -> expression GTE term .)
    COMMA           reduce using rule 46 (expression -> expression GTE term .)
    STEP            reduce using rule 46 (expression -> expression GTE term .)
    LEFT_BRACE      reduce using rule 46 (expression -> expression GTE term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 68

    (47) expression -> expression LTE term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 47 (expression -> expression LTE term .)
    GTE             reduce using rule 47 (expression -> expression LTE term .)
    LTE             reduce using rule 47 (expression -> expression LTE term .)
    IS              reduce using rule 47 (expression -> expression LTE term .)
    GT              reduce using rule 47 (expression -> expression LTE term .)
    LT              reduce using rule 47 (expression -> expression LTE term .)
    EQUALS          reduce using rule 47 (expression -> expression LTE term .)
    OR              reduce using rule 47 (expression -> expression LTE term .)
    AND             reduce using rule 47 (expression -> expression LTE term .)
    PLUS            reduce using rule 47 (expression -> expression LTE term .)
    MINUS           reduce using rule 47 (expression -> expression LTE term .)
    IN              reduce using rule 47 (expression -> expression LTE term .)
    RIGHT_PAREN     reduce using rule 47 (expression -> expression LTE term .)
    TO              reduce using rule 47 (expression -> expression LTE term .)
    COMMA           reduce using rule 47 (expression -> expression LTE term .)
    STEP            reduce using rule 47 (expression -> expression LTE term .)
    LEFT_BRACE      reduce using rule 47 (expression -> expression LTE term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 69

    (48) expression -> expression IS GREATER . THAN term

    THAN            shift and go to state 96


state 70

    (52) expression -> expression IS term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 52 (expression -> expression IS term .)
    GTE             reduce using rule 52 (expression -> expression IS term .)
    LTE             reduce using rule 52 (expression -> expression IS term .)
    IS              reduce using rule 52 (expression -> expression IS term .)
    GT              reduce using rule 52 (expression -> expression IS term .)
    LT              reduce using rule 52 (expression -> expression IS term .)
    EQUALS          reduce using rule 52 (expression -> expression IS term .)
    OR              reduce using rule 52 (expression -> expression IS term .)
    AND             reduce using rule 52 (expression -> expression IS term .)
    PLUS            reduce using rule 52 (expression -> expression IS term .)
    MINUS           reduce using rule 52 (expression -> expression IS term .)
    IN              reduce using rule 52 (expression -> expression IS term .)
    RIGHT_PAREN     reduce using rule 52 (expression -> expression IS term .)
    TO              reduce using rule 52 (expression -> expression IS term .)
    COMMA           reduce using rule 52 (expression -> expression IS term .)
    STEP            reduce using rule 52 (expression -> expression IS term .)
    LEFT_BRACE      reduce using rule 52 (expression -> expression IS term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 71

    (49) expression -> expression IS LESS . THAN term

    THAN            shift and go to state 97


state 72

    (50) expression -> expression GT term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 50 (expression -> expression GT term .)
    GTE             reduce using rule 50 (expression -> expression GT term .)
    LTE             reduce using rule 50 (expression -> expression GT term .)
    IS              reduce using rule 50 (expression -> expression GT term .)
    GT              reduce using rule 50 (expression -> expression GT term .)
    LT              reduce using rule 50 (expression -> expression GT term .)
    EQUALS          reduce using rule 50 (expression -> expression GT term .)
    OR              reduce using rule 50 (expression -> expression GT term .)
    AND             reduce using rule 50 (expression -> expression GT term .)
    PLUS            reduce using rule 50 (expression -> expression GT term .)
    MINUS           reduce using rule 50 (expression -> expression GT term .)
    IN              reduce using rule 50 (expression -> expression GT term .)
    RIGHT_PAREN     reduce using rule 50 (expression -> expression GT term .)
    TO              reduce using rule 50 (expression -> expression GT term .)
    COMMA           reduce using rule 50 (expression -> expression GT term .)
    STEP            reduce using rule 50 (expression -> expression GT term .)
    LEFT_BRACE      reduce using rule 50 (expression -> expression GT term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 73

    (51) expression -> expression LT term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 51 (expression -> expression LT term .)
    GTE             reduce using rule 51 (expression -> expression LT term .)
    LTE             reduce using rule 51 (expression -> expression LT term .)
    IS              reduce using rule 51 (expression -> expression LT term .)
    GT              reduce using rule 51 (expression -> expression LT term .)
    LT              reduce using rule 51 (expression -> expression LT term .)
    EQUALS          reduce using rule 51 (expression -> expression LT term .)
    OR              reduce using rule 51 (expression -> expression LT term .)
    AND             reduce using rule 51 (expression -> expression LT term .)
    PLUS            reduce using rule 51 (expression -> expression LT term .)
    MINUS           reduce using rule 51 (expression -> expression LT term .)
    IN              reduce using rule 51 (expression -> expression LT term .)
    RIGHT_PAREN     reduce using rule 51 (expression -> expression LT term .)
    TO              reduce using rule 51 (expression -> expression LT term .)
    COMMA           reduce using rule 51 (expression -> expression LT term .)
    STEP            reduce using rule 51 (expression -> expression LT term .)
    LEFT_BRACE      reduce using rule 51 (expression -> expression LT term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 74

    (53) expression -> expression EQUALS term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 53 (expression -> expression EQUALS term .)
    GTE             reduce using rule 53 (expression -> expression EQUALS term .)
    LTE             reduce using rule 53 (expression -> expression EQUALS term .)
    IS              reduce using rule 53 (expression -> expression EQUALS term .)
    GT              reduce using rule 53 (expression -> expression EQUALS term .)
    LT              reduce using rule 53 (expression -> expression EQUALS term .)
    EQUALS          reduce using rule 53 (expression -> expression EQUALS term .)
    OR              reduce using rule 53 (expression -> expression EQUALS term .)
    AND             reduce using rule 53 (expression -> expression EQUALS term .)
    PLUS            reduce using rule 53 (expression -> expression EQUALS term .)
    MINUS           reduce using rule 53 (expression -> expression EQUALS term .)
    IN              reduce using rule 53 (expression -> expression EQUALS term .)
    RIGHT_PAREN     reduce using rule 53 (expression -> expression EQUALS term .)
    TO              reduce using rule 53 (expression -> expression EQUALS term .)
    COMMA           reduce using rule 53 (expression -> expression EQUALS term .)
    STEP            reduce using rule 53 (expression -> expression EQUALS term .)
    LEFT_BRACE      reduce using rule 53 (expression -> expression EQUALS term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 75

    (54) expression -> expression OR term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 54 (expression -> expression OR term .)
    GTE             reduce using rule 54 (expression -> expression OR term .)
    LTE             reduce using rule 54 (expression -> expression OR term .)
    IS              reduce using rule 54 (expression -> expression OR term .)
    GT              reduce using rule 54 (expression -> expression OR term .)
    LT              reduce using rule 54 (expression -> expression OR term .)
    EQUALS          reduce using rule 54 (expression -> expression OR term .)
    OR              reduce using rule 54 (expression -> expression OR term .)
    AND             reduce using rule 54 (expression -> expression OR term .)
    PLUS            reduce using rule 54 (expression -> expression OR term .)
    MINUS           reduce using rule 54 (expression -> expression OR term .)
    IN              reduce using rule 54 (expression -> expression OR term .)
    RIGHT_PAREN     reduce using rule 54 (expression -> expression OR term .)
    TO              reduce using rule 54 (expression -> expression OR term .)
    COMMA           reduce using rule 54 (expression -> expression OR term .)
    STEP            reduce using rule 54 (expression -> expression OR term .)
    LEFT_BRACE      reduce using rule 54 (expression -> expression OR term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 76

    (55) expression -> expression AND term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 55 (expression -> expression AND term .)
    GTE             reduce using rule 55 (expression -> expression AND term .)
    LTE             reduce using rule 55 (expression -> expression AND term .)
    IS              reduce using rule 55 (expression -> expression AND term .)
    GT              reduce using rule 55 (expression -> expression AND term .)
    LT              reduce using rule 55 (expression -> expression AND term .)
    EQUALS          reduce using rule 55 (expression -> expression AND term .)
    OR              reduce using rule 55 (expression -> expression AND term .)
    AND             reduce using rule 55 (expression -> expression AND term .)
    PLUS            reduce using rule 55 (expression -> expression AND term .)
    MINUS           reduce using rule 55 (expression -> expression AND term .)
    IN              reduce using rule 55 (expression -> expression AND term .)
    RIGHT_PAREN     reduce using rule 55 (expression -> expression AND term .)
    TO              reduce using rule 55 (expression -> expression AND term .)
    COMMA           reduce using rule 55 (expression -> expression AND term .)
    STEP            reduce using rule 55 (expression -> expression AND term .)
    LEFT_BRACE      reduce using rule 55 (expression -> expression AND term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 77

    (56) expression -> expression PLUS term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 56 (expression -> expression PLUS term .)
    GTE             reduce using rule 56 (expression -> expression PLUS term .)
    LTE             reduce using rule 56 (expression -> expression PLUS term .)
    IS              reduce using rule 56 (expression -> expression PLUS term .)
    GT              reduce using rule 56 (expression -> expression PLUS term .)
    LT              reduce using rule 56 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 56 (expression -> expression PLUS term .)
    OR              reduce using rule 56 (expression -> expression PLUS term .)
    AND             reduce using rule 56 (expression -> expression PLUS term .)
    PLUS            reduce using rule 56 (expression -> expression PLUS term .)
    MINUS           reduce using rule 56 (expression -> expression PLUS term .)
    IN              reduce using rule 56 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 56 (expression -> expression PLUS term .)
    TO              reduce using rule 56 (expression -> expression PLUS term .)
    COMMA           reduce using rule 56 (expression -> expression PLUS term .)
    STEP            reduce using rule 56 (expression -> expression PLUS term .)
    LEFT_BRACE      reduce using rule 56 (expression -> expression PLUS term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 78

    (57) expression -> expression MINUS term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 57 (expression -> expression MINUS term .)
    GTE             reduce using rule 57 (expression -> expression MINUS term .)
    LTE             reduce using rule 57 (expression -> expression MINUS term .)
    IS              reduce using rule 57 (expression -> expression MINUS term .)
    GT              reduce using rule 57 (expression -> expression MINUS term .)
    LT              reduce using rule 57 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 57 (expression -> expression MINUS term .)
    OR              reduce using rule 57 (expression -> expression MINUS term .)
    AND             reduce using rule 57 (expression -> expression MINUS term .)
    PLUS            reduce using rule 57 (expression -> expression MINUS term .)
    MINUS           reduce using rule 57 (expression -> expression MINUS term .)
    IN              reduce using rule 57 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 57 (expression -> expression MINUS term .)
    TO              reduce using rule 57 (expression -> expression MINUS term .)
    COMMA           reduce using rule 57 (expression -> expression MINUS term .)
    STEP            reduce using rule 57 (expression -> expression MINUS term .)
    LEFT_BRACE      reduce using rule 57 (expression -> expression MINUS term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 79

    (29) assignment_statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 98
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 80

    (2) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 99


state 81

    (28) function_call -> IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 100


state 82

    (1) arguments -> expression . COMMA arguments
    (27) arguments -> expression .
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    COMMA           shift and go to state 101
    RIGHT_PAREN     reduce using rule 27 (arguments -> expression .)
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 83

    (37) assignment_statement -> LET IDENTIFIER ASSIGN . expression SEMICOLON
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 102
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 84

    (15) iterative_statement -> DO compound_statement WHILE . LEFT_PAREN expression RIGHT_PAREN

    LEFT_PAREN      shift and go to state 103


state 85

    (17) iterative_statement -> WHILE LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 104
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 86

    (35) factor -> LEFT_PAREN expression RIGHT_PAREN .

    PRODUCT         reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GTE             reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LTE             reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IS              reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GT              reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LT              reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IN              reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TO              reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    STEP            reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 35 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 87

    (16) iterative_statement -> FOR LEFT_PAREN expression . TO expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> FOR LEFT_PAREN expression . TO expression STEP expression RIGHT_PAREN compound_statement
    (35) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    TO              shift and go to state 105
    RIGHT_PAREN     shift and go to state 86
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 88

    (38) iterative_statement -> FOR expression TO . expression compound_statement
    (44) iterative_statement -> FOR expression TO . expression STEP expression compound_statement
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 106
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 89

    (4) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE compound_statement
    (30) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 107
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 90

    (22) compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .

    PUT             reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LET             reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DO              reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FOR             reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    WHILE           reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IF              reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LOG             reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FUNCTION        reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    MINUS           reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    NOT             reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    INTEGER         reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRING          reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    $end            reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    ELSE            reduce using rule 22 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)


state 91

    (20) print_statement -> LOG LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 108


state 92

    (21) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN compound_statement
    (33) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN . RIGHT_PAREN compound_statement
    (1) arguments -> . expression COMMA arguments
    (27) arguments -> . expression
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    RIGHT_PAREN     shift and go to state 110
    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    arguments                      shift and go to state 109
    expression                     shift and go to state 82
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 93

    (26) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 26 (term -> term PRODUCT factor .)
    DIVIDE          reduce using rule 26 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 26 (term -> term PRODUCT factor .)
    GTE             reduce using rule 26 (term -> term PRODUCT factor .)
    LTE             reduce using rule 26 (term -> term PRODUCT factor .)
    IS              reduce using rule 26 (term -> term PRODUCT factor .)
    GT              reduce using rule 26 (term -> term PRODUCT factor .)
    LT              reduce using rule 26 (term -> term PRODUCT factor .)
    EQUALS          reduce using rule 26 (term -> term PRODUCT factor .)
    OR              reduce using rule 26 (term -> term PRODUCT factor .)
    AND             reduce using rule 26 (term -> term PRODUCT factor .)
    PLUS            reduce using rule 26 (term -> term PRODUCT factor .)
    MINUS           reduce using rule 26 (term -> term PRODUCT factor .)
    IN              reduce using rule 26 (term -> term PRODUCT factor .)
    RIGHT_PAREN     reduce using rule 26 (term -> term PRODUCT factor .)
    TO              reduce using rule 26 (term -> term PRODUCT factor .)
    COMMA           reduce using rule 26 (term -> term PRODUCT factor .)
    STEP            reduce using rule 26 (term -> term PRODUCT factor .)
    LEFT_BRACE      reduce using rule 26 (term -> term PRODUCT factor .)


state 94

    (36) term -> term DIVIDE factor .

    PRODUCT         reduce using rule 36 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 36 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 36 (term -> term DIVIDE factor .)
    GTE             reduce using rule 36 (term -> term DIVIDE factor .)
    LTE             reduce using rule 36 (term -> term DIVIDE factor .)
    IS              reduce using rule 36 (term -> term DIVIDE factor .)
    GT              reduce using rule 36 (term -> term DIVIDE factor .)
    LT              reduce using rule 36 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 36 (term -> term DIVIDE factor .)
    OR              reduce using rule 36 (term -> term DIVIDE factor .)
    AND             reduce using rule 36 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 36 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 36 (term -> term DIVIDE factor .)
    IN              reduce using rule 36 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 36 (term -> term DIVIDE factor .)
    TO              reduce using rule 36 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 36 (term -> term DIVIDE factor .)
    STEP            reduce using rule 36 (term -> term DIVIDE factor .)
    LEFT_BRACE      reduce using rule 36 (term -> term DIVIDE factor .)


state 95

    (3) assignment_statement -> PUT expression IN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 111


state 96

    (48) expression -> expression IS GREATER THAN . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 112
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 97

    (49) expression -> expression IS LESS THAN . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    LEFT_PAREN      shift and go to state 19
    IDENTIFIER      shift and go to state 62
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    term                           shift and go to state 113
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 98

    (29) assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    PUT             reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FUNCTION        reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 29 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 99

    (2) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .

    PUT             reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FUNCTION        reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 2 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)


state 100

    (28) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 114


state 101

    (1) arguments -> expression COMMA . arguments
    (1) arguments -> . expression COMMA arguments
    (27) arguments -> . expression
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 82
    arguments                      shift and go to state 115
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 102

    (37) assignment_statement -> LET IDENTIFIER ASSIGN expression . SEMICOLON
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 116
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 103

    (15) iterative_statement -> DO compound_statement WHILE LEFT_PAREN . expression RIGHT_PAREN
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 117
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 104

    (17) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 118

state 105

    (16) iterative_statement -> FOR LEFT_PAREN expression TO . expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> FOR LEFT_PAREN expression TO . expression STEP expression RIGHT_PAREN compound_statement
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 119
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 106

    (38) iterative_statement -> FOR expression TO expression . compound_statement
    (44) iterative_statement -> FOR expression TO expression . STEP expression compound_statement
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    STEP            shift and go to state 121
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 120

state 107

    (4) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE compound_statement
    (30) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 122

state 108

    (20) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 123


state 109

    (21) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 124


state 110

    (33) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN . compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 125

state 111

    (3) assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .

    PUT             reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LET             reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DO              reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 3 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)


state 112

    (48) expression -> expression IS GREATER THAN term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    GTE             reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    LTE             reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    IS              reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    GT              reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    LT              reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    EQUALS          reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    OR              reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    AND             reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    PLUS            reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    MINUS           reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    IN              reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    RIGHT_PAREN     reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    TO              reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    COMMA           reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    STEP            reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    LEFT_BRACE      reduce using rule 48 (expression -> expression IS GREATER THAN term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 113

    (49) expression -> expression IS LESS THAN term .
    (26) term -> term . PRODUCT factor
    (36) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 49 (expression -> expression IS LESS THAN term .)
    GTE             reduce using rule 49 (expression -> expression IS LESS THAN term .)
    LTE             reduce using rule 49 (expression -> expression IS LESS THAN term .)
    IS              reduce using rule 49 (expression -> expression IS LESS THAN term .)
    GT              reduce using rule 49 (expression -> expression IS LESS THAN term .)
    LT              reduce using rule 49 (expression -> expression IS LESS THAN term .)
    EQUALS          reduce using rule 49 (expression -> expression IS LESS THAN term .)
    OR              reduce using rule 49 (expression -> expression IS LESS THAN term .)
    AND             reduce using rule 49 (expression -> expression IS LESS THAN term .)
    PLUS            reduce using rule 49 (expression -> expression IS LESS THAN term .)
    MINUS           reduce using rule 49 (expression -> expression IS LESS THAN term .)
    IN              reduce using rule 49 (expression -> expression IS LESS THAN term .)
    RIGHT_PAREN     reduce using rule 49 (expression -> expression IS LESS THAN term .)
    TO              reduce using rule 49 (expression -> expression IS LESS THAN term .)
    COMMA           reduce using rule 49 (expression -> expression IS LESS THAN term .)
    STEP            reduce using rule 49 (expression -> expression IS LESS THAN term .)
    LEFT_BRACE      reduce using rule 49 (expression -> expression IS LESS THAN term .)
    PRODUCT         shift and go to state 63
    DIVIDE          shift and go to state 64


state 114

    (28) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    PUT             reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FUNCTION        reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 28 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 115

    (1) arguments -> expression COMMA arguments .

    RIGHT_PAREN     reduce using rule 1 (arguments -> expression COMMA arguments .)


state 116

    (37) assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .

    PUT             reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FUNCTION        reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 37 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)


state 117

    (15) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression . RIGHT_PAREN
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 126
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 118

    (17) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .

    PUT             reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 17 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 119

    (16) iterative_statement -> FOR LEFT_PAREN expression TO expression . RIGHT_PAREN compound_statement
    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression . STEP expression RIGHT_PAREN compound_statement
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 127
    STEP            shift and go to state 128
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 120

    (38) iterative_statement -> FOR expression TO expression compound_statement .

    PUT             reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    IDENTIFIER      reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    LET             reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    SEMICOLON       reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    DO              reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    FOR             reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    WHILE           reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    IF              reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_BRACE      reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    LOG             reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    FUNCTION        reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    MINUS           reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    NOT             reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_PAREN      reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    DOUBLE          reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    INTEGER         reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRING          reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    $end            reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)
    RIGHT_BRACE     reduce using rule 38 (iterative_statement -> FOR expression TO expression compound_statement .)


state 121

    (44) iterative_statement -> FOR expression TO expression STEP . expression compound_statement
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 129
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 122

    (4) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE compound_statement
    (30) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .

    ELSE            shift and go to state 130
    PUT             reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 30 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 123

    (20) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    PUT             reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FUNCTION        reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 20 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 124

    (21) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 131

state 125

    (33) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .

    PUT             reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LET             reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DO              reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IF              reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    $end            reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 33 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)


state 126

    (15) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .

    PUT             reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IDENTIFIER      reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LET             reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DO              reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FOR             reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    WHILE           reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IF              reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LOG             reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FUNCTION        reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DOUBLE          reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    INTEGER         reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRING          reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    $end            reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 15 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)


state 127

    (16) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN . compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 132

state 128

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP . expression RIGHT_PAREN compound_statement
    (24) expression -> . IDENTIFIER INCREMENT
    (34) expression -> . IDENTIFIER DECREMENT
    (42) expression -> . MINUS term
    (45) expression -> . NOT term
    (46) expression -> . expression GTE term
    (47) expression -> . expression LTE term
    (48) expression -> . expression IS GREATER THAN term
    (49) expression -> . expression IS LESS THAN term
    (50) expression -> . expression GT term
    (51) expression -> . expression LT term
    (52) expression -> . expression IS term
    (53) expression -> . expression EQUALS term
    (54) expression -> . expression OR term
    (55) expression -> . expression AND term
    (56) expression -> . expression PLUS term
    (57) expression -> . expression MINUS term
    (58) expression -> . term
    (26) term -> . term PRODUCT factor
    (36) term -> . term DIVIDE factor
    (43) term -> . factor
    (25) factor -> . literal
    (35) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (32) literal -> . IDENTIFIER
    (39) literal -> . DOUBLE
    (40) literal -> . INTEGER
    (41) literal -> . STRING

    IDENTIFIER      shift and go to state 35
    MINUS           shift and go to state 25
    NOT             shift and go to state 27
    LEFT_PAREN      shift and go to state 19
    DOUBLE          shift and go to state 30
    INTEGER         shift and go to state 31
    STRING          shift and go to state 32

    expression                     shift and go to state 133
    term                           shift and go to state 26
    factor                         shift and go to state 28
    literal                        shift and go to state 29

state 129

    (44) iterative_statement -> FOR expression TO expression STEP expression . compound_statement
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 134

state 130

    (4) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 135

state 131

    (21) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .

    PUT             reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LET             reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DO              reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IF              reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    $end            reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 21 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)


state 132

    (16) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .

    PUT             reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 16 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)


state 133

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression . RIGHT_PAREN compound_statement
    (46) expression -> expression . GTE term
    (47) expression -> expression . LTE term
    (48) expression -> expression . IS GREATER THAN term
    (49) expression -> expression . IS LESS THAN term
    (50) expression -> expression . GT term
    (51) expression -> expression . LT term
    (52) expression -> expression . IS term
    (53) expression -> expression . EQUALS term
    (54) expression -> expression . OR term
    (55) expression -> expression . AND term
    (56) expression -> expression . PLUS term
    (57) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 136
    GTE             shift and go to state 37
    LTE             shift and go to state 38
    IS              shift and go to state 39
    GT              shift and go to state 40
    LT              shift and go to state 41
    EQUALS          shift and go to state 42
    OR              shift and go to state 43
    AND             shift and go to state 44
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46


state 134

    (44) iterative_statement -> FOR expression TO expression STEP expression compound_statement .

    PUT             reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IDENTIFIER      reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LET             reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    SEMICOLON       reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DO              reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FOR             reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    WHILE           reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IF              reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_BRACE      reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LOG             reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FUNCTION        reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    MINUS           reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    NOT             reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_PAREN      reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DOUBLE          reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    INTEGER         reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRING          reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    $end            reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    RIGHT_BRACE     reduce using rule 44 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)


state 135

    (4) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .

    PUT             reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IDENTIFIER      reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LET             reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    SEMICOLON       reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DO              reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FOR             reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IF              reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_BRACE      reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LOG             reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FUNCTION        reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    MINUS           reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    NOT             reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_PAREN      reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DOUBLE          reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    INTEGER         reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRING          reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    $end            reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    RIGHT_BRACE     reduce using rule 4 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)


state 136

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN . compound_statement
    (22) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 22

    compound_statement             shift and go to state 137

state 137

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .

    PUT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)

