Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    MODULUS
    OBJECT
    RETURN
    SKIP
    STRUCT

Grammar

Rule 0     S' -> program
Rule 1     type_specifier -> TYPE_BOOL
Rule 2     type_specifier -> TYPE_INT
Rule 3     type_specifier -> TYPE_CHAR
Rule 4     type_specifier -> TYPE_DOUBLE
Rule 5     type_specifier -> TYPE_STRING
Rule 6     arguments -> expression COMMA arguments
Rule 7     function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
Rule 8     assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON
Rule 9     conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
Rule 10    expression_statement -> expression SEMICOLON
Rule 11    expression_statement -> SEMICOLON
Rule 12    statement -> assignment_statement
Rule 13    statement -> expression_statement
Rule 14    statement -> iterative_statement
Rule 15    statement -> conditional_statement
Rule 16    statement -> compound_statement
Rule 17    statement -> print_statement
Rule 18    statement -> function_statement
Rule 19    statement -> function_call
Rule 20    iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
Rule 21    iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
Rule 22    iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 23    statement_list -> statement statement_list
Rule 24    statement_list -> <empty>
Rule 25    print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 26    function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
Rule 27    compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE
Rule 28    program -> statement_list
Rule 29    expression -> IDENTIFIER INCREMENT
Rule 30    factor -> literal
Rule 31    term -> term PRODUCT factor
Rule 32    arguments -> expression
Rule 33    function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 34    assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 35    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 36    iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
Rule 37    literal -> IDENTIFIER
Rule 38    function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
Rule 39    expression -> IDENTIFIER DECREMENT
Rule 40    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 41    term -> term DIVIDE factor
Rule 42    assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON
Rule 43    iterative_statement -> FOR expression TO expression compound_statement
Rule 44    literal -> DOUBLE
Rule 45    literal -> INTEGER
Rule 46    literal -> STRING
Rule 47    literal -> TRUE
Rule 48    literal -> FALSE
Rule 49    expression -> MINUS term
Rule 50    term -> factor
Rule 51    assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON
Rule 52    iterative_statement -> FOR expression TO expression STEP expression compound_statement
Rule 53    expression -> NOT term
Rule 54    expression -> expression GTE term
Rule 55    expression -> expression LTE term
Rule 56    expression -> expression IS GREATER THAN term
Rule 57    expression -> expression IS LESS THAN term
Rule 58    expression -> expression GT term
Rule 59    expression -> expression LT term
Rule 60    expression -> expression IS term
Rule 61    expression -> expression EQUALS term
Rule 62    expression -> expression OR term
Rule 63    expression -> expression AND term
Rule 64    expression -> expression PLUS term
Rule 65    expression -> expression MINUS term
Rule 66    expression -> term

Terminals, with rules where they appear

AND                  : 63
ASSIGN               : 34 42 51
BREAK                : 
COMMA                : 6
DECREMENT            : 39
DIVIDE               : 41
DO                   : 20
DOUBLE               : 44
ELSE                 : 9
EQUALS               : 61
FALSE                : 48
FOR                  : 21 36 43 52
FUNCTION             : 26 38
GREATER              : 56
GT                   : 58
GTE                  : 54
IDENTIFIER           : 7 8 26 29 33 34 37 38 39 42 51
IF                   : 9 35
IN                   : 8
INCREMENT            : 29
INTEGER              : 45
IS                   : 56 57 60
LEFT_BRACE           : 27
LEFT_PAREN           : 7 9 20 21 22 25 26 33 35 36 38 40
LESS                 : 57
LET                  : 42
LOG                  : 25
LT                   : 59
LTE                  : 55
MINUS                : 49 65
MODULUS              : 
NOT                  : 53
OBJECT               : 
OR                   : 62
PLUS                 : 64
PRODUCT              : 31
PUT                  : 8
RETURN               : 
RIGHT_BRACE          : 27
RIGHT_PAREN          : 7 9 20 21 22 25 26 33 35 36 38 40
SEMICOLON            : 7 8 10 11 25 33 34 42 51
SKIP                 : 
STEP                 : 36 52
STRING               : 46
STRUCT               : 
THAN                 : 56 57
TO                   : 21 36 43 52
TRUE                 : 47
TYPE_BOOL            : 1
TYPE_CHAR            : 3
TYPE_DOUBLE          : 4
TYPE_INT             : 2
TYPE_STRING          : 5
WHILE                : 20 22
error                : 

Nonterminals, with rules where they appear

arguments            : 6 25 26 33
assignment_statement : 12
compound_statement   : 9 9 16 20 21 22 26 35 36 38 43 52
conditional_statement : 15
expression           : 6 8 9 10 20 21 21 22 32 34 35 36 36 36 40 42 43 43 51 52 52 52 54 55 56 57 58 59 60 61 62 63 64 65
expression_statement : 13
factor               : 31 41 50
function_call        : 19
function_statement   : 18
iterative_statement  : 14
literal              : 30
print_statement      : 17
program              : 0
statement            : 23
statement_list       : 23 27 28
term                 : 31 41 49 53 54 55 56 57 58 59 60 61 62 63 64 65 66
type_specifier       : 51

Parsing method: LALR

state 0

    (0) S' -> . program
    (28) program -> . statement_list
    (23) statement_list -> . statement statement_list
    (24) statement_list -> .
    (12) statement -> . assignment_statement
    (13) statement -> . expression_statement
    (14) statement -> . iterative_statement
    (15) statement -> . conditional_statement
    (16) statement -> . compound_statement
    (17) statement -> . print_statement
    (18) statement -> . function_statement
    (19) statement -> . function_call
    (8) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (34) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (42) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (10) expression_statement -> . expression SEMICOLON
    (11) expression_statement -> . SEMICOLON
    (20) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (21) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (22) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (36) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR expression TO expression compound_statement
    (52) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (35) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (26) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (38) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (7) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (33) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    $end            reduce using rule 24 (statement_list -> .)
    PUT             shift and go to state 12
    IDENTIFIER      shift and go to state 14
    LET             shift and go to state 16
    SEMICOLON       shift and go to state 15
    DO              shift and go to state 18
    FOR             shift and go to state 21
    WHILE           shift and go to state 19
    IF              shift and go to state 22
    LEFT_BRACE      shift and go to state 23
    LOG             shift and go to state 24
    FUNCTION        shift and go to state 25
    TYPE_BOOL       shift and go to state 26
    TYPE_INT        shift and go to state 27
    TYPE_CHAR       shift and go to state 28
    TYPE_DOUBLE     shift and go to state 29
    TYPE_STRING     shift and go to state 30
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    function_statement             shift and go to state 10
    function_call                  shift and go to state 11
    expression                     shift and go to state 13
    type_specifier                 shift and go to state 17
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 1

    (0) S' -> program .



state 2

    (28) program -> statement_list .

    $end            reduce using rule 28 (program -> statement_list .)


state 3

    (23) statement_list -> statement . statement_list
    (23) statement_list -> . statement statement_list
    (24) statement_list -> .
    (12) statement -> . assignment_statement
    (13) statement -> . expression_statement
    (14) statement -> . iterative_statement
    (15) statement -> . conditional_statement
    (16) statement -> . compound_statement
    (17) statement -> . print_statement
    (18) statement -> . function_statement
    (19) statement -> . function_call
    (8) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (34) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (42) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (10) expression_statement -> . expression SEMICOLON
    (11) expression_statement -> . SEMICOLON
    (20) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (21) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (22) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (36) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR expression TO expression compound_statement
    (52) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (35) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (26) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (38) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (7) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (33) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    $end            reduce using rule 24 (statement_list -> .)
    RIGHT_BRACE     reduce using rule 24 (statement_list -> .)
    PUT             shift and go to state 12
    IDENTIFIER      shift and go to state 14
    LET             shift and go to state 16
    SEMICOLON       shift and go to state 15
    DO              shift and go to state 18
    FOR             shift and go to state 21
    WHILE           shift and go to state 19
    IF              shift and go to state 22
    LEFT_BRACE      shift and go to state 23
    LOG             shift and go to state 24
    FUNCTION        shift and go to state 25
    TYPE_BOOL       shift and go to state 26
    TYPE_INT        shift and go to state 27
    TYPE_CHAR       shift and go to state 28
    TYPE_DOUBLE     shift and go to state 29
    TYPE_STRING     shift and go to state 30
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    statement                      shift and go to state 3
    statement_list                 shift and go to state 41
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    function_statement             shift and go to state 10
    function_call                  shift and go to state 11
    expression                     shift and go to state 13
    type_specifier                 shift and go to state 17
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 4

    (12) statement -> assignment_statement .

    PUT             reduce using rule 12 (statement -> assignment_statement .)
    IDENTIFIER      reduce using rule 12 (statement -> assignment_statement .)
    LET             reduce using rule 12 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 12 (statement -> assignment_statement .)
    DO              reduce using rule 12 (statement -> assignment_statement .)
    FOR             reduce using rule 12 (statement -> assignment_statement .)
    WHILE           reduce using rule 12 (statement -> assignment_statement .)
    IF              reduce using rule 12 (statement -> assignment_statement .)
    LEFT_BRACE      reduce using rule 12 (statement -> assignment_statement .)
    LOG             reduce using rule 12 (statement -> assignment_statement .)
    FUNCTION        reduce using rule 12 (statement -> assignment_statement .)
    TYPE_BOOL       reduce using rule 12 (statement -> assignment_statement .)
    TYPE_INT        reduce using rule 12 (statement -> assignment_statement .)
    TYPE_CHAR       reduce using rule 12 (statement -> assignment_statement .)
    TYPE_DOUBLE     reduce using rule 12 (statement -> assignment_statement .)
    TYPE_STRING     reduce using rule 12 (statement -> assignment_statement .)
    MINUS           reduce using rule 12 (statement -> assignment_statement .)
    NOT             reduce using rule 12 (statement -> assignment_statement .)
    LEFT_PAREN      reduce using rule 12 (statement -> assignment_statement .)
    DOUBLE          reduce using rule 12 (statement -> assignment_statement .)
    INTEGER         reduce using rule 12 (statement -> assignment_statement .)
    STRING          reduce using rule 12 (statement -> assignment_statement .)
    TRUE            reduce using rule 12 (statement -> assignment_statement .)
    FALSE           reduce using rule 12 (statement -> assignment_statement .)
    $end            reduce using rule 12 (statement -> assignment_statement .)
    RIGHT_BRACE     reduce using rule 12 (statement -> assignment_statement .)


state 5

    (13) statement -> expression_statement .

    PUT             reduce using rule 13 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 13 (statement -> expression_statement .)
    LET             reduce using rule 13 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 13 (statement -> expression_statement .)
    DO              reduce using rule 13 (statement -> expression_statement .)
    FOR             reduce using rule 13 (statement -> expression_statement .)
    WHILE           reduce using rule 13 (statement -> expression_statement .)
    IF              reduce using rule 13 (statement -> expression_statement .)
    LEFT_BRACE      reduce using rule 13 (statement -> expression_statement .)
    LOG             reduce using rule 13 (statement -> expression_statement .)
    FUNCTION        reduce using rule 13 (statement -> expression_statement .)
    TYPE_BOOL       reduce using rule 13 (statement -> expression_statement .)
    TYPE_INT        reduce using rule 13 (statement -> expression_statement .)
    TYPE_CHAR       reduce using rule 13 (statement -> expression_statement .)
    TYPE_DOUBLE     reduce using rule 13 (statement -> expression_statement .)
    TYPE_STRING     reduce using rule 13 (statement -> expression_statement .)
    MINUS           reduce using rule 13 (statement -> expression_statement .)
    NOT             reduce using rule 13 (statement -> expression_statement .)
    LEFT_PAREN      reduce using rule 13 (statement -> expression_statement .)
    DOUBLE          reduce using rule 13 (statement -> expression_statement .)
    INTEGER         reduce using rule 13 (statement -> expression_statement .)
    STRING          reduce using rule 13 (statement -> expression_statement .)
    TRUE            reduce using rule 13 (statement -> expression_statement .)
    FALSE           reduce using rule 13 (statement -> expression_statement .)
    $end            reduce using rule 13 (statement -> expression_statement .)
    RIGHT_BRACE     reduce using rule 13 (statement -> expression_statement .)


state 6

    (14) statement -> iterative_statement .

    PUT             reduce using rule 14 (statement -> iterative_statement .)
    IDENTIFIER      reduce using rule 14 (statement -> iterative_statement .)
    LET             reduce using rule 14 (statement -> iterative_statement .)
    SEMICOLON       reduce using rule 14 (statement -> iterative_statement .)
    DO              reduce using rule 14 (statement -> iterative_statement .)
    FOR             reduce using rule 14 (statement -> iterative_statement .)
    WHILE           reduce using rule 14 (statement -> iterative_statement .)
    IF              reduce using rule 14 (statement -> iterative_statement .)
    LEFT_BRACE      reduce using rule 14 (statement -> iterative_statement .)
    LOG             reduce using rule 14 (statement -> iterative_statement .)
    FUNCTION        reduce using rule 14 (statement -> iterative_statement .)
    TYPE_BOOL       reduce using rule 14 (statement -> iterative_statement .)
    TYPE_INT        reduce using rule 14 (statement -> iterative_statement .)
    TYPE_CHAR       reduce using rule 14 (statement -> iterative_statement .)
    TYPE_DOUBLE     reduce using rule 14 (statement -> iterative_statement .)
    TYPE_STRING     reduce using rule 14 (statement -> iterative_statement .)
    MINUS           reduce using rule 14 (statement -> iterative_statement .)
    NOT             reduce using rule 14 (statement -> iterative_statement .)
    LEFT_PAREN      reduce using rule 14 (statement -> iterative_statement .)
    DOUBLE          reduce using rule 14 (statement -> iterative_statement .)
    INTEGER         reduce using rule 14 (statement -> iterative_statement .)
    STRING          reduce using rule 14 (statement -> iterative_statement .)
    TRUE            reduce using rule 14 (statement -> iterative_statement .)
    FALSE           reduce using rule 14 (statement -> iterative_statement .)
    $end            reduce using rule 14 (statement -> iterative_statement .)
    RIGHT_BRACE     reduce using rule 14 (statement -> iterative_statement .)


state 7

    (15) statement -> conditional_statement .

    PUT             reduce using rule 15 (statement -> conditional_statement .)
    IDENTIFIER      reduce using rule 15 (statement -> conditional_statement .)
    LET             reduce using rule 15 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 15 (statement -> conditional_statement .)
    DO              reduce using rule 15 (statement -> conditional_statement .)
    FOR             reduce using rule 15 (statement -> conditional_statement .)
    WHILE           reduce using rule 15 (statement -> conditional_statement .)
    IF              reduce using rule 15 (statement -> conditional_statement .)
    LEFT_BRACE      reduce using rule 15 (statement -> conditional_statement .)
    LOG             reduce using rule 15 (statement -> conditional_statement .)
    FUNCTION        reduce using rule 15 (statement -> conditional_statement .)
    TYPE_BOOL       reduce using rule 15 (statement -> conditional_statement .)
    TYPE_INT        reduce using rule 15 (statement -> conditional_statement .)
    TYPE_CHAR       reduce using rule 15 (statement -> conditional_statement .)
    TYPE_DOUBLE     reduce using rule 15 (statement -> conditional_statement .)
    TYPE_STRING     reduce using rule 15 (statement -> conditional_statement .)
    MINUS           reduce using rule 15 (statement -> conditional_statement .)
    NOT             reduce using rule 15 (statement -> conditional_statement .)
    LEFT_PAREN      reduce using rule 15 (statement -> conditional_statement .)
    DOUBLE          reduce using rule 15 (statement -> conditional_statement .)
    INTEGER         reduce using rule 15 (statement -> conditional_statement .)
    STRING          reduce using rule 15 (statement -> conditional_statement .)
    TRUE            reduce using rule 15 (statement -> conditional_statement .)
    FALSE           reduce using rule 15 (statement -> conditional_statement .)
    $end            reduce using rule 15 (statement -> conditional_statement .)
    RIGHT_BRACE     reduce using rule 15 (statement -> conditional_statement .)


state 8

    (16) statement -> compound_statement .

    PUT             reduce using rule 16 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 16 (statement -> compound_statement .)
    LET             reduce using rule 16 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 16 (statement -> compound_statement .)
    DO              reduce using rule 16 (statement -> compound_statement .)
    FOR             reduce using rule 16 (statement -> compound_statement .)
    WHILE           reduce using rule 16 (statement -> compound_statement .)
    IF              reduce using rule 16 (statement -> compound_statement .)
    LEFT_BRACE      reduce using rule 16 (statement -> compound_statement .)
    LOG             reduce using rule 16 (statement -> compound_statement .)
    FUNCTION        reduce using rule 16 (statement -> compound_statement .)
    TYPE_BOOL       reduce using rule 16 (statement -> compound_statement .)
    TYPE_INT        reduce using rule 16 (statement -> compound_statement .)
    TYPE_CHAR       reduce using rule 16 (statement -> compound_statement .)
    TYPE_DOUBLE     reduce using rule 16 (statement -> compound_statement .)
    TYPE_STRING     reduce using rule 16 (statement -> compound_statement .)
    MINUS           reduce using rule 16 (statement -> compound_statement .)
    NOT             reduce using rule 16 (statement -> compound_statement .)
    LEFT_PAREN      reduce using rule 16 (statement -> compound_statement .)
    DOUBLE          reduce using rule 16 (statement -> compound_statement .)
    INTEGER         reduce using rule 16 (statement -> compound_statement .)
    STRING          reduce using rule 16 (statement -> compound_statement .)
    TRUE            reduce using rule 16 (statement -> compound_statement .)
    FALSE           reduce using rule 16 (statement -> compound_statement .)
    $end            reduce using rule 16 (statement -> compound_statement .)
    RIGHT_BRACE     reduce using rule 16 (statement -> compound_statement .)


state 9

    (17) statement -> print_statement .

    PUT             reduce using rule 17 (statement -> print_statement .)
    IDENTIFIER      reduce using rule 17 (statement -> print_statement .)
    LET             reduce using rule 17 (statement -> print_statement .)
    SEMICOLON       reduce using rule 17 (statement -> print_statement .)
    DO              reduce using rule 17 (statement -> print_statement .)
    FOR             reduce using rule 17 (statement -> print_statement .)
    WHILE           reduce using rule 17 (statement -> print_statement .)
    IF              reduce using rule 17 (statement -> print_statement .)
    LEFT_BRACE      reduce using rule 17 (statement -> print_statement .)
    LOG             reduce using rule 17 (statement -> print_statement .)
    FUNCTION        reduce using rule 17 (statement -> print_statement .)
    TYPE_BOOL       reduce using rule 17 (statement -> print_statement .)
    TYPE_INT        reduce using rule 17 (statement -> print_statement .)
    TYPE_CHAR       reduce using rule 17 (statement -> print_statement .)
    TYPE_DOUBLE     reduce using rule 17 (statement -> print_statement .)
    TYPE_STRING     reduce using rule 17 (statement -> print_statement .)
    MINUS           reduce using rule 17 (statement -> print_statement .)
    NOT             reduce using rule 17 (statement -> print_statement .)
    LEFT_PAREN      reduce using rule 17 (statement -> print_statement .)
    DOUBLE          reduce using rule 17 (statement -> print_statement .)
    INTEGER         reduce using rule 17 (statement -> print_statement .)
    STRING          reduce using rule 17 (statement -> print_statement .)
    TRUE            reduce using rule 17 (statement -> print_statement .)
    FALSE           reduce using rule 17 (statement -> print_statement .)
    $end            reduce using rule 17 (statement -> print_statement .)
    RIGHT_BRACE     reduce using rule 17 (statement -> print_statement .)


state 10

    (18) statement -> function_statement .

    PUT             reduce using rule 18 (statement -> function_statement .)
    IDENTIFIER      reduce using rule 18 (statement -> function_statement .)
    LET             reduce using rule 18 (statement -> function_statement .)
    SEMICOLON       reduce using rule 18 (statement -> function_statement .)
    DO              reduce using rule 18 (statement -> function_statement .)
    FOR             reduce using rule 18 (statement -> function_statement .)
    WHILE           reduce using rule 18 (statement -> function_statement .)
    IF              reduce using rule 18 (statement -> function_statement .)
    LEFT_BRACE      reduce using rule 18 (statement -> function_statement .)
    LOG             reduce using rule 18 (statement -> function_statement .)
    FUNCTION        reduce using rule 18 (statement -> function_statement .)
    TYPE_BOOL       reduce using rule 18 (statement -> function_statement .)
    TYPE_INT        reduce using rule 18 (statement -> function_statement .)
    TYPE_CHAR       reduce using rule 18 (statement -> function_statement .)
    TYPE_DOUBLE     reduce using rule 18 (statement -> function_statement .)
    TYPE_STRING     reduce using rule 18 (statement -> function_statement .)
    MINUS           reduce using rule 18 (statement -> function_statement .)
    NOT             reduce using rule 18 (statement -> function_statement .)
    LEFT_PAREN      reduce using rule 18 (statement -> function_statement .)
    DOUBLE          reduce using rule 18 (statement -> function_statement .)
    INTEGER         reduce using rule 18 (statement -> function_statement .)
    STRING          reduce using rule 18 (statement -> function_statement .)
    TRUE            reduce using rule 18 (statement -> function_statement .)
    FALSE           reduce using rule 18 (statement -> function_statement .)
    $end            reduce using rule 18 (statement -> function_statement .)
    RIGHT_BRACE     reduce using rule 18 (statement -> function_statement .)


state 11

    (19) statement -> function_call .

    PUT             reduce using rule 19 (statement -> function_call .)
    IDENTIFIER      reduce using rule 19 (statement -> function_call .)
    LET             reduce using rule 19 (statement -> function_call .)
    SEMICOLON       reduce using rule 19 (statement -> function_call .)
    DO              reduce using rule 19 (statement -> function_call .)
    FOR             reduce using rule 19 (statement -> function_call .)
    WHILE           reduce using rule 19 (statement -> function_call .)
    IF              reduce using rule 19 (statement -> function_call .)
    LEFT_BRACE      reduce using rule 19 (statement -> function_call .)
    LOG             reduce using rule 19 (statement -> function_call .)
    FUNCTION        reduce using rule 19 (statement -> function_call .)
    TYPE_BOOL       reduce using rule 19 (statement -> function_call .)
    TYPE_INT        reduce using rule 19 (statement -> function_call .)
    TYPE_CHAR       reduce using rule 19 (statement -> function_call .)
    TYPE_DOUBLE     reduce using rule 19 (statement -> function_call .)
    TYPE_STRING     reduce using rule 19 (statement -> function_call .)
    MINUS           reduce using rule 19 (statement -> function_call .)
    NOT             reduce using rule 19 (statement -> function_call .)
    LEFT_PAREN      reduce using rule 19 (statement -> function_call .)
    DOUBLE          reduce using rule 19 (statement -> function_call .)
    INTEGER         reduce using rule 19 (statement -> function_call .)
    STRING          reduce using rule 19 (statement -> function_call .)
    TRUE            reduce using rule 19 (statement -> function_call .)
    FALSE           reduce using rule 19 (statement -> function_call .)
    $end            reduce using rule 19 (statement -> function_call .)
    RIGHT_BRACE     reduce using rule 19 (statement -> function_call .)


state 12

    (8) assignment_statement -> PUT . expression IN IDENTIFIER SEMICOLON
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 42
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 13

    (10) expression_statement -> expression . SEMICOLON
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 44
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 14

    (34) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (7) function_call -> IDENTIFIER . LEFT_PAREN RIGHT_PAREN SEMICOLON
    (33) function_call -> IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (29) expression -> IDENTIFIER . INCREMENT
    (39) expression -> IDENTIFIER . DECREMENT
    (37) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 55
    LEFT_PAREN      shift and go to state 56
    INCREMENT       shift and go to state 57
    DECREMENT       shift and go to state 58
    PRODUCT         reduce using rule 37 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 37 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 37 (literal -> IDENTIFIER .)
    GTE             reduce using rule 37 (literal -> IDENTIFIER .)
    LTE             reduce using rule 37 (literal -> IDENTIFIER .)
    IS              reduce using rule 37 (literal -> IDENTIFIER .)
    GT              reduce using rule 37 (literal -> IDENTIFIER .)
    LT              reduce using rule 37 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 37 (literal -> IDENTIFIER .)
    OR              reduce using rule 37 (literal -> IDENTIFIER .)
    AND             reduce using rule 37 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 37 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 37 (literal -> IDENTIFIER .)


state 15

    (11) expression_statement -> SEMICOLON .

    PUT             reduce using rule 11 (expression_statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 11 (expression_statement -> SEMICOLON .)
    LET             reduce using rule 11 (expression_statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 11 (expression_statement -> SEMICOLON .)
    DO              reduce using rule 11 (expression_statement -> SEMICOLON .)
    FOR             reduce using rule 11 (expression_statement -> SEMICOLON .)
    WHILE           reduce using rule 11 (expression_statement -> SEMICOLON .)
    IF              reduce using rule 11 (expression_statement -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 11 (expression_statement -> SEMICOLON .)
    LOG             reduce using rule 11 (expression_statement -> SEMICOLON .)
    FUNCTION        reduce using rule 11 (expression_statement -> SEMICOLON .)
    TYPE_BOOL       reduce using rule 11 (expression_statement -> SEMICOLON .)
    TYPE_INT        reduce using rule 11 (expression_statement -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 11 (expression_statement -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 11 (expression_statement -> SEMICOLON .)
    TYPE_STRING     reduce using rule 11 (expression_statement -> SEMICOLON .)
    MINUS           reduce using rule 11 (expression_statement -> SEMICOLON .)
    NOT             reduce using rule 11 (expression_statement -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 11 (expression_statement -> SEMICOLON .)
    DOUBLE          reduce using rule 11 (expression_statement -> SEMICOLON .)
    INTEGER         reduce using rule 11 (expression_statement -> SEMICOLON .)
    STRING          reduce using rule 11 (expression_statement -> SEMICOLON .)
    TRUE            reduce using rule 11 (expression_statement -> SEMICOLON .)
    FALSE           reduce using rule 11 (expression_statement -> SEMICOLON .)
    $end            reduce using rule 11 (expression_statement -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 11 (expression_statement -> SEMICOLON .)


state 16

    (42) assignment_statement -> LET . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 59


state 17

    (51) assignment_statement -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 60


state 18

    (20) iterative_statement -> DO . compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 61

state 19

    (22) iterative_statement -> WHILE . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 62


state 20

    (40) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 63
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 21

    (21) iterative_statement -> FOR . LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (36) iterative_statement -> FOR . LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR . expression TO expression compound_statement
    (52) iterative_statement -> FOR . expression TO expression STEP expression compound_statement
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 64
    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 65
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 22

    (9) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (35) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 66


state 23

    (27) compound_statement -> LEFT_BRACE . statement_list RIGHT_BRACE
    (23) statement_list -> . statement statement_list
    (24) statement_list -> .
    (12) statement -> . assignment_statement
    (13) statement -> . expression_statement
    (14) statement -> . iterative_statement
    (15) statement -> . conditional_statement
    (16) statement -> . compound_statement
    (17) statement -> . print_statement
    (18) statement -> . function_statement
    (19) statement -> . function_call
    (8) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (34) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (42) assignment_statement -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (51) assignment_statement -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (10) expression_statement -> . expression SEMICOLON
    (11) expression_statement -> . SEMICOLON
    (20) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (21) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (22) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (36) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR expression TO expression compound_statement
    (52) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (35) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (26) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (38) function_statement -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (7) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (33) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 24 (statement_list -> .)
    PUT             shift and go to state 12
    IDENTIFIER      shift and go to state 14
    LET             shift and go to state 16
    SEMICOLON       shift and go to state 15
    DO              shift and go to state 18
    FOR             shift and go to state 21
    WHILE           shift and go to state 19
    IF              shift and go to state 22
    LEFT_BRACE      shift and go to state 23
    LOG             shift and go to state 24
    FUNCTION        shift and go to state 25
    TYPE_BOOL       shift and go to state 26
    TYPE_INT        shift and go to state 27
    TYPE_CHAR       shift and go to state 28
    TYPE_DOUBLE     shift and go to state 29
    TYPE_STRING     shift and go to state 30
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    statement_list                 shift and go to state 67
    statement                      shift and go to state 3
    assignment_statement           shift and go to state 4
    expression_statement           shift and go to state 5
    iterative_statement            shift and go to state 6
    conditional_statement          shift and go to state 7
    compound_statement             shift and go to state 8
    print_statement                shift and go to state 9
    function_statement             shift and go to state 10
    function_call                  shift and go to state 11
    expression                     shift and go to state 13
    type_specifier                 shift and go to state 17
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 24

    (25) print_statement -> LOG . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 68


state 25

    (26) function_statement -> FUNCTION . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (38) function_statement -> FUNCTION . IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement

    IDENTIFIER      shift and go to state 69


state 26

    (1) type_specifier -> TYPE_BOOL .

    IDENTIFIER      reduce using rule 1 (type_specifier -> TYPE_BOOL .)


state 27

    (2) type_specifier -> TYPE_INT .

    IDENTIFIER      reduce using rule 2 (type_specifier -> TYPE_INT .)


state 28

    (3) type_specifier -> TYPE_CHAR .

    IDENTIFIER      reduce using rule 3 (type_specifier -> TYPE_CHAR .)


state 29

    (4) type_specifier -> TYPE_DOUBLE .

    IDENTIFIER      reduce using rule 4 (type_specifier -> TYPE_DOUBLE .)


state 30

    (5) type_specifier -> TYPE_STRING .

    IDENTIFIER      reduce using rule 5 (type_specifier -> TYPE_STRING .)


state 31

    (49) expression -> MINUS . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 70
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 32

    (66) expression -> term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 66 (expression -> term .)
    GTE             reduce using rule 66 (expression -> term .)
    LTE             reduce using rule 66 (expression -> term .)
    IS              reduce using rule 66 (expression -> term .)
    GT              reduce using rule 66 (expression -> term .)
    LT              reduce using rule 66 (expression -> term .)
    EQUALS          reduce using rule 66 (expression -> term .)
    OR              reduce using rule 66 (expression -> term .)
    AND             reduce using rule 66 (expression -> term .)
    PLUS            reduce using rule 66 (expression -> term .)
    MINUS           reduce using rule 66 (expression -> term .)
    IN              reduce using rule 66 (expression -> term .)
    RIGHT_PAREN     reduce using rule 66 (expression -> term .)
    TO              reduce using rule 66 (expression -> term .)
    COMMA           reduce using rule 66 (expression -> term .)
    STEP            reduce using rule 66 (expression -> term .)
    LEFT_BRACE      reduce using rule 66 (expression -> term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 33

    (53) expression -> NOT . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 74
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 34

    (50) term -> factor .

    PRODUCT         reduce using rule 50 (term -> factor .)
    DIVIDE          reduce using rule 50 (term -> factor .)
    SEMICOLON       reduce using rule 50 (term -> factor .)
    GTE             reduce using rule 50 (term -> factor .)
    LTE             reduce using rule 50 (term -> factor .)
    IS              reduce using rule 50 (term -> factor .)
    GT              reduce using rule 50 (term -> factor .)
    LT              reduce using rule 50 (term -> factor .)
    EQUALS          reduce using rule 50 (term -> factor .)
    OR              reduce using rule 50 (term -> factor .)
    AND             reduce using rule 50 (term -> factor .)
    PLUS            reduce using rule 50 (term -> factor .)
    MINUS           reduce using rule 50 (term -> factor .)
    IN              reduce using rule 50 (term -> factor .)
    RIGHT_PAREN     reduce using rule 50 (term -> factor .)
    TO              reduce using rule 50 (term -> factor .)
    COMMA           reduce using rule 50 (term -> factor .)
    STEP            reduce using rule 50 (term -> factor .)
    LEFT_BRACE      reduce using rule 50 (term -> factor .)


state 35

    (30) factor -> literal .

    PRODUCT         reduce using rule 30 (factor -> literal .)
    DIVIDE          reduce using rule 30 (factor -> literal .)
    SEMICOLON       reduce using rule 30 (factor -> literal .)
    GTE             reduce using rule 30 (factor -> literal .)
    LTE             reduce using rule 30 (factor -> literal .)
    IS              reduce using rule 30 (factor -> literal .)
    GT              reduce using rule 30 (factor -> literal .)
    LT              reduce using rule 30 (factor -> literal .)
    EQUALS          reduce using rule 30 (factor -> literal .)
    OR              reduce using rule 30 (factor -> literal .)
    AND             reduce using rule 30 (factor -> literal .)
    PLUS            reduce using rule 30 (factor -> literal .)
    MINUS           reduce using rule 30 (factor -> literal .)
    IN              reduce using rule 30 (factor -> literal .)
    RIGHT_PAREN     reduce using rule 30 (factor -> literal .)
    TO              reduce using rule 30 (factor -> literal .)
    COMMA           reduce using rule 30 (factor -> literal .)
    STEP            reduce using rule 30 (factor -> literal .)
    LEFT_BRACE      reduce using rule 30 (factor -> literal .)


state 36

    (44) literal -> DOUBLE .

    PRODUCT         reduce using rule 44 (literal -> DOUBLE .)
    DIVIDE          reduce using rule 44 (literal -> DOUBLE .)
    SEMICOLON       reduce using rule 44 (literal -> DOUBLE .)
    GTE             reduce using rule 44 (literal -> DOUBLE .)
    LTE             reduce using rule 44 (literal -> DOUBLE .)
    IS              reduce using rule 44 (literal -> DOUBLE .)
    GT              reduce using rule 44 (literal -> DOUBLE .)
    LT              reduce using rule 44 (literal -> DOUBLE .)
    EQUALS          reduce using rule 44 (literal -> DOUBLE .)
    OR              reduce using rule 44 (literal -> DOUBLE .)
    AND             reduce using rule 44 (literal -> DOUBLE .)
    PLUS            reduce using rule 44 (literal -> DOUBLE .)
    MINUS           reduce using rule 44 (literal -> DOUBLE .)
    IN              reduce using rule 44 (literal -> DOUBLE .)
    RIGHT_PAREN     reduce using rule 44 (literal -> DOUBLE .)
    TO              reduce using rule 44 (literal -> DOUBLE .)
    COMMA           reduce using rule 44 (literal -> DOUBLE .)
    STEP            reduce using rule 44 (literal -> DOUBLE .)
    LEFT_BRACE      reduce using rule 44 (literal -> DOUBLE .)


state 37

    (45) literal -> INTEGER .

    PRODUCT         reduce using rule 45 (literal -> INTEGER .)
    DIVIDE          reduce using rule 45 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 45 (literal -> INTEGER .)
    GTE             reduce using rule 45 (literal -> INTEGER .)
    LTE             reduce using rule 45 (literal -> INTEGER .)
    IS              reduce using rule 45 (literal -> INTEGER .)
    GT              reduce using rule 45 (literal -> INTEGER .)
    LT              reduce using rule 45 (literal -> INTEGER .)
    EQUALS          reduce using rule 45 (literal -> INTEGER .)
    OR              reduce using rule 45 (literal -> INTEGER .)
    AND             reduce using rule 45 (literal -> INTEGER .)
    PLUS            reduce using rule 45 (literal -> INTEGER .)
    MINUS           reduce using rule 45 (literal -> INTEGER .)
    IN              reduce using rule 45 (literal -> INTEGER .)
    RIGHT_PAREN     reduce using rule 45 (literal -> INTEGER .)
    TO              reduce using rule 45 (literal -> INTEGER .)
    COMMA           reduce using rule 45 (literal -> INTEGER .)
    STEP            reduce using rule 45 (literal -> INTEGER .)
    LEFT_BRACE      reduce using rule 45 (literal -> INTEGER .)


state 38

    (46) literal -> STRING .

    PRODUCT         reduce using rule 46 (literal -> STRING .)
    DIVIDE          reduce using rule 46 (literal -> STRING .)
    SEMICOLON       reduce using rule 46 (literal -> STRING .)
    GTE             reduce using rule 46 (literal -> STRING .)
    LTE             reduce using rule 46 (literal -> STRING .)
    IS              reduce using rule 46 (literal -> STRING .)
    GT              reduce using rule 46 (literal -> STRING .)
    LT              reduce using rule 46 (literal -> STRING .)
    EQUALS          reduce using rule 46 (literal -> STRING .)
    OR              reduce using rule 46 (literal -> STRING .)
    AND             reduce using rule 46 (literal -> STRING .)
    PLUS            reduce using rule 46 (literal -> STRING .)
    MINUS           reduce using rule 46 (literal -> STRING .)
    IN              reduce using rule 46 (literal -> STRING .)
    RIGHT_PAREN     reduce using rule 46 (literal -> STRING .)
    TO              reduce using rule 46 (literal -> STRING .)
    COMMA           reduce using rule 46 (literal -> STRING .)
    STEP            reduce using rule 46 (literal -> STRING .)
    LEFT_BRACE      reduce using rule 46 (literal -> STRING .)


state 39

    (47) literal -> TRUE .

    PRODUCT         reduce using rule 47 (literal -> TRUE .)
    DIVIDE          reduce using rule 47 (literal -> TRUE .)
    SEMICOLON       reduce using rule 47 (literal -> TRUE .)
    GTE             reduce using rule 47 (literal -> TRUE .)
    LTE             reduce using rule 47 (literal -> TRUE .)
    IS              reduce using rule 47 (literal -> TRUE .)
    GT              reduce using rule 47 (literal -> TRUE .)
    LT              reduce using rule 47 (literal -> TRUE .)
    EQUALS          reduce using rule 47 (literal -> TRUE .)
    OR              reduce using rule 47 (literal -> TRUE .)
    AND             reduce using rule 47 (literal -> TRUE .)
    PLUS            reduce using rule 47 (literal -> TRUE .)
    MINUS           reduce using rule 47 (literal -> TRUE .)
    IN              reduce using rule 47 (literal -> TRUE .)
    RIGHT_PAREN     reduce using rule 47 (literal -> TRUE .)
    TO              reduce using rule 47 (literal -> TRUE .)
    COMMA           reduce using rule 47 (literal -> TRUE .)
    STEP            reduce using rule 47 (literal -> TRUE .)
    LEFT_BRACE      reduce using rule 47 (literal -> TRUE .)


state 40

    (48) literal -> FALSE .

    PRODUCT         reduce using rule 48 (literal -> FALSE .)
    DIVIDE          reduce using rule 48 (literal -> FALSE .)
    SEMICOLON       reduce using rule 48 (literal -> FALSE .)
    GTE             reduce using rule 48 (literal -> FALSE .)
    LTE             reduce using rule 48 (literal -> FALSE .)
    IS              reduce using rule 48 (literal -> FALSE .)
    GT              reduce using rule 48 (literal -> FALSE .)
    LT              reduce using rule 48 (literal -> FALSE .)
    EQUALS          reduce using rule 48 (literal -> FALSE .)
    OR              reduce using rule 48 (literal -> FALSE .)
    AND             reduce using rule 48 (literal -> FALSE .)
    PLUS            reduce using rule 48 (literal -> FALSE .)
    MINUS           reduce using rule 48 (literal -> FALSE .)
    IN              reduce using rule 48 (literal -> FALSE .)
    RIGHT_PAREN     reduce using rule 48 (literal -> FALSE .)
    TO              reduce using rule 48 (literal -> FALSE .)
    COMMA           reduce using rule 48 (literal -> FALSE .)
    STEP            reduce using rule 48 (literal -> FALSE .)
    LEFT_BRACE      reduce using rule 48 (literal -> FALSE .)


state 41

    (23) statement_list -> statement statement_list .

    $end            reduce using rule 23 (statement_list -> statement statement_list .)
    RIGHT_BRACE     reduce using rule 23 (statement_list -> statement statement_list .)


state 42

    (8) assignment_statement -> PUT expression . IN IDENTIFIER SEMICOLON
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    IN              shift and go to state 75
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 43

    (29) expression -> IDENTIFIER . INCREMENT
    (39) expression -> IDENTIFIER . DECREMENT
    (37) literal -> IDENTIFIER .

    INCREMENT       shift and go to state 57
    DECREMENT       shift and go to state 58
    PRODUCT         reduce using rule 37 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 37 (literal -> IDENTIFIER .)
    IN              reduce using rule 37 (literal -> IDENTIFIER .)
    GTE             reduce using rule 37 (literal -> IDENTIFIER .)
    LTE             reduce using rule 37 (literal -> IDENTIFIER .)
    IS              reduce using rule 37 (literal -> IDENTIFIER .)
    GT              reduce using rule 37 (literal -> IDENTIFIER .)
    LT              reduce using rule 37 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 37 (literal -> IDENTIFIER .)
    OR              reduce using rule 37 (literal -> IDENTIFIER .)
    AND             reduce using rule 37 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 37 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 37 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 37 (literal -> IDENTIFIER .)
    TO              reduce using rule 37 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 37 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 37 (literal -> IDENTIFIER .)
    STEP            reduce using rule 37 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 37 (literal -> IDENTIFIER .)


state 44

    (10) expression_statement -> expression SEMICOLON .

    PUT             reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    LET             reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    DO              reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    LOG             reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    FUNCTION        reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    TYPE_STRING     reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    STRING          reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    TRUE            reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    FALSE           reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    $end            reduce using rule 10 (expression_statement -> expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 10 (expression_statement -> expression SEMICOLON .)


state 45

    (54) expression -> expression GTE . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 76
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 46

    (55) expression -> expression LTE . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 77
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 47

    (56) expression -> expression IS . GREATER THAN term
    (57) expression -> expression IS . LESS THAN term
    (60) expression -> expression IS . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    GREATER         shift and go to state 78
    LESS            shift and go to state 80
    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 79
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 48

    (58) expression -> expression GT . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 81
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 49

    (59) expression -> expression LT . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 82
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 50

    (61) expression -> expression EQUALS . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 83
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 51

    (62) expression -> expression OR . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 84
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 52

    (63) expression -> expression AND . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 85
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 53

    (64) expression -> expression PLUS . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 86
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 54

    (65) expression -> expression MINUS . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 87
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 55

    (34) assignment_statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 88
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 56

    (7) function_call -> IDENTIFIER LEFT_PAREN . RIGHT_PAREN SEMICOLON
    (33) function_call -> IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (6) arguments -> . expression COMMA arguments
    (32) arguments -> . expression
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 89
    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    arguments                      shift and go to state 90
    expression                     shift and go to state 91
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 57

    (29) expression -> IDENTIFIER INCREMENT .

    SEMICOLON       reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    GTE             reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    LTE             reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    IS              reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    GT              reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    LT              reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    EQUALS          reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    OR              reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    AND             reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    PLUS            reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    MINUS           reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    IN              reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    RIGHT_PAREN     reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    TO              reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    COMMA           reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    STEP            reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)
    LEFT_BRACE      reduce using rule 29 (expression -> IDENTIFIER INCREMENT .)


state 58

    (39) expression -> IDENTIFIER DECREMENT .

    SEMICOLON       reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    GTE             reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    LTE             reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    IS              reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    GT              reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    LT              reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    EQUALS          reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    OR              reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    AND             reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    PLUS            reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    MINUS           reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    IN              reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    RIGHT_PAREN     reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    TO              reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    COMMA           reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    STEP            reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)
    LEFT_BRACE      reduce using rule 39 (expression -> IDENTIFIER DECREMENT .)


state 59

    (42) assignment_statement -> LET IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 92


state 60

    (51) assignment_statement -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 93


state 61

    (20) iterative_statement -> DO compound_statement . WHILE LEFT_PAREN expression RIGHT_PAREN

    WHILE           shift and go to state 94


state 62

    (22) iterative_statement -> WHILE LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 95
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 63

    (40) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 96
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 64

    (21) iterative_statement -> FOR LEFT_PAREN . expression TO expression RIGHT_PAREN compound_statement
    (36) iterative_statement -> FOR LEFT_PAREN . expression TO expression STEP expression RIGHT_PAREN compound_statement
    (40) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 97
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 65

    (43) iterative_statement -> FOR expression . TO expression compound_statement
    (52) iterative_statement -> FOR expression . TO expression STEP expression compound_statement
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    TO              shift and go to state 98
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 66

    (9) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE compound_statement
    (35) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 99
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 67

    (27) compound_statement -> LEFT_BRACE statement_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 100


state 68

    (25) print_statement -> LOG LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (6) arguments -> . expression COMMA arguments
    (32) arguments -> . expression
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    arguments                      shift and go to state 101
    expression                     shift and go to state 91
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 69

    (26) function_statement -> FUNCTION IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (38) function_statement -> FUNCTION IDENTIFIER . LEFT_PAREN RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 102


state 70

    (49) expression -> MINUS term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 49 (expression -> MINUS term .)
    GTE             reduce using rule 49 (expression -> MINUS term .)
    LTE             reduce using rule 49 (expression -> MINUS term .)
    IS              reduce using rule 49 (expression -> MINUS term .)
    GT              reduce using rule 49 (expression -> MINUS term .)
    LT              reduce using rule 49 (expression -> MINUS term .)
    EQUALS          reduce using rule 49 (expression -> MINUS term .)
    OR              reduce using rule 49 (expression -> MINUS term .)
    AND             reduce using rule 49 (expression -> MINUS term .)
    PLUS            reduce using rule 49 (expression -> MINUS term .)
    MINUS           reduce using rule 49 (expression -> MINUS term .)
    IN              reduce using rule 49 (expression -> MINUS term .)
    RIGHT_PAREN     reduce using rule 49 (expression -> MINUS term .)
    TO              reduce using rule 49 (expression -> MINUS term .)
    COMMA           reduce using rule 49 (expression -> MINUS term .)
    STEP            reduce using rule 49 (expression -> MINUS term .)
    LEFT_BRACE      reduce using rule 49 (expression -> MINUS term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 71

    (37) literal -> IDENTIFIER .

    PRODUCT         reduce using rule 37 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 37 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 37 (literal -> IDENTIFIER .)
    GTE             reduce using rule 37 (literal -> IDENTIFIER .)
    LTE             reduce using rule 37 (literal -> IDENTIFIER .)
    IS              reduce using rule 37 (literal -> IDENTIFIER .)
    GT              reduce using rule 37 (literal -> IDENTIFIER .)
    LT              reduce using rule 37 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 37 (literal -> IDENTIFIER .)
    OR              reduce using rule 37 (literal -> IDENTIFIER .)
    AND             reduce using rule 37 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 37 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 37 (literal -> IDENTIFIER .)
    IN              reduce using rule 37 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 37 (literal -> IDENTIFIER .)
    TO              reduce using rule 37 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 37 (literal -> IDENTIFIER .)
    STEP            reduce using rule 37 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 37 (literal -> IDENTIFIER .)


state 72

    (31) term -> term PRODUCT . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    factor                         shift and go to state 103
    literal                        shift and go to state 35

state 73

    (41) term -> term DIVIDE . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    factor                         shift and go to state 104
    literal                        shift and go to state 35

state 74

    (53) expression -> NOT term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 53 (expression -> NOT term .)
    GTE             reduce using rule 53 (expression -> NOT term .)
    LTE             reduce using rule 53 (expression -> NOT term .)
    IS              reduce using rule 53 (expression -> NOT term .)
    GT              reduce using rule 53 (expression -> NOT term .)
    LT              reduce using rule 53 (expression -> NOT term .)
    EQUALS          reduce using rule 53 (expression -> NOT term .)
    OR              reduce using rule 53 (expression -> NOT term .)
    AND             reduce using rule 53 (expression -> NOT term .)
    PLUS            reduce using rule 53 (expression -> NOT term .)
    MINUS           reduce using rule 53 (expression -> NOT term .)
    IN              reduce using rule 53 (expression -> NOT term .)
    RIGHT_PAREN     reduce using rule 53 (expression -> NOT term .)
    TO              reduce using rule 53 (expression -> NOT term .)
    COMMA           reduce using rule 53 (expression -> NOT term .)
    STEP            reduce using rule 53 (expression -> NOT term .)
    LEFT_BRACE      reduce using rule 53 (expression -> NOT term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 75

    (8) assignment_statement -> PUT expression IN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 105


state 76

    (54) expression -> expression GTE term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 54 (expression -> expression GTE term .)
    GTE             reduce using rule 54 (expression -> expression GTE term .)
    LTE             reduce using rule 54 (expression -> expression GTE term .)
    IS              reduce using rule 54 (expression -> expression GTE term .)
    GT              reduce using rule 54 (expression -> expression GTE term .)
    LT              reduce using rule 54 (expression -> expression GTE term .)
    EQUALS          reduce using rule 54 (expression -> expression GTE term .)
    OR              reduce using rule 54 (expression -> expression GTE term .)
    AND             reduce using rule 54 (expression -> expression GTE term .)
    PLUS            reduce using rule 54 (expression -> expression GTE term .)
    MINUS           reduce using rule 54 (expression -> expression GTE term .)
    IN              reduce using rule 54 (expression -> expression GTE term .)
    RIGHT_PAREN     reduce using rule 54 (expression -> expression GTE term .)
    TO              reduce using rule 54 (expression -> expression GTE term .)
    COMMA           reduce using rule 54 (expression -> expression GTE term .)
    STEP            reduce using rule 54 (expression -> expression GTE term .)
    LEFT_BRACE      reduce using rule 54 (expression -> expression GTE term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 77

    (55) expression -> expression LTE term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 55 (expression -> expression LTE term .)
    GTE             reduce using rule 55 (expression -> expression LTE term .)
    LTE             reduce using rule 55 (expression -> expression LTE term .)
    IS              reduce using rule 55 (expression -> expression LTE term .)
    GT              reduce using rule 55 (expression -> expression LTE term .)
    LT              reduce using rule 55 (expression -> expression LTE term .)
    EQUALS          reduce using rule 55 (expression -> expression LTE term .)
    OR              reduce using rule 55 (expression -> expression LTE term .)
    AND             reduce using rule 55 (expression -> expression LTE term .)
    PLUS            reduce using rule 55 (expression -> expression LTE term .)
    MINUS           reduce using rule 55 (expression -> expression LTE term .)
    IN              reduce using rule 55 (expression -> expression LTE term .)
    RIGHT_PAREN     reduce using rule 55 (expression -> expression LTE term .)
    TO              reduce using rule 55 (expression -> expression LTE term .)
    COMMA           reduce using rule 55 (expression -> expression LTE term .)
    STEP            reduce using rule 55 (expression -> expression LTE term .)
    LEFT_BRACE      reduce using rule 55 (expression -> expression LTE term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 78

    (56) expression -> expression IS GREATER . THAN term

    THAN            shift and go to state 106


state 79

    (60) expression -> expression IS term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 60 (expression -> expression IS term .)
    GTE             reduce using rule 60 (expression -> expression IS term .)
    LTE             reduce using rule 60 (expression -> expression IS term .)
    IS              reduce using rule 60 (expression -> expression IS term .)
    GT              reduce using rule 60 (expression -> expression IS term .)
    LT              reduce using rule 60 (expression -> expression IS term .)
    EQUALS          reduce using rule 60 (expression -> expression IS term .)
    OR              reduce using rule 60 (expression -> expression IS term .)
    AND             reduce using rule 60 (expression -> expression IS term .)
    PLUS            reduce using rule 60 (expression -> expression IS term .)
    MINUS           reduce using rule 60 (expression -> expression IS term .)
    IN              reduce using rule 60 (expression -> expression IS term .)
    RIGHT_PAREN     reduce using rule 60 (expression -> expression IS term .)
    TO              reduce using rule 60 (expression -> expression IS term .)
    COMMA           reduce using rule 60 (expression -> expression IS term .)
    STEP            reduce using rule 60 (expression -> expression IS term .)
    LEFT_BRACE      reduce using rule 60 (expression -> expression IS term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 80

    (57) expression -> expression IS LESS . THAN term

    THAN            shift and go to state 107


state 81

    (58) expression -> expression GT term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 58 (expression -> expression GT term .)
    GTE             reduce using rule 58 (expression -> expression GT term .)
    LTE             reduce using rule 58 (expression -> expression GT term .)
    IS              reduce using rule 58 (expression -> expression GT term .)
    GT              reduce using rule 58 (expression -> expression GT term .)
    LT              reduce using rule 58 (expression -> expression GT term .)
    EQUALS          reduce using rule 58 (expression -> expression GT term .)
    OR              reduce using rule 58 (expression -> expression GT term .)
    AND             reduce using rule 58 (expression -> expression GT term .)
    PLUS            reduce using rule 58 (expression -> expression GT term .)
    MINUS           reduce using rule 58 (expression -> expression GT term .)
    IN              reduce using rule 58 (expression -> expression GT term .)
    RIGHT_PAREN     reduce using rule 58 (expression -> expression GT term .)
    TO              reduce using rule 58 (expression -> expression GT term .)
    COMMA           reduce using rule 58 (expression -> expression GT term .)
    STEP            reduce using rule 58 (expression -> expression GT term .)
    LEFT_BRACE      reduce using rule 58 (expression -> expression GT term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 82

    (59) expression -> expression LT term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 59 (expression -> expression LT term .)
    GTE             reduce using rule 59 (expression -> expression LT term .)
    LTE             reduce using rule 59 (expression -> expression LT term .)
    IS              reduce using rule 59 (expression -> expression LT term .)
    GT              reduce using rule 59 (expression -> expression LT term .)
    LT              reduce using rule 59 (expression -> expression LT term .)
    EQUALS          reduce using rule 59 (expression -> expression LT term .)
    OR              reduce using rule 59 (expression -> expression LT term .)
    AND             reduce using rule 59 (expression -> expression LT term .)
    PLUS            reduce using rule 59 (expression -> expression LT term .)
    MINUS           reduce using rule 59 (expression -> expression LT term .)
    IN              reduce using rule 59 (expression -> expression LT term .)
    RIGHT_PAREN     reduce using rule 59 (expression -> expression LT term .)
    TO              reduce using rule 59 (expression -> expression LT term .)
    COMMA           reduce using rule 59 (expression -> expression LT term .)
    STEP            reduce using rule 59 (expression -> expression LT term .)
    LEFT_BRACE      reduce using rule 59 (expression -> expression LT term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 83

    (61) expression -> expression EQUALS term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 61 (expression -> expression EQUALS term .)
    GTE             reduce using rule 61 (expression -> expression EQUALS term .)
    LTE             reduce using rule 61 (expression -> expression EQUALS term .)
    IS              reduce using rule 61 (expression -> expression EQUALS term .)
    GT              reduce using rule 61 (expression -> expression EQUALS term .)
    LT              reduce using rule 61 (expression -> expression EQUALS term .)
    EQUALS          reduce using rule 61 (expression -> expression EQUALS term .)
    OR              reduce using rule 61 (expression -> expression EQUALS term .)
    AND             reduce using rule 61 (expression -> expression EQUALS term .)
    PLUS            reduce using rule 61 (expression -> expression EQUALS term .)
    MINUS           reduce using rule 61 (expression -> expression EQUALS term .)
    IN              reduce using rule 61 (expression -> expression EQUALS term .)
    RIGHT_PAREN     reduce using rule 61 (expression -> expression EQUALS term .)
    TO              reduce using rule 61 (expression -> expression EQUALS term .)
    COMMA           reduce using rule 61 (expression -> expression EQUALS term .)
    STEP            reduce using rule 61 (expression -> expression EQUALS term .)
    LEFT_BRACE      reduce using rule 61 (expression -> expression EQUALS term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 84

    (62) expression -> expression OR term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 62 (expression -> expression OR term .)
    GTE             reduce using rule 62 (expression -> expression OR term .)
    LTE             reduce using rule 62 (expression -> expression OR term .)
    IS              reduce using rule 62 (expression -> expression OR term .)
    GT              reduce using rule 62 (expression -> expression OR term .)
    LT              reduce using rule 62 (expression -> expression OR term .)
    EQUALS          reduce using rule 62 (expression -> expression OR term .)
    OR              reduce using rule 62 (expression -> expression OR term .)
    AND             reduce using rule 62 (expression -> expression OR term .)
    PLUS            reduce using rule 62 (expression -> expression OR term .)
    MINUS           reduce using rule 62 (expression -> expression OR term .)
    IN              reduce using rule 62 (expression -> expression OR term .)
    RIGHT_PAREN     reduce using rule 62 (expression -> expression OR term .)
    TO              reduce using rule 62 (expression -> expression OR term .)
    COMMA           reduce using rule 62 (expression -> expression OR term .)
    STEP            reduce using rule 62 (expression -> expression OR term .)
    LEFT_BRACE      reduce using rule 62 (expression -> expression OR term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 85

    (63) expression -> expression AND term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 63 (expression -> expression AND term .)
    GTE             reduce using rule 63 (expression -> expression AND term .)
    LTE             reduce using rule 63 (expression -> expression AND term .)
    IS              reduce using rule 63 (expression -> expression AND term .)
    GT              reduce using rule 63 (expression -> expression AND term .)
    LT              reduce using rule 63 (expression -> expression AND term .)
    EQUALS          reduce using rule 63 (expression -> expression AND term .)
    OR              reduce using rule 63 (expression -> expression AND term .)
    AND             reduce using rule 63 (expression -> expression AND term .)
    PLUS            reduce using rule 63 (expression -> expression AND term .)
    MINUS           reduce using rule 63 (expression -> expression AND term .)
    IN              reduce using rule 63 (expression -> expression AND term .)
    RIGHT_PAREN     reduce using rule 63 (expression -> expression AND term .)
    TO              reduce using rule 63 (expression -> expression AND term .)
    COMMA           reduce using rule 63 (expression -> expression AND term .)
    STEP            reduce using rule 63 (expression -> expression AND term .)
    LEFT_BRACE      reduce using rule 63 (expression -> expression AND term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 86

    (64) expression -> expression PLUS term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 64 (expression -> expression PLUS term .)
    GTE             reduce using rule 64 (expression -> expression PLUS term .)
    LTE             reduce using rule 64 (expression -> expression PLUS term .)
    IS              reduce using rule 64 (expression -> expression PLUS term .)
    GT              reduce using rule 64 (expression -> expression PLUS term .)
    LT              reduce using rule 64 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 64 (expression -> expression PLUS term .)
    OR              reduce using rule 64 (expression -> expression PLUS term .)
    AND             reduce using rule 64 (expression -> expression PLUS term .)
    PLUS            reduce using rule 64 (expression -> expression PLUS term .)
    MINUS           reduce using rule 64 (expression -> expression PLUS term .)
    IN              reduce using rule 64 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 64 (expression -> expression PLUS term .)
    TO              reduce using rule 64 (expression -> expression PLUS term .)
    COMMA           reduce using rule 64 (expression -> expression PLUS term .)
    STEP            reduce using rule 64 (expression -> expression PLUS term .)
    LEFT_BRACE      reduce using rule 64 (expression -> expression PLUS term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 87

    (65) expression -> expression MINUS term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 65 (expression -> expression MINUS term .)
    GTE             reduce using rule 65 (expression -> expression MINUS term .)
    LTE             reduce using rule 65 (expression -> expression MINUS term .)
    IS              reduce using rule 65 (expression -> expression MINUS term .)
    GT              reduce using rule 65 (expression -> expression MINUS term .)
    LT              reduce using rule 65 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 65 (expression -> expression MINUS term .)
    OR              reduce using rule 65 (expression -> expression MINUS term .)
    AND             reduce using rule 65 (expression -> expression MINUS term .)
    PLUS            reduce using rule 65 (expression -> expression MINUS term .)
    MINUS           reduce using rule 65 (expression -> expression MINUS term .)
    IN              reduce using rule 65 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 65 (expression -> expression MINUS term .)
    TO              reduce using rule 65 (expression -> expression MINUS term .)
    COMMA           reduce using rule 65 (expression -> expression MINUS term .)
    STEP            reduce using rule 65 (expression -> expression MINUS term .)
    LEFT_BRACE      reduce using rule 65 (expression -> expression MINUS term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 88

    (34) assignment_statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 108
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 89

    (7) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 109


state 90

    (33) function_call -> IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 110


state 91

    (6) arguments -> expression . COMMA arguments
    (32) arguments -> expression .
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    COMMA           shift and go to state 111
    RIGHT_PAREN     reduce using rule 32 (arguments -> expression .)
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 92

    (42) assignment_statement -> LET IDENTIFIER ASSIGN . expression SEMICOLON
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 112
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 93

    (51) assignment_statement -> type_specifier IDENTIFIER ASSIGN . expression SEMICOLON
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 113
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 94

    (20) iterative_statement -> DO compound_statement WHILE . LEFT_PAREN expression RIGHT_PAREN

    LEFT_PAREN      shift and go to state 114


state 95

    (22) iterative_statement -> WHILE LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 115
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 96

    (40) factor -> LEFT_PAREN expression RIGHT_PAREN .

    PRODUCT         reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GTE             reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LTE             reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IS              reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GT              reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LT              reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IN              reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TO              reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    STEP            reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 40 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 97

    (21) iterative_statement -> FOR LEFT_PAREN expression . TO expression RIGHT_PAREN compound_statement
    (36) iterative_statement -> FOR LEFT_PAREN expression . TO expression STEP expression RIGHT_PAREN compound_statement
    (40) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    TO              shift and go to state 116
    RIGHT_PAREN     shift and go to state 96
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 98

    (43) iterative_statement -> FOR expression TO . expression compound_statement
    (52) iterative_statement -> FOR expression TO . expression STEP expression compound_statement
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 117
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 99

    (9) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE compound_statement
    (35) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 118
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 100

    (27) compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .

    PUT             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LET             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DO              reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FOR             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    WHILE           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IF              reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LOG             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FUNCTION        reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_BOOL       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_INT        reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_CHAR       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_DOUBLE     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_STRING     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    MINUS           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    NOT             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    INTEGER         reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRING          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TRUE            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FALSE           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    $end            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    ELSE            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)


state 101

    (25) print_statement -> LOG LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 119


state 102

    (26) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN compound_statement
    (38) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN . RIGHT_PAREN compound_statement
    (6) arguments -> . expression COMMA arguments
    (32) arguments -> . expression
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 121
    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    arguments                      shift and go to state 120
    expression                     shift and go to state 91
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 103

    (31) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 31 (term -> term PRODUCT factor .)
    DIVIDE          reduce using rule 31 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 31 (term -> term PRODUCT factor .)
    GTE             reduce using rule 31 (term -> term PRODUCT factor .)
    LTE             reduce using rule 31 (term -> term PRODUCT factor .)
    IS              reduce using rule 31 (term -> term PRODUCT factor .)
    GT              reduce using rule 31 (term -> term PRODUCT factor .)
    LT              reduce using rule 31 (term -> term PRODUCT factor .)
    EQUALS          reduce using rule 31 (term -> term PRODUCT factor .)
    OR              reduce using rule 31 (term -> term PRODUCT factor .)
    AND             reduce using rule 31 (term -> term PRODUCT factor .)
    PLUS            reduce using rule 31 (term -> term PRODUCT factor .)
    MINUS           reduce using rule 31 (term -> term PRODUCT factor .)
    IN              reduce using rule 31 (term -> term PRODUCT factor .)
    RIGHT_PAREN     reduce using rule 31 (term -> term PRODUCT factor .)
    TO              reduce using rule 31 (term -> term PRODUCT factor .)
    COMMA           reduce using rule 31 (term -> term PRODUCT factor .)
    STEP            reduce using rule 31 (term -> term PRODUCT factor .)
    LEFT_BRACE      reduce using rule 31 (term -> term PRODUCT factor .)


state 104

    (41) term -> term DIVIDE factor .

    PRODUCT         reduce using rule 41 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 41 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 41 (term -> term DIVIDE factor .)
    GTE             reduce using rule 41 (term -> term DIVIDE factor .)
    LTE             reduce using rule 41 (term -> term DIVIDE factor .)
    IS              reduce using rule 41 (term -> term DIVIDE factor .)
    GT              reduce using rule 41 (term -> term DIVIDE factor .)
    LT              reduce using rule 41 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 41 (term -> term DIVIDE factor .)
    OR              reduce using rule 41 (term -> term DIVIDE factor .)
    AND             reduce using rule 41 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 41 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 41 (term -> term DIVIDE factor .)
    IN              reduce using rule 41 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 41 (term -> term DIVIDE factor .)
    TO              reduce using rule 41 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 41 (term -> term DIVIDE factor .)
    STEP            reduce using rule 41 (term -> term DIVIDE factor .)
    LEFT_BRACE      reduce using rule 41 (term -> term DIVIDE factor .)


state 105

    (8) assignment_statement -> PUT expression IN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 122


state 106

    (56) expression -> expression IS GREATER THAN . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 123
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 107

    (57) expression -> expression IS LESS THAN . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    LEFT_PAREN      shift and go to state 20
    IDENTIFIER      shift and go to state 71
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    term                           shift and go to state 124
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 108

    (34) assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    PUT             reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FUNCTION        reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 34 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 109

    (7) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .

    PUT             reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FUNCTION        reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 7 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)


state 110

    (33) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 125


state 111

    (6) arguments -> expression COMMA . arguments
    (6) arguments -> . expression COMMA arguments
    (32) arguments -> . expression
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 91
    arguments                      shift and go to state 126
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 112

    (42) assignment_statement -> LET IDENTIFIER ASSIGN expression . SEMICOLON
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 127
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 113

    (51) assignment_statement -> type_specifier IDENTIFIER ASSIGN expression . SEMICOLON
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 128
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 114

    (20) iterative_statement -> DO compound_statement WHILE LEFT_PAREN . expression RIGHT_PAREN
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 129
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 115

    (22) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 130

state 116

    (21) iterative_statement -> FOR LEFT_PAREN expression TO . expression RIGHT_PAREN compound_statement
    (36) iterative_statement -> FOR LEFT_PAREN expression TO . expression STEP expression RIGHT_PAREN compound_statement
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 131
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 117

    (43) iterative_statement -> FOR expression TO expression . compound_statement
    (52) iterative_statement -> FOR expression TO expression . STEP expression compound_statement
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    STEP            shift and go to state 133
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 132

state 118

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE compound_statement
    (35) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 134

state 119

    (25) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 120

    (26) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 136


state 121

    (38) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 137

state 122

    (8) assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .

    PUT             reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LET             reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DO              reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 8 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)


state 123

    (56) expression -> expression IS GREATER THAN term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    GTE             reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    LTE             reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    IS              reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    GT              reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    LT              reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    EQUALS          reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    OR              reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    AND             reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    PLUS            reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    MINUS           reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    IN              reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    RIGHT_PAREN     reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    TO              reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    COMMA           reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    STEP            reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    LEFT_BRACE      reduce using rule 56 (expression -> expression IS GREATER THAN term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 124

    (57) expression -> expression IS LESS THAN term .
    (31) term -> term . PRODUCT factor
    (41) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 57 (expression -> expression IS LESS THAN term .)
    GTE             reduce using rule 57 (expression -> expression IS LESS THAN term .)
    LTE             reduce using rule 57 (expression -> expression IS LESS THAN term .)
    IS              reduce using rule 57 (expression -> expression IS LESS THAN term .)
    GT              reduce using rule 57 (expression -> expression IS LESS THAN term .)
    LT              reduce using rule 57 (expression -> expression IS LESS THAN term .)
    EQUALS          reduce using rule 57 (expression -> expression IS LESS THAN term .)
    OR              reduce using rule 57 (expression -> expression IS LESS THAN term .)
    AND             reduce using rule 57 (expression -> expression IS LESS THAN term .)
    PLUS            reduce using rule 57 (expression -> expression IS LESS THAN term .)
    MINUS           reduce using rule 57 (expression -> expression IS LESS THAN term .)
    IN              reduce using rule 57 (expression -> expression IS LESS THAN term .)
    RIGHT_PAREN     reduce using rule 57 (expression -> expression IS LESS THAN term .)
    TO              reduce using rule 57 (expression -> expression IS LESS THAN term .)
    COMMA           reduce using rule 57 (expression -> expression IS LESS THAN term .)
    STEP            reduce using rule 57 (expression -> expression IS LESS THAN term .)
    LEFT_BRACE      reduce using rule 57 (expression -> expression IS LESS THAN term .)
    PRODUCT         shift and go to state 72
    DIVIDE          shift and go to state 73


state 125

    (33) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    PUT             reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FUNCTION        reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 33 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 126

    (6) arguments -> expression COMMA arguments .

    RIGHT_PAREN     reduce using rule 6 (arguments -> expression COMMA arguments .)


state 127

    (42) assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .

    PUT             reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FUNCTION        reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 42 (assignment_statement -> LET IDENTIFIER ASSIGN expression SEMICOLON .)


state 128

    (51) assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .

    PUT             reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FUNCTION        reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 51 (assignment_statement -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)


state 129

    (20) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression . RIGHT_PAREN
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 138
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 130

    (22) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .

    PUT             reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 22 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 131

    (21) iterative_statement -> FOR LEFT_PAREN expression TO expression . RIGHT_PAREN compound_statement
    (36) iterative_statement -> FOR LEFT_PAREN expression TO expression . STEP expression RIGHT_PAREN compound_statement
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 139
    STEP            shift and go to state 140
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 132

    (43) iterative_statement -> FOR expression TO expression compound_statement .

    PUT             reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    IDENTIFIER      reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    LET             reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    SEMICOLON       reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    DO              reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    FOR             reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    WHILE           reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    IF              reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_BRACE      reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    LOG             reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    FUNCTION        reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_BOOL       reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_INT        reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_CHAR       reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_STRING     reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    MINUS           reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    NOT             reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_PAREN      reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    DOUBLE          reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    INTEGER         reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRING          reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    TRUE            reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    FALSE           reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    $end            reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)
    RIGHT_BRACE     reduce using rule 43 (iterative_statement -> FOR expression TO expression compound_statement .)


state 133

    (52) iterative_statement -> FOR expression TO expression STEP . expression compound_statement
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 141
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 134

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE compound_statement
    (35) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .

    ELSE            shift and go to state 142
    PUT             reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 35 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 135

    (25) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    PUT             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FUNCTION        reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 136

    (26) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 143

state 137

    (38) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .

    PUT             reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LET             reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DO              reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IF              reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    $end            reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 38 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)


state 138

    (20) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .

    PUT             reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IDENTIFIER      reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LET             reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DO              reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FOR             reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    WHILE           reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IF              reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LOG             reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FUNCTION        reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_BOOL       reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_INT        reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_CHAR       reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_DOUBLE     reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_STRING     reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DOUBLE          reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    INTEGER         reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRING          reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TRUE            reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FALSE           reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    $end            reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 20 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)


state 139

    (21) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 144

state 140

    (36) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP . expression RIGHT_PAREN compound_statement
    (29) expression -> . IDENTIFIER INCREMENT
    (39) expression -> . IDENTIFIER DECREMENT
    (49) expression -> . MINUS term
    (53) expression -> . NOT term
    (54) expression -> . expression GTE term
    (55) expression -> . expression LTE term
    (56) expression -> . expression IS GREATER THAN term
    (57) expression -> . expression IS LESS THAN term
    (58) expression -> . expression GT term
    (59) expression -> . expression LT term
    (60) expression -> . expression IS term
    (61) expression -> . expression EQUALS term
    (62) expression -> . expression OR term
    (63) expression -> . expression AND term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . term
    (31) term -> . term PRODUCT factor
    (41) term -> . term DIVIDE factor
    (50) term -> . factor
    (30) factor -> . literal
    (40) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (37) literal -> . IDENTIFIER
    (44) literal -> . DOUBLE
    (45) literal -> . INTEGER
    (46) literal -> . STRING
    (47) literal -> . TRUE
    (48) literal -> . FALSE

    IDENTIFIER      shift and go to state 43
    MINUS           shift and go to state 31
    NOT             shift and go to state 33
    LEFT_PAREN      shift and go to state 20
    DOUBLE          shift and go to state 36
    INTEGER         shift and go to state 37
    STRING          shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40

    expression                     shift and go to state 145
    term                           shift and go to state 32
    factor                         shift and go to state 34
    literal                        shift and go to state 35

state 141

    (52) iterative_statement -> FOR expression TO expression STEP expression . compound_statement
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54
    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 146

state 142

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 147

state 143

    (26) function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .

    PUT             reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LET             reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DO              reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IF              reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    $end            reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 26 (function_statement -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)


state 144

    (21) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .

    PUT             reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 21 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)


state 145

    (36) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression . RIGHT_PAREN compound_statement
    (54) expression -> expression . GTE term
    (55) expression -> expression . LTE term
    (56) expression -> expression . IS GREATER THAN term
    (57) expression -> expression . IS LESS THAN term
    (58) expression -> expression . GT term
    (59) expression -> expression . LT term
    (60) expression -> expression . IS term
    (61) expression -> expression . EQUALS term
    (62) expression -> expression . OR term
    (63) expression -> expression . AND term
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 148
    GTE             shift and go to state 45
    LTE             shift and go to state 46
    IS              shift and go to state 47
    GT              shift and go to state 48
    LT              shift and go to state 49
    EQUALS          shift and go to state 50
    OR              shift and go to state 51
    AND             shift and go to state 52
    PLUS            shift and go to state 53
    MINUS           shift and go to state 54


state 146

    (52) iterative_statement -> FOR expression TO expression STEP expression compound_statement .

    PUT             reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IDENTIFIER      reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LET             reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    SEMICOLON       reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DO              reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FOR             reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    WHILE           reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IF              reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_BRACE      reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LOG             reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FUNCTION        reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_BOOL       reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_INT        reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_CHAR       reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_STRING     reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    MINUS           reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    NOT             reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_PAREN      reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DOUBLE          reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    INTEGER         reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRING          reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TRUE            reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FALSE           reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    $end            reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    RIGHT_BRACE     reduce using rule 52 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)


state 147

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .

    PUT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IDENTIFIER      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LET             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    SEMICOLON       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DO              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FOR             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IF              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_BRACE      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LOG             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FUNCTION        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_BOOL       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_INT        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_CHAR       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_DOUBLE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_STRING     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    MINUS           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    NOT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_PAREN      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DOUBLE          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    INTEGER         reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRING          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TRUE            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FALSE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    $end            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    RIGHT_BRACE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)


state 148

    (36) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 23

    compound_statement             shift and go to state 149

state 149

    (36) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .

    PUT             reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FUNCTION        reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 36 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)

