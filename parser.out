Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    MODULUS
    OBJECT
    RETURN
    SKIP

Grammar

Rule 0     S' -> program
Rule 1     type_specifier -> TYPE_BOOL
Rule 2     type_specifier -> TYPE_INT
Rule 3     type_specifier -> TYPE_CHAR
Rule 4     type_specifier -> TYPE_DOUBLE
Rule 5     type_specifier -> TYPE_STRING
Rule 6     empty -> <empty>
Rule 7     arguments -> expression COMMA arguments
Rule 8     function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
Rule 9     conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
Rule 10    struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
Rule 11    variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON
Rule 12    variable_declaration_list -> variable_declaration variable_declaration_list
Rule 13    expression_statement -> expression SEMICOLON
Rule 14    expression_statement -> SEMICOLON
Rule 15    statement -> assignment_statement
Rule 16    statement -> expression_statement
Rule 17    statement -> iterative_statement
Rule 18    statement -> conditional_statement
Rule 19    statement -> compound_statement
Rule 20    statement -> print_statement
Rule 21    statement -> function_call
Rule 22    statement -> variable_declaration
Rule 23    iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
Rule 24    iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 25    statement_list -> statement statement_list
Rule 26    print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 27    assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON
Rule 28    compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE
Rule 29    function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
Rule 30    declaration_list -> statement declaration_list
Rule 31    iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
Rule 32    program -> declaration_list
Rule 33    expression -> IDENTIFIER INCREMENT
Rule 34    factor -> literal
Rule 35    term -> term PRODUCT factor
Rule 36    arguments -> expression
Rule 37    function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 38    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 39    variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON
Rule 40    variable_declaration_list -> empty
Rule 41    assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 42    declaration_list -> function_declaration declaration_list
Rule 43    iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
Rule 44    literal -> IDENTIFIER DOT IDENTIFIER
Rule 45    function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
Rule 46    statement_list -> empty
Rule 47    expression -> IDENTIFIER DECREMENT
Rule 48    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 49    term -> term DIVIDE factor
Rule 50    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
Rule 51    variable_declaration -> type_specifier IDENTIFIER SEMICOLON
Rule 52    assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
Rule 53    declaration_list -> struct_declaration declaration_list
Rule 54    iterative_statement -> FOR expression TO expression compound_statement
Rule 55    literal -> IDENTIFIER
Rule 56    expression -> MINUS term
Rule 57    term -> factor
Rule 58    variable_declaration -> LET IDENTIFIER SEMICOLON
Rule 59    declaration_list -> empty
Rule 60    iterative_statement -> FOR expression TO expression STEP expression compound_statement
Rule 61    literal -> DOUBLE
Rule 62    literal -> INTEGER
Rule 63    literal -> STRING
Rule 64    literal -> TRUE
Rule 65    literal -> FALSE
Rule 66    expression -> expression NOT ASSIGN term
Rule 67    iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
Rule 68    expression -> NOT term
Rule 69    iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
Rule 70    expression -> expression EXP term
Rule 71    iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
Rule 72    expression -> expression GTE term
Rule 73    iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
Rule 74    expression -> expression LTE term
Rule 75    expression -> expression IS GREATER THAN term
Rule 76    expression -> expression IS LESS THAN term
Rule 77    expression -> expression GT term
Rule 78    expression -> expression LT term
Rule 79    expression -> expression IS term
Rule 80    expression -> expression EQUALS term
Rule 81    expression -> expression OR term
Rule 82    expression -> expression AND term
Rule 83    expression -> expression PLUS term
Rule 84    expression -> expression MINUS term
Rule 85    expression -> term

Terminals, with rules where they appear

AND                  : 82
ASSIGN               : 11 39 41 52 66
BREAK                : 
COMMA                : 7
DECREMENT            : 47
DIVIDE               : 49
DO                   : 23
DOT                  : 44 52
DOUBLE               : 61
ELSE                 : 9 50
EQUALS               : 80
EXP                  : 70
FALSE                : 65
FOR                  : 31 43 54 60 67 69 71 73
FUNCTION             : 29 45
GREATER              : 75
GT                   : 77
GTE                  : 72
IDENTIFIER           : 8 10 11 27 29 33 37 39 41 44 44 45 47 51 52 52 55 58
IF                   : 9 38 50
IN                   : 27
INCREMENT            : 33
INTEGER              : 62
IS                   : 75 76 79
LEFT_BRACE           : 10 28
LEFT_PAREN           : 8 9 23 24 26 29 31 37 38 43 45 48 50 67 69 71 73
LESS                 : 76
LET                  : 11 58
LOG                  : 26
LT                   : 78
LTE                  : 74
MINUS                : 56 84
MODULUS              : 
NOT                  : 66 68
OBJECT               : 
OR                   : 81
PLUS                 : 83
PRODUCT              : 35
PUT                  : 27
RETURN               : 
RIGHT_BRACE          : 10 28
RIGHT_PAREN          : 8 9 23 24 26 29 31 37 38 43 45 48 50 67 69 71 73
SEMICOLON            : 8 11 13 14 26 27 37 39 41 51 52 58 67 69 71 71 73 73
SKIP                 : 
STEP                 : 43 60
STRING               : 63
STRUCT               : 10
THAN                 : 75 76
TO                   : 31 43 54 60
TRUE                 : 64
TYPE_BOOL            : 1
TYPE_CHAR            : 3
TYPE_DOUBLE          : 4
TYPE_INT             : 2
TYPE_STRING          : 5
WHILE                : 23 24
error                : 

Nonterminals, with rules where they appear

arguments            : 7 26 29 37
assignment_statement : 15 67 71
compound_statement   : 9 9 19 23 24 29 31 38 43 45 50 54 60 67 69 71 73
conditional_statement : 18 50
declaration_list     : 30 32 42 53
empty                : 40 46 59
expression           : 7 9 11 13 23 24 27 31 31 36 38 39 41 43 43 43 48 50 52 54 54 60 60 60 66 67 69 69 70 71 71 72 73 73 73 74 75 76 77 78 79 80 81 82 83 84
expression_statement : 16
factor               : 35 49 57
function_call        : 21
function_declaration : 42
iterative_statement  : 17
literal              : 34
print_statement      : 20
program              : 0
statement            : 25 30
statement_list       : 25 28
struct_declaration   : 53
term                 : 35 49 56 66 68 70 72 74 75 76 77 78 79 80 81 82 83 84 85
type_specifier       : 39 51
variable_declaration : 12 22 67 69
variable_declaration_list : 10 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (32) program -> . declaration_list
    (30) declaration_list -> . statement declaration_list
    (42) declaration_list -> . function_declaration declaration_list
    (53) declaration_list -> . struct_declaration declaration_list
    (59) declaration_list -> . empty
    (15) statement -> . assignment_statement
    (16) statement -> . expression_statement
    (17) statement -> . iterative_statement
    (18) statement -> . conditional_statement
    (19) statement -> . compound_statement
    (20) statement -> . print_statement
    (21) statement -> . function_call
    (22) statement -> . variable_declaration
    (29) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (13) expression_statement -> . expression SEMICOLON
    (14) expression_statement -> . SEMICOLON
    (23) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (24) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (67) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (26) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    statement                      shift and go to state 3
    function_declaration           shift and go to state 4
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 1

    (0) S' -> program .



state 2

    (32) program -> declaration_list .

    $end            reduce using rule 32 (program -> declaration_list .)


state 3

    (30) declaration_list -> statement . declaration_list
    (30) declaration_list -> . statement declaration_list
    (42) declaration_list -> . function_declaration declaration_list
    (53) declaration_list -> . struct_declaration declaration_list
    (59) declaration_list -> . empty
    (15) statement -> . assignment_statement
    (16) statement -> . expression_statement
    (17) statement -> . iterative_statement
    (18) statement -> . conditional_statement
    (19) statement -> . compound_statement
    (20) statement -> . print_statement
    (21) statement -> . function_call
    (22) statement -> . variable_declaration
    (29) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (13) expression_statement -> . expression SEMICOLON
    (14) expression_statement -> . SEMICOLON
    (23) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (24) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (67) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (26) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement                      shift and go to state 3
    declaration_list               shift and go to state 45
    function_declaration           shift and go to state 4
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 4

    (42) declaration_list -> function_declaration . declaration_list
    (30) declaration_list -> . statement declaration_list
    (42) declaration_list -> . function_declaration declaration_list
    (53) declaration_list -> . struct_declaration declaration_list
    (59) declaration_list -> . empty
    (15) statement -> . assignment_statement
    (16) statement -> . expression_statement
    (17) statement -> . iterative_statement
    (18) statement -> . conditional_statement
    (19) statement -> . compound_statement
    (20) statement -> . print_statement
    (21) statement -> . function_call
    (22) statement -> . variable_declaration
    (29) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (13) expression_statement -> . expression SEMICOLON
    (14) expression_statement -> . SEMICOLON
    (23) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (24) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (67) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (26) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    function_declaration           shift and go to state 4
    declaration_list               shift and go to state 46
    statement                      shift and go to state 3
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 5

    (53) declaration_list -> struct_declaration . declaration_list
    (30) declaration_list -> . statement declaration_list
    (42) declaration_list -> . function_declaration declaration_list
    (53) declaration_list -> . struct_declaration declaration_list
    (59) declaration_list -> . empty
    (15) statement -> . assignment_statement
    (16) statement -> . expression_statement
    (17) statement -> . iterative_statement
    (18) statement -> . conditional_statement
    (19) statement -> . compound_statement
    (20) statement -> . print_statement
    (21) statement -> . function_call
    (22) statement -> . variable_declaration
    (29) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (13) expression_statement -> . expression SEMICOLON
    (14) expression_statement -> . SEMICOLON
    (23) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (24) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (67) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (26) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    struct_declaration             shift and go to state 5
    declaration_list               shift and go to state 47
    statement                      shift and go to state 3
    function_declaration           shift and go to state 4
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 6

    (59) declaration_list -> empty .

    $end            reduce using rule 59 (declaration_list -> empty .)


state 7

    (15) statement -> assignment_statement .

    FUNCTION        reduce using rule 15 (statement -> assignment_statement .)
    STRUCT          reduce using rule 15 (statement -> assignment_statement .)
    PUT             reduce using rule 15 (statement -> assignment_statement .)
    IDENTIFIER      reduce using rule 15 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 15 (statement -> assignment_statement .)
    DO              reduce using rule 15 (statement -> assignment_statement .)
    WHILE           reduce using rule 15 (statement -> assignment_statement .)
    FOR             reduce using rule 15 (statement -> assignment_statement .)
    IF              reduce using rule 15 (statement -> assignment_statement .)
    LEFT_BRACE      reduce using rule 15 (statement -> assignment_statement .)
    LOG             reduce using rule 15 (statement -> assignment_statement .)
    LET             reduce using rule 15 (statement -> assignment_statement .)
    MINUS           reduce using rule 15 (statement -> assignment_statement .)
    NOT             reduce using rule 15 (statement -> assignment_statement .)
    TYPE_BOOL       reduce using rule 15 (statement -> assignment_statement .)
    TYPE_INT        reduce using rule 15 (statement -> assignment_statement .)
    TYPE_CHAR       reduce using rule 15 (statement -> assignment_statement .)
    TYPE_DOUBLE     reduce using rule 15 (statement -> assignment_statement .)
    TYPE_STRING     reduce using rule 15 (statement -> assignment_statement .)
    LEFT_PAREN      reduce using rule 15 (statement -> assignment_statement .)
    DOUBLE          reduce using rule 15 (statement -> assignment_statement .)
    INTEGER         reduce using rule 15 (statement -> assignment_statement .)
    STRING          reduce using rule 15 (statement -> assignment_statement .)
    TRUE            reduce using rule 15 (statement -> assignment_statement .)
    FALSE           reduce using rule 15 (statement -> assignment_statement .)
    $end            reduce using rule 15 (statement -> assignment_statement .)
    RIGHT_BRACE     reduce using rule 15 (statement -> assignment_statement .)


state 8

    (16) statement -> expression_statement .

    FUNCTION        reduce using rule 16 (statement -> expression_statement .)
    STRUCT          reduce using rule 16 (statement -> expression_statement .)
    PUT             reduce using rule 16 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 16 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 16 (statement -> expression_statement .)
    DO              reduce using rule 16 (statement -> expression_statement .)
    WHILE           reduce using rule 16 (statement -> expression_statement .)
    FOR             reduce using rule 16 (statement -> expression_statement .)
    IF              reduce using rule 16 (statement -> expression_statement .)
    LEFT_BRACE      reduce using rule 16 (statement -> expression_statement .)
    LOG             reduce using rule 16 (statement -> expression_statement .)
    LET             reduce using rule 16 (statement -> expression_statement .)
    MINUS           reduce using rule 16 (statement -> expression_statement .)
    NOT             reduce using rule 16 (statement -> expression_statement .)
    TYPE_BOOL       reduce using rule 16 (statement -> expression_statement .)
    TYPE_INT        reduce using rule 16 (statement -> expression_statement .)
    TYPE_CHAR       reduce using rule 16 (statement -> expression_statement .)
    TYPE_DOUBLE     reduce using rule 16 (statement -> expression_statement .)
    TYPE_STRING     reduce using rule 16 (statement -> expression_statement .)
    LEFT_PAREN      reduce using rule 16 (statement -> expression_statement .)
    DOUBLE          reduce using rule 16 (statement -> expression_statement .)
    INTEGER         reduce using rule 16 (statement -> expression_statement .)
    STRING          reduce using rule 16 (statement -> expression_statement .)
    TRUE            reduce using rule 16 (statement -> expression_statement .)
    FALSE           reduce using rule 16 (statement -> expression_statement .)
    $end            reduce using rule 16 (statement -> expression_statement .)
    RIGHT_BRACE     reduce using rule 16 (statement -> expression_statement .)


state 9

    (17) statement -> iterative_statement .

    FUNCTION        reduce using rule 17 (statement -> iterative_statement .)
    STRUCT          reduce using rule 17 (statement -> iterative_statement .)
    PUT             reduce using rule 17 (statement -> iterative_statement .)
    IDENTIFIER      reduce using rule 17 (statement -> iterative_statement .)
    SEMICOLON       reduce using rule 17 (statement -> iterative_statement .)
    DO              reduce using rule 17 (statement -> iterative_statement .)
    WHILE           reduce using rule 17 (statement -> iterative_statement .)
    FOR             reduce using rule 17 (statement -> iterative_statement .)
    IF              reduce using rule 17 (statement -> iterative_statement .)
    LEFT_BRACE      reduce using rule 17 (statement -> iterative_statement .)
    LOG             reduce using rule 17 (statement -> iterative_statement .)
    LET             reduce using rule 17 (statement -> iterative_statement .)
    MINUS           reduce using rule 17 (statement -> iterative_statement .)
    NOT             reduce using rule 17 (statement -> iterative_statement .)
    TYPE_BOOL       reduce using rule 17 (statement -> iterative_statement .)
    TYPE_INT        reduce using rule 17 (statement -> iterative_statement .)
    TYPE_CHAR       reduce using rule 17 (statement -> iterative_statement .)
    TYPE_DOUBLE     reduce using rule 17 (statement -> iterative_statement .)
    TYPE_STRING     reduce using rule 17 (statement -> iterative_statement .)
    LEFT_PAREN      reduce using rule 17 (statement -> iterative_statement .)
    DOUBLE          reduce using rule 17 (statement -> iterative_statement .)
    INTEGER         reduce using rule 17 (statement -> iterative_statement .)
    STRING          reduce using rule 17 (statement -> iterative_statement .)
    TRUE            reduce using rule 17 (statement -> iterative_statement .)
    FALSE           reduce using rule 17 (statement -> iterative_statement .)
    $end            reduce using rule 17 (statement -> iterative_statement .)
    RIGHT_BRACE     reduce using rule 17 (statement -> iterative_statement .)


state 10

    (18) statement -> conditional_statement .

    FUNCTION        reduce using rule 18 (statement -> conditional_statement .)
    STRUCT          reduce using rule 18 (statement -> conditional_statement .)
    PUT             reduce using rule 18 (statement -> conditional_statement .)
    IDENTIFIER      reduce using rule 18 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 18 (statement -> conditional_statement .)
    DO              reduce using rule 18 (statement -> conditional_statement .)
    WHILE           reduce using rule 18 (statement -> conditional_statement .)
    FOR             reduce using rule 18 (statement -> conditional_statement .)
    IF              reduce using rule 18 (statement -> conditional_statement .)
    LEFT_BRACE      reduce using rule 18 (statement -> conditional_statement .)
    LOG             reduce using rule 18 (statement -> conditional_statement .)
    LET             reduce using rule 18 (statement -> conditional_statement .)
    MINUS           reduce using rule 18 (statement -> conditional_statement .)
    NOT             reduce using rule 18 (statement -> conditional_statement .)
    TYPE_BOOL       reduce using rule 18 (statement -> conditional_statement .)
    TYPE_INT        reduce using rule 18 (statement -> conditional_statement .)
    TYPE_CHAR       reduce using rule 18 (statement -> conditional_statement .)
    TYPE_DOUBLE     reduce using rule 18 (statement -> conditional_statement .)
    TYPE_STRING     reduce using rule 18 (statement -> conditional_statement .)
    LEFT_PAREN      reduce using rule 18 (statement -> conditional_statement .)
    DOUBLE          reduce using rule 18 (statement -> conditional_statement .)
    INTEGER         reduce using rule 18 (statement -> conditional_statement .)
    STRING          reduce using rule 18 (statement -> conditional_statement .)
    TRUE            reduce using rule 18 (statement -> conditional_statement .)
    FALSE           reduce using rule 18 (statement -> conditional_statement .)
    $end            reduce using rule 18 (statement -> conditional_statement .)
    RIGHT_BRACE     reduce using rule 18 (statement -> conditional_statement .)


state 11

    (19) statement -> compound_statement .

    FUNCTION        reduce using rule 19 (statement -> compound_statement .)
    STRUCT          reduce using rule 19 (statement -> compound_statement .)
    PUT             reduce using rule 19 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 19 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 19 (statement -> compound_statement .)
    DO              reduce using rule 19 (statement -> compound_statement .)
    WHILE           reduce using rule 19 (statement -> compound_statement .)
    FOR             reduce using rule 19 (statement -> compound_statement .)
    IF              reduce using rule 19 (statement -> compound_statement .)
    LEFT_BRACE      reduce using rule 19 (statement -> compound_statement .)
    LOG             reduce using rule 19 (statement -> compound_statement .)
    LET             reduce using rule 19 (statement -> compound_statement .)
    MINUS           reduce using rule 19 (statement -> compound_statement .)
    NOT             reduce using rule 19 (statement -> compound_statement .)
    TYPE_BOOL       reduce using rule 19 (statement -> compound_statement .)
    TYPE_INT        reduce using rule 19 (statement -> compound_statement .)
    TYPE_CHAR       reduce using rule 19 (statement -> compound_statement .)
    TYPE_DOUBLE     reduce using rule 19 (statement -> compound_statement .)
    TYPE_STRING     reduce using rule 19 (statement -> compound_statement .)
    LEFT_PAREN      reduce using rule 19 (statement -> compound_statement .)
    DOUBLE          reduce using rule 19 (statement -> compound_statement .)
    INTEGER         reduce using rule 19 (statement -> compound_statement .)
    STRING          reduce using rule 19 (statement -> compound_statement .)
    TRUE            reduce using rule 19 (statement -> compound_statement .)
    FALSE           reduce using rule 19 (statement -> compound_statement .)
    $end            reduce using rule 19 (statement -> compound_statement .)
    RIGHT_BRACE     reduce using rule 19 (statement -> compound_statement .)


state 12

    (20) statement -> print_statement .

    FUNCTION        reduce using rule 20 (statement -> print_statement .)
    STRUCT          reduce using rule 20 (statement -> print_statement .)
    PUT             reduce using rule 20 (statement -> print_statement .)
    IDENTIFIER      reduce using rule 20 (statement -> print_statement .)
    SEMICOLON       reduce using rule 20 (statement -> print_statement .)
    DO              reduce using rule 20 (statement -> print_statement .)
    WHILE           reduce using rule 20 (statement -> print_statement .)
    FOR             reduce using rule 20 (statement -> print_statement .)
    IF              reduce using rule 20 (statement -> print_statement .)
    LEFT_BRACE      reduce using rule 20 (statement -> print_statement .)
    LOG             reduce using rule 20 (statement -> print_statement .)
    LET             reduce using rule 20 (statement -> print_statement .)
    MINUS           reduce using rule 20 (statement -> print_statement .)
    NOT             reduce using rule 20 (statement -> print_statement .)
    TYPE_BOOL       reduce using rule 20 (statement -> print_statement .)
    TYPE_INT        reduce using rule 20 (statement -> print_statement .)
    TYPE_CHAR       reduce using rule 20 (statement -> print_statement .)
    TYPE_DOUBLE     reduce using rule 20 (statement -> print_statement .)
    TYPE_STRING     reduce using rule 20 (statement -> print_statement .)
    LEFT_PAREN      reduce using rule 20 (statement -> print_statement .)
    DOUBLE          reduce using rule 20 (statement -> print_statement .)
    INTEGER         reduce using rule 20 (statement -> print_statement .)
    STRING          reduce using rule 20 (statement -> print_statement .)
    TRUE            reduce using rule 20 (statement -> print_statement .)
    FALSE           reduce using rule 20 (statement -> print_statement .)
    $end            reduce using rule 20 (statement -> print_statement .)
    RIGHT_BRACE     reduce using rule 20 (statement -> print_statement .)


state 13

    (21) statement -> function_call .

    FUNCTION        reduce using rule 21 (statement -> function_call .)
    STRUCT          reduce using rule 21 (statement -> function_call .)
    PUT             reduce using rule 21 (statement -> function_call .)
    IDENTIFIER      reduce using rule 21 (statement -> function_call .)
    SEMICOLON       reduce using rule 21 (statement -> function_call .)
    DO              reduce using rule 21 (statement -> function_call .)
    WHILE           reduce using rule 21 (statement -> function_call .)
    FOR             reduce using rule 21 (statement -> function_call .)
    IF              reduce using rule 21 (statement -> function_call .)
    LEFT_BRACE      reduce using rule 21 (statement -> function_call .)
    LOG             reduce using rule 21 (statement -> function_call .)
    LET             reduce using rule 21 (statement -> function_call .)
    MINUS           reduce using rule 21 (statement -> function_call .)
    NOT             reduce using rule 21 (statement -> function_call .)
    TYPE_BOOL       reduce using rule 21 (statement -> function_call .)
    TYPE_INT        reduce using rule 21 (statement -> function_call .)
    TYPE_CHAR       reduce using rule 21 (statement -> function_call .)
    TYPE_DOUBLE     reduce using rule 21 (statement -> function_call .)
    TYPE_STRING     reduce using rule 21 (statement -> function_call .)
    LEFT_PAREN      reduce using rule 21 (statement -> function_call .)
    DOUBLE          reduce using rule 21 (statement -> function_call .)
    INTEGER         reduce using rule 21 (statement -> function_call .)
    STRING          reduce using rule 21 (statement -> function_call .)
    TRUE            reduce using rule 21 (statement -> function_call .)
    FALSE           reduce using rule 21 (statement -> function_call .)
    $end            reduce using rule 21 (statement -> function_call .)
    RIGHT_BRACE     reduce using rule 21 (statement -> function_call .)


state 14

    (22) statement -> variable_declaration .

    FUNCTION        reduce using rule 22 (statement -> variable_declaration .)
    STRUCT          reduce using rule 22 (statement -> variable_declaration .)
    PUT             reduce using rule 22 (statement -> variable_declaration .)
    IDENTIFIER      reduce using rule 22 (statement -> variable_declaration .)
    SEMICOLON       reduce using rule 22 (statement -> variable_declaration .)
    DO              reduce using rule 22 (statement -> variable_declaration .)
    WHILE           reduce using rule 22 (statement -> variable_declaration .)
    FOR             reduce using rule 22 (statement -> variable_declaration .)
    IF              reduce using rule 22 (statement -> variable_declaration .)
    LEFT_BRACE      reduce using rule 22 (statement -> variable_declaration .)
    LOG             reduce using rule 22 (statement -> variable_declaration .)
    LET             reduce using rule 22 (statement -> variable_declaration .)
    MINUS           reduce using rule 22 (statement -> variable_declaration .)
    NOT             reduce using rule 22 (statement -> variable_declaration .)
    TYPE_BOOL       reduce using rule 22 (statement -> variable_declaration .)
    TYPE_INT        reduce using rule 22 (statement -> variable_declaration .)
    TYPE_CHAR       reduce using rule 22 (statement -> variable_declaration .)
    TYPE_DOUBLE     reduce using rule 22 (statement -> variable_declaration .)
    TYPE_STRING     reduce using rule 22 (statement -> variable_declaration .)
    LEFT_PAREN      reduce using rule 22 (statement -> variable_declaration .)
    DOUBLE          reduce using rule 22 (statement -> variable_declaration .)
    INTEGER         reduce using rule 22 (statement -> variable_declaration .)
    STRING          reduce using rule 22 (statement -> variable_declaration .)
    TRUE            reduce using rule 22 (statement -> variable_declaration .)
    FALSE           reduce using rule 22 (statement -> variable_declaration .)
    $end            reduce using rule 22 (statement -> variable_declaration .)
    RIGHT_BRACE     reduce using rule 22 (statement -> variable_declaration .)


state 15

    (29) function_declaration -> FUNCTION . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> FUNCTION . IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement

    IDENTIFIER      shift and go to state 48


state 16

    (41) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (52) assignment_statement -> IDENTIFIER . DOT IDENTIFIER ASSIGN expression SEMICOLON
    (8) function_call -> IDENTIFIER . LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (33) expression -> IDENTIFIER . INCREMENT
    (47) expression -> IDENTIFIER . DECREMENT
    (44) literal -> IDENTIFIER . DOT IDENTIFIER
    (55) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 49
    DOT             shift and go to state 50
    LEFT_PAREN      shift and go to state 51
    INCREMENT       shift and go to state 52
    DECREMENT       shift and go to state 53
    PRODUCT         reduce using rule 55 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 55 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 55 (literal -> IDENTIFIER .)
    NOT             reduce using rule 55 (literal -> IDENTIFIER .)
    EXP             reduce using rule 55 (literal -> IDENTIFIER .)
    GTE             reduce using rule 55 (literal -> IDENTIFIER .)
    LTE             reduce using rule 55 (literal -> IDENTIFIER .)
    IS              reduce using rule 55 (literal -> IDENTIFIER .)
    GT              reduce using rule 55 (literal -> IDENTIFIER .)
    LT              reduce using rule 55 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 55 (literal -> IDENTIFIER .)
    OR              reduce using rule 55 (literal -> IDENTIFIER .)
    AND             reduce using rule 55 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 55 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 55 (literal -> IDENTIFIER .)


state 17

    (48) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 54
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 18

    (10) struct_declaration -> STRUCT . IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE

    IDENTIFIER      shift and go to state 56


state 19

    (28) compound_statement -> LEFT_BRACE . statement_list RIGHT_BRACE
    (25) statement_list -> . statement statement_list
    (46) statement_list -> . empty
    (15) statement -> . assignment_statement
    (16) statement -> . expression_statement
    (17) statement -> . iterative_statement
    (18) statement -> . conditional_statement
    (19) statement -> . compound_statement
    (20) statement -> . print_statement
    (21) statement -> . function_call
    (22) statement -> . variable_declaration
    (6) empty -> .
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (13) expression_statement -> . expression SEMICOLON
    (14) expression_statement -> . SEMICOLON
    (23) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (24) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (67) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (26) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement_list                 shift and go to state 57
    statement                      shift and go to state 58
    empty                          shift and go to state 59
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 20

    (27) assignment_statement -> PUT . expression IN IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 60
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 21

    (13) expression_statement -> expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 61
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 22

    (14) expression_statement -> SEMICOLON .

    FUNCTION        reduce using rule 14 (expression_statement -> SEMICOLON .)
    STRUCT          reduce using rule 14 (expression_statement -> SEMICOLON .)
    PUT             reduce using rule 14 (expression_statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (expression_statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 14 (expression_statement -> SEMICOLON .)
    DO              reduce using rule 14 (expression_statement -> SEMICOLON .)
    WHILE           reduce using rule 14 (expression_statement -> SEMICOLON .)
    FOR             reduce using rule 14 (expression_statement -> SEMICOLON .)
    IF              reduce using rule 14 (expression_statement -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 14 (expression_statement -> SEMICOLON .)
    LOG             reduce using rule 14 (expression_statement -> SEMICOLON .)
    LET             reduce using rule 14 (expression_statement -> SEMICOLON .)
    MINUS           reduce using rule 14 (expression_statement -> SEMICOLON .)
    NOT             reduce using rule 14 (expression_statement -> SEMICOLON .)
    TYPE_BOOL       reduce using rule 14 (expression_statement -> SEMICOLON .)
    TYPE_INT        reduce using rule 14 (expression_statement -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 14 (expression_statement -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 14 (expression_statement -> SEMICOLON .)
    TYPE_STRING     reduce using rule 14 (expression_statement -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 14 (expression_statement -> SEMICOLON .)
    DOUBLE          reduce using rule 14 (expression_statement -> SEMICOLON .)
    INTEGER         reduce using rule 14 (expression_statement -> SEMICOLON .)
    STRING          reduce using rule 14 (expression_statement -> SEMICOLON .)
    TRUE            reduce using rule 14 (expression_statement -> SEMICOLON .)
    FALSE           reduce using rule 14 (expression_statement -> SEMICOLON .)
    $end            reduce using rule 14 (expression_statement -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 14 (expression_statement -> SEMICOLON .)


state 23

    (23) iterative_statement -> DO . compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 74

state 24

    (24) iterative_statement -> WHILE . LEFT_PAREN expression RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 75


state 25

    (31) iterative_statement -> FOR . LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR . LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> FOR . expression TO expression compound_statement
    (60) iterative_statement -> FOR . expression TO expression STEP expression compound_statement
    (67) iterative_statement -> FOR . LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> FOR . LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR . LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR . LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 76
    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 77
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 26

    (9) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement

    LEFT_PAREN      shift and go to state 78


state 27

    (26) print_statement -> LOG . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 79


state 28

    (11) variable_declaration -> LET . IDENTIFIER ASSIGN expression SEMICOLON
    (58) variable_declaration -> LET . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 80


state 29

    (39) variable_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> type_specifier . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 81


state 30

    (56) expression -> MINUS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 82
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 31

    (85) expression -> term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 85 (expression -> term .)
    NOT             reduce using rule 85 (expression -> term .)
    EXP             reduce using rule 85 (expression -> term .)
    GTE             reduce using rule 85 (expression -> term .)
    LTE             reduce using rule 85 (expression -> term .)
    IS              reduce using rule 85 (expression -> term .)
    GT              reduce using rule 85 (expression -> term .)
    LT              reduce using rule 85 (expression -> term .)
    EQUALS          reduce using rule 85 (expression -> term .)
    OR              reduce using rule 85 (expression -> term .)
    AND             reduce using rule 85 (expression -> term .)
    PLUS            reduce using rule 85 (expression -> term .)
    MINUS           reduce using rule 85 (expression -> term .)
    RIGHT_PAREN     reduce using rule 85 (expression -> term .)
    IN              reduce using rule 85 (expression -> term .)
    TO              reduce using rule 85 (expression -> term .)
    COMMA           reduce using rule 85 (expression -> term .)
    STEP            reduce using rule 85 (expression -> term .)
    LEFT_BRACE      reduce using rule 85 (expression -> term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 32

    (68) expression -> NOT . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 86
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 33

    (1) type_specifier -> TYPE_BOOL .

    IDENTIFIER      reduce using rule 1 (type_specifier -> TYPE_BOOL .)


state 34

    (2) type_specifier -> TYPE_INT .

    IDENTIFIER      reduce using rule 2 (type_specifier -> TYPE_INT .)


state 35

    (3) type_specifier -> TYPE_CHAR .

    IDENTIFIER      reduce using rule 3 (type_specifier -> TYPE_CHAR .)


state 36

    (4) type_specifier -> TYPE_DOUBLE .

    IDENTIFIER      reduce using rule 4 (type_specifier -> TYPE_DOUBLE .)


state 37

    (5) type_specifier -> TYPE_STRING .

    IDENTIFIER      reduce using rule 5 (type_specifier -> TYPE_STRING .)


state 38

    (57) term -> factor .

    PRODUCT         reduce using rule 57 (term -> factor .)
    DIVIDE          reduce using rule 57 (term -> factor .)
    SEMICOLON       reduce using rule 57 (term -> factor .)
    NOT             reduce using rule 57 (term -> factor .)
    EXP             reduce using rule 57 (term -> factor .)
    GTE             reduce using rule 57 (term -> factor .)
    LTE             reduce using rule 57 (term -> factor .)
    IS              reduce using rule 57 (term -> factor .)
    GT              reduce using rule 57 (term -> factor .)
    LT              reduce using rule 57 (term -> factor .)
    EQUALS          reduce using rule 57 (term -> factor .)
    OR              reduce using rule 57 (term -> factor .)
    AND             reduce using rule 57 (term -> factor .)
    PLUS            reduce using rule 57 (term -> factor .)
    MINUS           reduce using rule 57 (term -> factor .)
    RIGHT_PAREN     reduce using rule 57 (term -> factor .)
    IN              reduce using rule 57 (term -> factor .)
    TO              reduce using rule 57 (term -> factor .)
    COMMA           reduce using rule 57 (term -> factor .)
    STEP            reduce using rule 57 (term -> factor .)
    LEFT_BRACE      reduce using rule 57 (term -> factor .)


state 39

    (34) factor -> literal .

    PRODUCT         reduce using rule 34 (factor -> literal .)
    DIVIDE          reduce using rule 34 (factor -> literal .)
    SEMICOLON       reduce using rule 34 (factor -> literal .)
    NOT             reduce using rule 34 (factor -> literal .)
    EXP             reduce using rule 34 (factor -> literal .)
    GTE             reduce using rule 34 (factor -> literal .)
    LTE             reduce using rule 34 (factor -> literal .)
    IS              reduce using rule 34 (factor -> literal .)
    GT              reduce using rule 34 (factor -> literal .)
    LT              reduce using rule 34 (factor -> literal .)
    EQUALS          reduce using rule 34 (factor -> literal .)
    OR              reduce using rule 34 (factor -> literal .)
    AND             reduce using rule 34 (factor -> literal .)
    PLUS            reduce using rule 34 (factor -> literal .)
    MINUS           reduce using rule 34 (factor -> literal .)
    RIGHT_PAREN     reduce using rule 34 (factor -> literal .)
    IN              reduce using rule 34 (factor -> literal .)
    TO              reduce using rule 34 (factor -> literal .)
    COMMA           reduce using rule 34 (factor -> literal .)
    STEP            reduce using rule 34 (factor -> literal .)
    LEFT_BRACE      reduce using rule 34 (factor -> literal .)


state 40

    (61) literal -> DOUBLE .

    PRODUCT         reduce using rule 61 (literal -> DOUBLE .)
    DIVIDE          reduce using rule 61 (literal -> DOUBLE .)
    SEMICOLON       reduce using rule 61 (literal -> DOUBLE .)
    NOT             reduce using rule 61 (literal -> DOUBLE .)
    EXP             reduce using rule 61 (literal -> DOUBLE .)
    GTE             reduce using rule 61 (literal -> DOUBLE .)
    LTE             reduce using rule 61 (literal -> DOUBLE .)
    IS              reduce using rule 61 (literal -> DOUBLE .)
    GT              reduce using rule 61 (literal -> DOUBLE .)
    LT              reduce using rule 61 (literal -> DOUBLE .)
    EQUALS          reduce using rule 61 (literal -> DOUBLE .)
    OR              reduce using rule 61 (literal -> DOUBLE .)
    AND             reduce using rule 61 (literal -> DOUBLE .)
    PLUS            reduce using rule 61 (literal -> DOUBLE .)
    MINUS           reduce using rule 61 (literal -> DOUBLE .)
    RIGHT_PAREN     reduce using rule 61 (literal -> DOUBLE .)
    IN              reduce using rule 61 (literal -> DOUBLE .)
    TO              reduce using rule 61 (literal -> DOUBLE .)
    COMMA           reduce using rule 61 (literal -> DOUBLE .)
    STEP            reduce using rule 61 (literal -> DOUBLE .)
    LEFT_BRACE      reduce using rule 61 (literal -> DOUBLE .)


state 41

    (62) literal -> INTEGER .

    PRODUCT         reduce using rule 62 (literal -> INTEGER .)
    DIVIDE          reduce using rule 62 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 62 (literal -> INTEGER .)
    NOT             reduce using rule 62 (literal -> INTEGER .)
    EXP             reduce using rule 62 (literal -> INTEGER .)
    GTE             reduce using rule 62 (literal -> INTEGER .)
    LTE             reduce using rule 62 (literal -> INTEGER .)
    IS              reduce using rule 62 (literal -> INTEGER .)
    GT              reduce using rule 62 (literal -> INTEGER .)
    LT              reduce using rule 62 (literal -> INTEGER .)
    EQUALS          reduce using rule 62 (literal -> INTEGER .)
    OR              reduce using rule 62 (literal -> INTEGER .)
    AND             reduce using rule 62 (literal -> INTEGER .)
    PLUS            reduce using rule 62 (literal -> INTEGER .)
    MINUS           reduce using rule 62 (literal -> INTEGER .)
    RIGHT_PAREN     reduce using rule 62 (literal -> INTEGER .)
    IN              reduce using rule 62 (literal -> INTEGER .)
    TO              reduce using rule 62 (literal -> INTEGER .)
    COMMA           reduce using rule 62 (literal -> INTEGER .)
    STEP            reduce using rule 62 (literal -> INTEGER .)
    LEFT_BRACE      reduce using rule 62 (literal -> INTEGER .)


state 42

    (63) literal -> STRING .

    PRODUCT         reduce using rule 63 (literal -> STRING .)
    DIVIDE          reduce using rule 63 (literal -> STRING .)
    SEMICOLON       reduce using rule 63 (literal -> STRING .)
    NOT             reduce using rule 63 (literal -> STRING .)
    EXP             reduce using rule 63 (literal -> STRING .)
    GTE             reduce using rule 63 (literal -> STRING .)
    LTE             reduce using rule 63 (literal -> STRING .)
    IS              reduce using rule 63 (literal -> STRING .)
    GT              reduce using rule 63 (literal -> STRING .)
    LT              reduce using rule 63 (literal -> STRING .)
    EQUALS          reduce using rule 63 (literal -> STRING .)
    OR              reduce using rule 63 (literal -> STRING .)
    AND             reduce using rule 63 (literal -> STRING .)
    PLUS            reduce using rule 63 (literal -> STRING .)
    MINUS           reduce using rule 63 (literal -> STRING .)
    RIGHT_PAREN     reduce using rule 63 (literal -> STRING .)
    IN              reduce using rule 63 (literal -> STRING .)
    TO              reduce using rule 63 (literal -> STRING .)
    COMMA           reduce using rule 63 (literal -> STRING .)
    STEP            reduce using rule 63 (literal -> STRING .)
    LEFT_BRACE      reduce using rule 63 (literal -> STRING .)


state 43

    (64) literal -> TRUE .

    PRODUCT         reduce using rule 64 (literal -> TRUE .)
    DIVIDE          reduce using rule 64 (literal -> TRUE .)
    SEMICOLON       reduce using rule 64 (literal -> TRUE .)
    NOT             reduce using rule 64 (literal -> TRUE .)
    EXP             reduce using rule 64 (literal -> TRUE .)
    GTE             reduce using rule 64 (literal -> TRUE .)
    LTE             reduce using rule 64 (literal -> TRUE .)
    IS              reduce using rule 64 (literal -> TRUE .)
    GT              reduce using rule 64 (literal -> TRUE .)
    LT              reduce using rule 64 (literal -> TRUE .)
    EQUALS          reduce using rule 64 (literal -> TRUE .)
    OR              reduce using rule 64 (literal -> TRUE .)
    AND             reduce using rule 64 (literal -> TRUE .)
    PLUS            reduce using rule 64 (literal -> TRUE .)
    MINUS           reduce using rule 64 (literal -> TRUE .)
    RIGHT_PAREN     reduce using rule 64 (literal -> TRUE .)
    IN              reduce using rule 64 (literal -> TRUE .)
    TO              reduce using rule 64 (literal -> TRUE .)
    COMMA           reduce using rule 64 (literal -> TRUE .)
    STEP            reduce using rule 64 (literal -> TRUE .)
    LEFT_BRACE      reduce using rule 64 (literal -> TRUE .)


state 44

    (65) literal -> FALSE .

    PRODUCT         reduce using rule 65 (literal -> FALSE .)
    DIVIDE          reduce using rule 65 (literal -> FALSE .)
    SEMICOLON       reduce using rule 65 (literal -> FALSE .)
    NOT             reduce using rule 65 (literal -> FALSE .)
    EXP             reduce using rule 65 (literal -> FALSE .)
    GTE             reduce using rule 65 (literal -> FALSE .)
    LTE             reduce using rule 65 (literal -> FALSE .)
    IS              reduce using rule 65 (literal -> FALSE .)
    GT              reduce using rule 65 (literal -> FALSE .)
    LT              reduce using rule 65 (literal -> FALSE .)
    EQUALS          reduce using rule 65 (literal -> FALSE .)
    OR              reduce using rule 65 (literal -> FALSE .)
    AND             reduce using rule 65 (literal -> FALSE .)
    PLUS            reduce using rule 65 (literal -> FALSE .)
    MINUS           reduce using rule 65 (literal -> FALSE .)
    RIGHT_PAREN     reduce using rule 65 (literal -> FALSE .)
    IN              reduce using rule 65 (literal -> FALSE .)
    TO              reduce using rule 65 (literal -> FALSE .)
    COMMA           reduce using rule 65 (literal -> FALSE .)
    STEP            reduce using rule 65 (literal -> FALSE .)
    LEFT_BRACE      reduce using rule 65 (literal -> FALSE .)


state 45

    (30) declaration_list -> statement declaration_list .

    $end            reduce using rule 30 (declaration_list -> statement declaration_list .)


state 46

    (42) declaration_list -> function_declaration declaration_list .

    $end            reduce using rule 42 (declaration_list -> function_declaration declaration_list .)


state 47

    (53) declaration_list -> struct_declaration declaration_list .

    $end            reduce using rule 53 (declaration_list -> struct_declaration declaration_list .)


state 48

    (29) function_declaration -> FUNCTION IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> FUNCTION IDENTIFIER . LEFT_PAREN RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 87


state 49

    (41) assignment_statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 88
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 50

    (52) assignment_statement -> IDENTIFIER DOT . IDENTIFIER ASSIGN expression SEMICOLON
    (44) literal -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 89


state 51

    (8) function_call -> IDENTIFIER LEFT_PAREN . RIGHT_PAREN SEMICOLON
    (37) function_call -> IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 90
    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 91
    expression                     shift and go to state 92
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 52

    (33) expression -> IDENTIFIER INCREMENT .

    SEMICOLON       reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    NOT             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    EXP             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    GTE             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LTE             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IS              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    GT              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LT              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    EQUALS          reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    OR              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    AND             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    PLUS            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    MINUS           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    RIGHT_PAREN     reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IN              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TO              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    COMMA           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    STEP            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LEFT_BRACE      reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)


state 53

    (47) expression -> IDENTIFIER DECREMENT .

    SEMICOLON       reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    NOT             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    EXP             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    GTE             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    LTE             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    IS              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    GT              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    LT              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    EQUALS          reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    OR              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    AND             reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    PLUS            reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    MINUS           reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    RIGHT_PAREN     reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    IN              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    TO              reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    COMMA           reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    STEP            reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)
    LEFT_BRACE      reduce using rule 47 (expression -> IDENTIFIER DECREMENT .)


state 54

    (48) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 93
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 55

    (33) expression -> IDENTIFIER . INCREMENT
    (47) expression -> IDENTIFIER . DECREMENT
    (44) literal -> IDENTIFIER . DOT IDENTIFIER
    (55) literal -> IDENTIFIER .

    INCREMENT       shift and go to state 52
    DECREMENT       shift and go to state 53
    DOT             shift and go to state 94
    PRODUCT         reduce using rule 55 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 55 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 55 (literal -> IDENTIFIER .)
    NOT             reduce using rule 55 (literal -> IDENTIFIER .)
    EXP             reduce using rule 55 (literal -> IDENTIFIER .)
    GTE             reduce using rule 55 (literal -> IDENTIFIER .)
    LTE             reduce using rule 55 (literal -> IDENTIFIER .)
    IS              reduce using rule 55 (literal -> IDENTIFIER .)
    GT              reduce using rule 55 (literal -> IDENTIFIER .)
    LT              reduce using rule 55 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 55 (literal -> IDENTIFIER .)
    OR              reduce using rule 55 (literal -> IDENTIFIER .)
    AND             reduce using rule 55 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 55 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 55 (literal -> IDENTIFIER .)
    IN              reduce using rule 55 (literal -> IDENTIFIER .)
    TO              reduce using rule 55 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 55 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 55 (literal -> IDENTIFIER .)
    STEP            reduce using rule 55 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 55 (literal -> IDENTIFIER .)


state 56

    (10) struct_declaration -> STRUCT IDENTIFIER . LEFT_BRACE variable_declaration_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 95


state 57

    (28) compound_statement -> LEFT_BRACE statement_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 96


state 58

    (25) statement_list -> statement . statement_list
    (25) statement_list -> . statement statement_list
    (46) statement_list -> . empty
    (15) statement -> . assignment_statement
    (16) statement -> . expression_statement
    (17) statement -> . iterative_statement
    (18) statement -> . conditional_statement
    (19) statement -> . compound_statement
    (20) statement -> . print_statement
    (21) statement -> . function_call
    (22) statement -> . variable_declaration
    (6) empty -> .
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (13) expression_statement -> . expression SEMICOLON
    (14) expression_statement -> . SEMICOLON
    (23) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (24) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (54) iterative_statement -> . FOR expression TO expression compound_statement
    (60) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (67) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (26) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement                      shift and go to state 58
    statement_list                 shift and go to state 97
    empty                          shift and go to state 59
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 59

    (46) statement_list -> empty .

    RIGHT_BRACE     reduce using rule 46 (statement_list -> empty .)


state 60

    (27) assignment_statement -> PUT expression . IN IDENTIFIER SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    IN              shift and go to state 98
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 61

    (13) expression_statement -> expression SEMICOLON .

    FUNCTION        reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    STRUCT          reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    PUT             reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    DO              reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    LOG             reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    LET             reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    TYPE_STRING     reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    STRING          reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    TRUE            reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    FALSE           reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    $end            reduce using rule 13 (expression_statement -> expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 13 (expression_statement -> expression SEMICOLON .)


state 62

    (66) expression -> expression NOT . ASSIGN term

    ASSIGN          shift and go to state 99


state 63

    (70) expression -> expression EXP . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 100
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 64

    (72) expression -> expression GTE . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 101
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 65

    (74) expression -> expression LTE . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 102
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 66

    (75) expression -> expression IS . GREATER THAN term
    (76) expression -> expression IS . LESS THAN term
    (79) expression -> expression IS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    GREATER         shift and go to state 103
    LESS            shift and go to state 105
    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 104
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 67

    (77) expression -> expression GT . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 106
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 68

    (78) expression -> expression LT . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 107
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 69

    (80) expression -> expression EQUALS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 108
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 70

    (81) expression -> expression OR . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 109
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 71

    (82) expression -> expression AND . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 110
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 72

    (83) expression -> expression PLUS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 111
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 73

    (84) expression -> expression MINUS . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 112
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 74

    (23) iterative_statement -> DO compound_statement . WHILE LEFT_PAREN expression RIGHT_PAREN

    WHILE           shift and go to state 113


state 75

    (24) iterative_statement -> WHILE LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 114
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 76

    (31) iterative_statement -> FOR LEFT_PAREN . expression TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN . expression TO expression STEP expression RIGHT_PAREN compound_statement
    (67) iterative_statement -> FOR LEFT_PAREN . variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> FOR LEFT_PAREN . variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR LEFT_PAREN . expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR LEFT_PAREN . expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (48) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LET             shift and go to state 28
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 115
    variable_declaration           shift and go to state 116
    term                           shift and go to state 31
    type_specifier                 shift and go to state 29
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 77

    (54) iterative_statement -> FOR expression . TO expression compound_statement
    (60) iterative_statement -> FOR expression . TO expression STEP expression compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    TO              shift and go to state 117
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 78

    (9) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 118
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 79

    (26) print_statement -> LOG LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 119
    expression                     shift and go to state 92
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 80

    (11) variable_declaration -> LET IDENTIFIER . ASSIGN expression SEMICOLON
    (58) variable_declaration -> LET IDENTIFIER . SEMICOLON

    ASSIGN          shift and go to state 120
    SEMICOLON       shift and go to state 121


state 81

    (39) variable_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON
    (51) variable_declaration -> type_specifier IDENTIFIER . SEMICOLON

    ASSIGN          shift and go to state 122
    SEMICOLON       shift and go to state 123


state 82

    (56) expression -> MINUS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 56 (expression -> MINUS term .)
    NOT             reduce using rule 56 (expression -> MINUS term .)
    EXP             reduce using rule 56 (expression -> MINUS term .)
    GTE             reduce using rule 56 (expression -> MINUS term .)
    LTE             reduce using rule 56 (expression -> MINUS term .)
    IS              reduce using rule 56 (expression -> MINUS term .)
    GT              reduce using rule 56 (expression -> MINUS term .)
    LT              reduce using rule 56 (expression -> MINUS term .)
    EQUALS          reduce using rule 56 (expression -> MINUS term .)
    OR              reduce using rule 56 (expression -> MINUS term .)
    AND             reduce using rule 56 (expression -> MINUS term .)
    PLUS            reduce using rule 56 (expression -> MINUS term .)
    MINUS           reduce using rule 56 (expression -> MINUS term .)
    RIGHT_PAREN     reduce using rule 56 (expression -> MINUS term .)
    IN              reduce using rule 56 (expression -> MINUS term .)
    TO              reduce using rule 56 (expression -> MINUS term .)
    COMMA           reduce using rule 56 (expression -> MINUS term .)
    STEP            reduce using rule 56 (expression -> MINUS term .)
    LEFT_BRACE      reduce using rule 56 (expression -> MINUS term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 83

    (44) literal -> IDENTIFIER . DOT IDENTIFIER
    (55) literal -> IDENTIFIER .

    DOT             shift and go to state 94
    PRODUCT         reduce using rule 55 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 55 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 55 (literal -> IDENTIFIER .)
    NOT             reduce using rule 55 (literal -> IDENTIFIER .)
    EXP             reduce using rule 55 (literal -> IDENTIFIER .)
    GTE             reduce using rule 55 (literal -> IDENTIFIER .)
    LTE             reduce using rule 55 (literal -> IDENTIFIER .)
    IS              reduce using rule 55 (literal -> IDENTIFIER .)
    GT              reduce using rule 55 (literal -> IDENTIFIER .)
    LT              reduce using rule 55 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 55 (literal -> IDENTIFIER .)
    OR              reduce using rule 55 (literal -> IDENTIFIER .)
    AND             reduce using rule 55 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 55 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 55 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 55 (literal -> IDENTIFIER .)
    IN              reduce using rule 55 (literal -> IDENTIFIER .)
    TO              reduce using rule 55 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 55 (literal -> IDENTIFIER .)
    STEP            reduce using rule 55 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 55 (literal -> IDENTIFIER .)


state 84

    (35) term -> term PRODUCT . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    factor                         shift and go to state 124
    literal                        shift and go to state 39

state 85

    (49) term -> term DIVIDE . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    factor                         shift and go to state 125
    literal                        shift and go to state 39

state 86

    (68) expression -> NOT term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 68 (expression -> NOT term .)
    NOT             reduce using rule 68 (expression -> NOT term .)
    EXP             reduce using rule 68 (expression -> NOT term .)
    GTE             reduce using rule 68 (expression -> NOT term .)
    LTE             reduce using rule 68 (expression -> NOT term .)
    IS              reduce using rule 68 (expression -> NOT term .)
    GT              reduce using rule 68 (expression -> NOT term .)
    LT              reduce using rule 68 (expression -> NOT term .)
    EQUALS          reduce using rule 68 (expression -> NOT term .)
    OR              reduce using rule 68 (expression -> NOT term .)
    AND             reduce using rule 68 (expression -> NOT term .)
    PLUS            reduce using rule 68 (expression -> NOT term .)
    MINUS           reduce using rule 68 (expression -> NOT term .)
    RIGHT_PAREN     reduce using rule 68 (expression -> NOT term .)
    IN              reduce using rule 68 (expression -> NOT term .)
    TO              reduce using rule 68 (expression -> NOT term .)
    COMMA           reduce using rule 68 (expression -> NOT term .)
    STEP            reduce using rule 68 (expression -> NOT term .)
    LEFT_BRACE      reduce using rule 68 (expression -> NOT term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 87

    (29) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN compound_statement
    (45) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN . RIGHT_PAREN compound_statement
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 127
    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 126
    expression                     shift and go to state 92
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 88

    (41) assignment_statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 128
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 89

    (52) assignment_statement -> IDENTIFIER DOT IDENTIFIER . ASSIGN expression SEMICOLON
    (44) literal -> IDENTIFIER DOT IDENTIFIER .

    ASSIGN          shift and go to state 129
    PRODUCT         reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    NOT             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EXP             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GTE             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LTE             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IS              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GT              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LT              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EQUALS          reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    OR              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    AND             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    MINUS           reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)


state 90

    (8) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 130


state 91

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 131


state 92

    (7) arguments -> expression . COMMA arguments
    (36) arguments -> expression .
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    COMMA           shift and go to state 132
    RIGHT_PAREN     reduce using rule 36 (arguments -> expression .)
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 93

    (48) factor -> LEFT_PAREN expression RIGHT_PAREN .

    PRODUCT         reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EXP             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GTE             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LTE             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IS              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GT              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LT              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IN              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TO              reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    STEP            reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 48 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 94

    (44) literal -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 133


state 95

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE . variable_declaration_list RIGHT_BRACE
    (12) variable_declaration_list -> . variable_declaration variable_declaration_list
    (40) variable_declaration_list -> . empty
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (6) empty -> .
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING

    LET             shift and go to state 28
    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37

    variable_declaration_list      shift and go to state 134
    variable_declaration           shift and go to state 135
    empty                          shift and go to state 136
    type_specifier                 shift and go to state 29

state 96

    (28) compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .

    FUNCTION        reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRUCT          reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    PUT             reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DO              reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    WHILE           reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FOR             reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IF              reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LOG             reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LET             reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    MINUS           reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    NOT             reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_BOOL       reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_INT        reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_CHAR       reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_DOUBLE     reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_STRING     reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    INTEGER         reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRING          reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TRUE            reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FALSE           reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    $end            reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    ELSE            reduce using rule 28 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)


state 97

    (25) statement_list -> statement statement_list .

    RIGHT_BRACE     reduce using rule 25 (statement_list -> statement statement_list .)


state 98

    (27) assignment_statement -> PUT expression IN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 137


state 99

    (66) expression -> expression NOT ASSIGN . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 138
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 100

    (70) expression -> expression EXP term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 70 (expression -> expression EXP term .)
    NOT             reduce using rule 70 (expression -> expression EXP term .)
    EXP             reduce using rule 70 (expression -> expression EXP term .)
    GTE             reduce using rule 70 (expression -> expression EXP term .)
    LTE             reduce using rule 70 (expression -> expression EXP term .)
    IS              reduce using rule 70 (expression -> expression EXP term .)
    GT              reduce using rule 70 (expression -> expression EXP term .)
    LT              reduce using rule 70 (expression -> expression EXP term .)
    EQUALS          reduce using rule 70 (expression -> expression EXP term .)
    OR              reduce using rule 70 (expression -> expression EXP term .)
    AND             reduce using rule 70 (expression -> expression EXP term .)
    PLUS            reduce using rule 70 (expression -> expression EXP term .)
    MINUS           reduce using rule 70 (expression -> expression EXP term .)
    RIGHT_PAREN     reduce using rule 70 (expression -> expression EXP term .)
    IN              reduce using rule 70 (expression -> expression EXP term .)
    TO              reduce using rule 70 (expression -> expression EXP term .)
    COMMA           reduce using rule 70 (expression -> expression EXP term .)
    STEP            reduce using rule 70 (expression -> expression EXP term .)
    LEFT_BRACE      reduce using rule 70 (expression -> expression EXP term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 101

    (72) expression -> expression GTE term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 72 (expression -> expression GTE term .)
    NOT             reduce using rule 72 (expression -> expression GTE term .)
    EXP             reduce using rule 72 (expression -> expression GTE term .)
    GTE             reduce using rule 72 (expression -> expression GTE term .)
    LTE             reduce using rule 72 (expression -> expression GTE term .)
    IS              reduce using rule 72 (expression -> expression GTE term .)
    GT              reduce using rule 72 (expression -> expression GTE term .)
    LT              reduce using rule 72 (expression -> expression GTE term .)
    EQUALS          reduce using rule 72 (expression -> expression GTE term .)
    OR              reduce using rule 72 (expression -> expression GTE term .)
    AND             reduce using rule 72 (expression -> expression GTE term .)
    PLUS            reduce using rule 72 (expression -> expression GTE term .)
    MINUS           reduce using rule 72 (expression -> expression GTE term .)
    RIGHT_PAREN     reduce using rule 72 (expression -> expression GTE term .)
    IN              reduce using rule 72 (expression -> expression GTE term .)
    TO              reduce using rule 72 (expression -> expression GTE term .)
    COMMA           reduce using rule 72 (expression -> expression GTE term .)
    STEP            reduce using rule 72 (expression -> expression GTE term .)
    LEFT_BRACE      reduce using rule 72 (expression -> expression GTE term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 102

    (74) expression -> expression LTE term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 74 (expression -> expression LTE term .)
    NOT             reduce using rule 74 (expression -> expression LTE term .)
    EXP             reduce using rule 74 (expression -> expression LTE term .)
    GTE             reduce using rule 74 (expression -> expression LTE term .)
    LTE             reduce using rule 74 (expression -> expression LTE term .)
    IS              reduce using rule 74 (expression -> expression LTE term .)
    GT              reduce using rule 74 (expression -> expression LTE term .)
    LT              reduce using rule 74 (expression -> expression LTE term .)
    EQUALS          reduce using rule 74 (expression -> expression LTE term .)
    OR              reduce using rule 74 (expression -> expression LTE term .)
    AND             reduce using rule 74 (expression -> expression LTE term .)
    PLUS            reduce using rule 74 (expression -> expression LTE term .)
    MINUS           reduce using rule 74 (expression -> expression LTE term .)
    RIGHT_PAREN     reduce using rule 74 (expression -> expression LTE term .)
    IN              reduce using rule 74 (expression -> expression LTE term .)
    TO              reduce using rule 74 (expression -> expression LTE term .)
    COMMA           reduce using rule 74 (expression -> expression LTE term .)
    STEP            reduce using rule 74 (expression -> expression LTE term .)
    LEFT_BRACE      reduce using rule 74 (expression -> expression LTE term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 103

    (75) expression -> expression IS GREATER . THAN term

    THAN            shift and go to state 139


state 104

    (79) expression -> expression IS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 79 (expression -> expression IS term .)
    NOT             reduce using rule 79 (expression -> expression IS term .)
    EXP             reduce using rule 79 (expression -> expression IS term .)
    GTE             reduce using rule 79 (expression -> expression IS term .)
    LTE             reduce using rule 79 (expression -> expression IS term .)
    IS              reduce using rule 79 (expression -> expression IS term .)
    GT              reduce using rule 79 (expression -> expression IS term .)
    LT              reduce using rule 79 (expression -> expression IS term .)
    EQUALS          reduce using rule 79 (expression -> expression IS term .)
    OR              reduce using rule 79 (expression -> expression IS term .)
    AND             reduce using rule 79 (expression -> expression IS term .)
    PLUS            reduce using rule 79 (expression -> expression IS term .)
    MINUS           reduce using rule 79 (expression -> expression IS term .)
    RIGHT_PAREN     reduce using rule 79 (expression -> expression IS term .)
    IN              reduce using rule 79 (expression -> expression IS term .)
    TO              reduce using rule 79 (expression -> expression IS term .)
    COMMA           reduce using rule 79 (expression -> expression IS term .)
    STEP            reduce using rule 79 (expression -> expression IS term .)
    LEFT_BRACE      reduce using rule 79 (expression -> expression IS term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 105

    (76) expression -> expression IS LESS . THAN term

    THAN            shift and go to state 140


state 106

    (77) expression -> expression GT term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 77 (expression -> expression GT term .)
    NOT             reduce using rule 77 (expression -> expression GT term .)
    EXP             reduce using rule 77 (expression -> expression GT term .)
    GTE             reduce using rule 77 (expression -> expression GT term .)
    LTE             reduce using rule 77 (expression -> expression GT term .)
    IS              reduce using rule 77 (expression -> expression GT term .)
    GT              reduce using rule 77 (expression -> expression GT term .)
    LT              reduce using rule 77 (expression -> expression GT term .)
    EQUALS          reduce using rule 77 (expression -> expression GT term .)
    OR              reduce using rule 77 (expression -> expression GT term .)
    AND             reduce using rule 77 (expression -> expression GT term .)
    PLUS            reduce using rule 77 (expression -> expression GT term .)
    MINUS           reduce using rule 77 (expression -> expression GT term .)
    RIGHT_PAREN     reduce using rule 77 (expression -> expression GT term .)
    IN              reduce using rule 77 (expression -> expression GT term .)
    TO              reduce using rule 77 (expression -> expression GT term .)
    COMMA           reduce using rule 77 (expression -> expression GT term .)
    STEP            reduce using rule 77 (expression -> expression GT term .)
    LEFT_BRACE      reduce using rule 77 (expression -> expression GT term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 107

    (78) expression -> expression LT term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 78 (expression -> expression LT term .)
    NOT             reduce using rule 78 (expression -> expression LT term .)
    EXP             reduce using rule 78 (expression -> expression LT term .)
    GTE             reduce using rule 78 (expression -> expression LT term .)
    LTE             reduce using rule 78 (expression -> expression LT term .)
    IS              reduce using rule 78 (expression -> expression LT term .)
    GT              reduce using rule 78 (expression -> expression LT term .)
    LT              reduce using rule 78 (expression -> expression LT term .)
    EQUALS          reduce using rule 78 (expression -> expression LT term .)
    OR              reduce using rule 78 (expression -> expression LT term .)
    AND             reduce using rule 78 (expression -> expression LT term .)
    PLUS            reduce using rule 78 (expression -> expression LT term .)
    MINUS           reduce using rule 78 (expression -> expression LT term .)
    RIGHT_PAREN     reduce using rule 78 (expression -> expression LT term .)
    IN              reduce using rule 78 (expression -> expression LT term .)
    TO              reduce using rule 78 (expression -> expression LT term .)
    COMMA           reduce using rule 78 (expression -> expression LT term .)
    STEP            reduce using rule 78 (expression -> expression LT term .)
    LEFT_BRACE      reduce using rule 78 (expression -> expression LT term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 108

    (80) expression -> expression EQUALS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 80 (expression -> expression EQUALS term .)
    NOT             reduce using rule 80 (expression -> expression EQUALS term .)
    EXP             reduce using rule 80 (expression -> expression EQUALS term .)
    GTE             reduce using rule 80 (expression -> expression EQUALS term .)
    LTE             reduce using rule 80 (expression -> expression EQUALS term .)
    IS              reduce using rule 80 (expression -> expression EQUALS term .)
    GT              reduce using rule 80 (expression -> expression EQUALS term .)
    LT              reduce using rule 80 (expression -> expression EQUALS term .)
    EQUALS          reduce using rule 80 (expression -> expression EQUALS term .)
    OR              reduce using rule 80 (expression -> expression EQUALS term .)
    AND             reduce using rule 80 (expression -> expression EQUALS term .)
    PLUS            reduce using rule 80 (expression -> expression EQUALS term .)
    MINUS           reduce using rule 80 (expression -> expression EQUALS term .)
    RIGHT_PAREN     reduce using rule 80 (expression -> expression EQUALS term .)
    IN              reduce using rule 80 (expression -> expression EQUALS term .)
    TO              reduce using rule 80 (expression -> expression EQUALS term .)
    COMMA           reduce using rule 80 (expression -> expression EQUALS term .)
    STEP            reduce using rule 80 (expression -> expression EQUALS term .)
    LEFT_BRACE      reduce using rule 80 (expression -> expression EQUALS term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 109

    (81) expression -> expression OR term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 81 (expression -> expression OR term .)
    NOT             reduce using rule 81 (expression -> expression OR term .)
    EXP             reduce using rule 81 (expression -> expression OR term .)
    GTE             reduce using rule 81 (expression -> expression OR term .)
    LTE             reduce using rule 81 (expression -> expression OR term .)
    IS              reduce using rule 81 (expression -> expression OR term .)
    GT              reduce using rule 81 (expression -> expression OR term .)
    LT              reduce using rule 81 (expression -> expression OR term .)
    EQUALS          reduce using rule 81 (expression -> expression OR term .)
    OR              reduce using rule 81 (expression -> expression OR term .)
    AND             reduce using rule 81 (expression -> expression OR term .)
    PLUS            reduce using rule 81 (expression -> expression OR term .)
    MINUS           reduce using rule 81 (expression -> expression OR term .)
    RIGHT_PAREN     reduce using rule 81 (expression -> expression OR term .)
    IN              reduce using rule 81 (expression -> expression OR term .)
    TO              reduce using rule 81 (expression -> expression OR term .)
    COMMA           reduce using rule 81 (expression -> expression OR term .)
    STEP            reduce using rule 81 (expression -> expression OR term .)
    LEFT_BRACE      reduce using rule 81 (expression -> expression OR term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 110

    (82) expression -> expression AND term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 82 (expression -> expression AND term .)
    NOT             reduce using rule 82 (expression -> expression AND term .)
    EXP             reduce using rule 82 (expression -> expression AND term .)
    GTE             reduce using rule 82 (expression -> expression AND term .)
    LTE             reduce using rule 82 (expression -> expression AND term .)
    IS              reduce using rule 82 (expression -> expression AND term .)
    GT              reduce using rule 82 (expression -> expression AND term .)
    LT              reduce using rule 82 (expression -> expression AND term .)
    EQUALS          reduce using rule 82 (expression -> expression AND term .)
    OR              reduce using rule 82 (expression -> expression AND term .)
    AND             reduce using rule 82 (expression -> expression AND term .)
    PLUS            reduce using rule 82 (expression -> expression AND term .)
    MINUS           reduce using rule 82 (expression -> expression AND term .)
    RIGHT_PAREN     reduce using rule 82 (expression -> expression AND term .)
    IN              reduce using rule 82 (expression -> expression AND term .)
    TO              reduce using rule 82 (expression -> expression AND term .)
    COMMA           reduce using rule 82 (expression -> expression AND term .)
    STEP            reduce using rule 82 (expression -> expression AND term .)
    LEFT_BRACE      reduce using rule 82 (expression -> expression AND term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 111

    (83) expression -> expression PLUS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 83 (expression -> expression PLUS term .)
    NOT             reduce using rule 83 (expression -> expression PLUS term .)
    EXP             reduce using rule 83 (expression -> expression PLUS term .)
    GTE             reduce using rule 83 (expression -> expression PLUS term .)
    LTE             reduce using rule 83 (expression -> expression PLUS term .)
    IS              reduce using rule 83 (expression -> expression PLUS term .)
    GT              reduce using rule 83 (expression -> expression PLUS term .)
    LT              reduce using rule 83 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 83 (expression -> expression PLUS term .)
    OR              reduce using rule 83 (expression -> expression PLUS term .)
    AND             reduce using rule 83 (expression -> expression PLUS term .)
    PLUS            reduce using rule 83 (expression -> expression PLUS term .)
    MINUS           reduce using rule 83 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 83 (expression -> expression PLUS term .)
    IN              reduce using rule 83 (expression -> expression PLUS term .)
    TO              reduce using rule 83 (expression -> expression PLUS term .)
    COMMA           reduce using rule 83 (expression -> expression PLUS term .)
    STEP            reduce using rule 83 (expression -> expression PLUS term .)
    LEFT_BRACE      reduce using rule 83 (expression -> expression PLUS term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 112

    (84) expression -> expression MINUS term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 84 (expression -> expression MINUS term .)
    NOT             reduce using rule 84 (expression -> expression MINUS term .)
    EXP             reduce using rule 84 (expression -> expression MINUS term .)
    GTE             reduce using rule 84 (expression -> expression MINUS term .)
    LTE             reduce using rule 84 (expression -> expression MINUS term .)
    IS              reduce using rule 84 (expression -> expression MINUS term .)
    GT              reduce using rule 84 (expression -> expression MINUS term .)
    LT              reduce using rule 84 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 84 (expression -> expression MINUS term .)
    OR              reduce using rule 84 (expression -> expression MINUS term .)
    AND             reduce using rule 84 (expression -> expression MINUS term .)
    PLUS            reduce using rule 84 (expression -> expression MINUS term .)
    MINUS           reduce using rule 84 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 84 (expression -> expression MINUS term .)
    IN              reduce using rule 84 (expression -> expression MINUS term .)
    TO              reduce using rule 84 (expression -> expression MINUS term .)
    COMMA           reduce using rule 84 (expression -> expression MINUS term .)
    STEP            reduce using rule 84 (expression -> expression MINUS term .)
    LEFT_BRACE      reduce using rule 84 (expression -> expression MINUS term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 113

    (23) iterative_statement -> DO compound_statement WHILE . LEFT_PAREN expression RIGHT_PAREN

    LEFT_PAREN      shift and go to state 141


state 114

    (24) iterative_statement -> WHILE LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 142
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 115

    (31) iterative_statement -> FOR LEFT_PAREN expression . TO expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN expression . TO expression STEP expression RIGHT_PAREN compound_statement
    (71) iterative_statement -> FOR LEFT_PAREN expression . SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR LEFT_PAREN expression . SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (48) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    TO              shift and go to state 143
    SEMICOLON       shift and go to state 144
    RIGHT_PAREN     shift and go to state 93
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 116

    (67) iterative_statement -> FOR LEFT_PAREN variable_declaration . expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> FOR LEFT_PAREN variable_declaration . expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 145
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 117

    (54) iterative_statement -> FOR expression TO . expression compound_statement
    (60) iterative_statement -> FOR expression TO . expression STEP expression compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 146
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 118

    (9) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (50) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE conditional_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 147
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 119

    (26) print_statement -> LOG LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 148


state 120

    (11) variable_declaration -> LET IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 149
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 121

    (58) variable_declaration -> LET IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    DO              reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    IF              reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LET             reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    $end            reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 58 (variable_declaration -> LET IDENTIFIER SEMICOLON .)


state 122

    (39) variable_declaration -> type_specifier IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 150
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 123

    (51) variable_declaration -> type_specifier IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DO              reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IF              reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LET             reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    $end            reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 51 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)


state 124

    (35) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 35 (term -> term PRODUCT factor .)
    DIVIDE          reduce using rule 35 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 35 (term -> term PRODUCT factor .)
    NOT             reduce using rule 35 (term -> term PRODUCT factor .)
    EXP             reduce using rule 35 (term -> term PRODUCT factor .)
    GTE             reduce using rule 35 (term -> term PRODUCT factor .)
    LTE             reduce using rule 35 (term -> term PRODUCT factor .)
    IS              reduce using rule 35 (term -> term PRODUCT factor .)
    GT              reduce using rule 35 (term -> term PRODUCT factor .)
    LT              reduce using rule 35 (term -> term PRODUCT factor .)
    EQUALS          reduce using rule 35 (term -> term PRODUCT factor .)
    OR              reduce using rule 35 (term -> term PRODUCT factor .)
    AND             reduce using rule 35 (term -> term PRODUCT factor .)
    PLUS            reduce using rule 35 (term -> term PRODUCT factor .)
    MINUS           reduce using rule 35 (term -> term PRODUCT factor .)
    RIGHT_PAREN     reduce using rule 35 (term -> term PRODUCT factor .)
    IN              reduce using rule 35 (term -> term PRODUCT factor .)
    TO              reduce using rule 35 (term -> term PRODUCT factor .)
    COMMA           reduce using rule 35 (term -> term PRODUCT factor .)
    STEP            reduce using rule 35 (term -> term PRODUCT factor .)
    LEFT_BRACE      reduce using rule 35 (term -> term PRODUCT factor .)


state 125

    (49) term -> term DIVIDE factor .

    PRODUCT         reduce using rule 49 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 49 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 49 (term -> term DIVIDE factor .)
    NOT             reduce using rule 49 (term -> term DIVIDE factor .)
    EXP             reduce using rule 49 (term -> term DIVIDE factor .)
    GTE             reduce using rule 49 (term -> term DIVIDE factor .)
    LTE             reduce using rule 49 (term -> term DIVIDE factor .)
    IS              reduce using rule 49 (term -> term DIVIDE factor .)
    GT              reduce using rule 49 (term -> term DIVIDE factor .)
    LT              reduce using rule 49 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 49 (term -> term DIVIDE factor .)
    OR              reduce using rule 49 (term -> term DIVIDE factor .)
    AND             reduce using rule 49 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 49 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 49 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 49 (term -> term DIVIDE factor .)
    IN              reduce using rule 49 (term -> term DIVIDE factor .)
    TO              reduce using rule 49 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 49 (term -> term DIVIDE factor .)
    STEP            reduce using rule 49 (term -> term DIVIDE factor .)
    LEFT_BRACE      reduce using rule 49 (term -> term DIVIDE factor .)


state 126

    (29) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 151


state 127

    (45) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 152

state 128

    (41) assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_PAREN     reduce using rule 41 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 129

    (52) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 153
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 130

    (8) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)


state 131

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 154


state 132

    (7) arguments -> expression COMMA . arguments
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 92
    arguments                      shift and go to state 155
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 133

    (44) literal -> IDENTIFIER DOT IDENTIFIER .

    PRODUCT         reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    NOT             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EXP             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GTE             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LTE             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IS              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GT              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LT              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EQUALS          reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    OR              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    AND             reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    MINUS           reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IN              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TO              reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    COMMA           reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    STEP            reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LEFT_BRACE      reduce using rule 44 (literal -> IDENTIFIER DOT IDENTIFIER .)


state 134

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 156


state 135

    (12) variable_declaration_list -> variable_declaration . variable_declaration_list
    (12) variable_declaration_list -> . variable_declaration variable_declaration_list
    (40) variable_declaration_list -> . empty
    (11) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (39) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (51) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (58) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (6) empty -> .
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING

    LET             shift and go to state 28
    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37

    variable_declaration           shift and go to state 135
    variable_declaration_list      shift and go to state 157
    empty                          shift and go to state 136
    type_specifier                 shift and go to state 29

state 136

    (40) variable_declaration_list -> empty .

    RIGHT_BRACE     reduce using rule 40 (variable_declaration_list -> empty .)


state 137

    (27) assignment_statement -> PUT expression IN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 158


state 138

    (66) expression -> expression NOT ASSIGN term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    NOT             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    EXP             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    GTE             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LTE             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    IS              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    GT              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LT              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    EQUALS          reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    OR              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    AND             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    PLUS            reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    MINUS           reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    RIGHT_PAREN     reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    IN              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TO              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    COMMA           reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    STEP            reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LEFT_BRACE      reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 139

    (75) expression -> expression IS GREATER THAN . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 159
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 140

    (76) expression -> expression IS LESS THAN . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 83
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 160
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 141

    (23) iterative_statement -> DO compound_statement WHILE LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 161
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 142

    (24) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 162

state 143

    (31) iterative_statement -> FOR LEFT_PAREN expression TO . expression RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN expression TO . expression STEP expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 163
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 144

    (71) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON . expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON . expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 164
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 145

    (67) iterative_statement -> FOR LEFT_PAREN variable_declaration expression . SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> FOR LEFT_PAREN variable_declaration expression . SEMICOLON expression RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 165
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 146

    (54) iterative_statement -> FOR expression TO expression . compound_statement
    (60) iterative_statement -> FOR expression TO expression . STEP expression compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    STEP            shift and go to state 167
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 166

state 147

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 168

state 148

    (26) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 169


state 149

    (11) variable_declaration -> LET IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 170
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 150

    (39) variable_declaration -> type_specifier IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 171
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 151

    (29) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 172

state 152

    (45) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DO              reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IF              reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LET             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    $end            reduce using rule 45 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)


state 153

    (52) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 173
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 154

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 155

    (7) arguments -> expression COMMA arguments .

    RIGHT_PAREN     reduce using rule 7 (arguments -> expression COMMA arguments .)


state 156

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .

    FUNCTION        reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    STRUCT          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    PUT             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    DO              reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    WHILE           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    FOR             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    IF              reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LOG             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LET             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    MINUS           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    NOT             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_BOOL       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_INT        reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_CHAR       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_DOUBLE     reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_STRING     reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    INTEGER         reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    STRING          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TRUE            reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    FALSE           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    $end            reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)


state 157

    (12) variable_declaration_list -> variable_declaration variable_declaration_list .

    RIGHT_BRACE     reduce using rule 12 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 158

    (27) assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DO              reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LET             reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_PAREN     reduce using rule 27 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)


state 159

    (75) expression -> expression IS GREATER THAN term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    NOT             reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    EXP             reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    GTE             reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    LTE             reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    IS              reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    GT              reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    LT              reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    EQUALS          reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    OR              reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    AND             reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    PLUS            reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    MINUS           reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    RIGHT_PAREN     reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    IN              reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    TO              reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    COMMA           reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    STEP            reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    LEFT_BRACE      reduce using rule 75 (expression -> expression IS GREATER THAN term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 160

    (76) expression -> expression IS LESS THAN term .
    (35) term -> term . PRODUCT factor
    (49) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 76 (expression -> expression IS LESS THAN term .)
    NOT             reduce using rule 76 (expression -> expression IS LESS THAN term .)
    EXP             reduce using rule 76 (expression -> expression IS LESS THAN term .)
    GTE             reduce using rule 76 (expression -> expression IS LESS THAN term .)
    LTE             reduce using rule 76 (expression -> expression IS LESS THAN term .)
    IS              reduce using rule 76 (expression -> expression IS LESS THAN term .)
    GT              reduce using rule 76 (expression -> expression IS LESS THAN term .)
    LT              reduce using rule 76 (expression -> expression IS LESS THAN term .)
    EQUALS          reduce using rule 76 (expression -> expression IS LESS THAN term .)
    OR              reduce using rule 76 (expression -> expression IS LESS THAN term .)
    AND             reduce using rule 76 (expression -> expression IS LESS THAN term .)
    PLUS            reduce using rule 76 (expression -> expression IS LESS THAN term .)
    MINUS           reduce using rule 76 (expression -> expression IS LESS THAN term .)
    RIGHT_PAREN     reduce using rule 76 (expression -> expression IS LESS THAN term .)
    IN              reduce using rule 76 (expression -> expression IS LESS THAN term .)
    TO              reduce using rule 76 (expression -> expression IS LESS THAN term .)
    COMMA           reduce using rule 76 (expression -> expression IS LESS THAN term .)
    STEP            reduce using rule 76 (expression -> expression IS LESS THAN term .)
    LEFT_BRACE      reduce using rule 76 (expression -> expression IS LESS THAN term .)
    PRODUCT         shift and go to state 84
    DIVIDE          shift and go to state 85


state 161

    (23) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression . RIGHT_PAREN
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 174
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 162

    (24) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 24 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 163

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression . RIGHT_PAREN compound_statement
    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression . STEP expression RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 175
    STEP            shift and go to state 176
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 164

    (71) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression . SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression . SEMICOLON expression RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 177
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 165

    (67) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON . assignment_statement RIGHT_PAREN compound_statement
    (69) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON . expression RIGHT_PAREN compound_statement
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 180
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 178
    assignment_statement           shift and go to state 179
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 166

    (54) iterative_statement -> FOR expression TO expression compound_statement .

    FUNCTION        reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRUCT          reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    PUT             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    IDENTIFIER      reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    SEMICOLON       reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    DO              reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    WHILE           reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    FOR             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    IF              reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_BRACE      reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LOG             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LET             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    MINUS           reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    NOT             reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_BOOL       reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_INT        reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_CHAR       reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_STRING     reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_PAREN      reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    DOUBLE          reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    INTEGER         reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRING          reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    TRUE            reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    FALSE           reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    $end            reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)
    RIGHT_BRACE     reduce using rule 54 (iterative_statement -> FOR expression TO expression compound_statement .)


state 167

    (60) iterative_statement -> FOR expression TO expression STEP . expression compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 181
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 168

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .
    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE conditional_statement

    ELSE            shift and go to state 182
    FUNCTION        reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 169

    (26) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 26 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 170

    (11) variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 11 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)


state 171

    (39) variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 39 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)


state 172

    (29) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DO              reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IF              reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LET             reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    $end            reduce using rule 29 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)


state 173

    (52) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_PAREN     reduce using rule 52 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)


state 174

    (23) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .

    FUNCTION        reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRUCT          reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    PUT             reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IDENTIFIER      reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DO              reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    WHILE           reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FOR             reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IF              reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LOG             reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LET             reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_BOOL       reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_INT        reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_CHAR       reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_DOUBLE     reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_STRING     reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DOUBLE          reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    INTEGER         reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRING          reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TRUE            reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FALSE           reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    $end            reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 23 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)


state 175

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 183

state 176

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP . expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    IDENTIFIER      shift and go to state 55
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 184
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 177

    (71) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON . assignment_statement RIGHT_PAREN compound_statement
    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON . expression RIGHT_PAREN compound_statement
    (27) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (41) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (52) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (47) expression -> . IDENTIFIER DECREMENT
    (56) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (68) expression -> . NOT term
    (70) expression -> . expression EXP term
    (72) expression -> . expression GTE term
    (74) expression -> . expression LTE term
    (75) expression -> . expression IS GREATER THAN term
    (76) expression -> . expression IS LESS THAN term
    (77) expression -> . expression GT term
    (78) expression -> . expression LT term
    (79) expression -> . expression IS term
    (80) expression -> . expression EQUALS term
    (81) expression -> . expression OR term
    (82) expression -> . expression AND term
    (83) expression -> . expression PLUS term
    (84) expression -> . expression MINUS term
    (85) expression -> . term
    (35) term -> . term PRODUCT factor
    (49) term -> . term DIVIDE factor
    (57) term -> . factor
    (34) factor -> . literal
    (48) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (44) literal -> . IDENTIFIER DOT IDENTIFIER
    (55) literal -> . IDENTIFIER
    (61) literal -> . DOUBLE
    (62) literal -> . INTEGER
    (63) literal -> . STRING
    (64) literal -> . TRUE
    (65) literal -> . FALSE

    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 180
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 185
    assignment_statement           shift and go to state 186
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 178

    (69) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression . RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 187
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 179

    (67) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 188


state 180

    (41) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (52) assignment_statement -> IDENTIFIER . DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> IDENTIFIER . INCREMENT
    (47) expression -> IDENTIFIER . DECREMENT
    (44) literal -> IDENTIFIER . DOT IDENTIFIER
    (55) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 49
    DOT             shift and go to state 50
    INCREMENT       shift and go to state 52
    DECREMENT       shift and go to state 53
    PRODUCT         reduce using rule 55 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 55 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 55 (literal -> IDENTIFIER .)
    NOT             reduce using rule 55 (literal -> IDENTIFIER .)
    EXP             reduce using rule 55 (literal -> IDENTIFIER .)
    GTE             reduce using rule 55 (literal -> IDENTIFIER .)
    LTE             reduce using rule 55 (literal -> IDENTIFIER .)
    IS              reduce using rule 55 (literal -> IDENTIFIER .)
    GT              reduce using rule 55 (literal -> IDENTIFIER .)
    LT              reduce using rule 55 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 55 (literal -> IDENTIFIER .)
    OR              reduce using rule 55 (literal -> IDENTIFIER .)
    AND             reduce using rule 55 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 55 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 55 (literal -> IDENTIFIER .)


state 181

    (60) iterative_statement -> FOR expression TO expression STEP expression . compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 189

state 182

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . compound_statement
    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . conditional_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (50) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement

    LEFT_BRACE      shift and go to state 19
    IF              shift and go to state 26

    compound_statement             shift and go to state 190
    conditional_statement          shift and go to state 191

state 183

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)


state 184

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression . RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 192
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 185

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression . RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (70) expression -> expression . EXP term
    (72) expression -> expression . GTE term
    (74) expression -> expression . LTE term
    (75) expression -> expression . IS GREATER THAN term
    (76) expression -> expression . IS LESS THAN term
    (77) expression -> expression . GT term
    (78) expression -> expression . LT term
    (79) expression -> expression . IS term
    (80) expression -> expression . EQUALS term
    (81) expression -> expression . OR term
    (82) expression -> expression . AND term
    (83) expression -> expression . PLUS term
    (84) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 193
    NOT             shift and go to state 62
    EXP             shift and go to state 63
    GTE             shift and go to state 64
    LTE             shift and go to state 65
    IS              shift and go to state 66
    GT              shift and go to state 67
    LT              shift and go to state 68
    EQUALS          shift and go to state 69
    OR              shift and go to state 70
    AND             shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 186

    (71) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 194


state 187

    (69) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 195

state 188

    (67) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 196

state 189

    (60) iterative_statement -> FOR expression TO expression STEP expression compound_statement .

    FUNCTION        reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRUCT          reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    PUT             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IDENTIFIER      reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    SEMICOLON       reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DO              reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    WHILE           reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FOR             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IF              reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_BRACE      reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LOG             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LET             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    MINUS           reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    NOT             reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_BOOL       reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_INT        reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_CHAR       reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_STRING     reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_PAREN      reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DOUBLE          reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    INTEGER         reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRING          reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TRUE            reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FALSE           reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    $end            reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    RIGHT_BRACE     reduce using rule 60 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)


state 190

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .

    FUNCTION        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRUCT          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    PUT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IDENTIFIER      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    SEMICOLON       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DO              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FOR             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IF              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_BRACE      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LOG             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LET             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    MINUS           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    NOT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_BOOL       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_INT        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_CHAR       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_DOUBLE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_STRING     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_PAREN      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DOUBLE          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    INTEGER         reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRING          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TRUE            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FALSE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    $end            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    RIGHT_BRACE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)


state 191

    (50) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .

    FUNCTION        reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    STRUCT          reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    PUT             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    IDENTIFIER      reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    SEMICOLON       reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    DO              reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    WHILE           reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    FOR             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    IF              reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LEFT_BRACE      reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LOG             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LET             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    MINUS           reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    NOT             reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_BOOL       reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_INT        reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_CHAR       reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_DOUBLE     reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_STRING     reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LEFT_PAREN      reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    DOUBLE          reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    INTEGER         reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    STRING          reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TRUE            reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    FALSE           reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    $end            reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    RIGHT_BRACE     reduce using rule 50 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)


state 192

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 197

state 193

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 198

state 194

    (71) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN . compound_statement
    (28) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 199

state 195

    (69) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 69 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)


state 196

    (67) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DO              reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IF              reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LET             reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    $end            reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 67 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)


state 197

    (43) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 43 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)


state 198

    (73) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 73 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)


state 199

    (71) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DO              reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IF              reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LET             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    $end            reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 71 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)

