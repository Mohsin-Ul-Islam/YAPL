Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    MODULUS
    OBJECT
    RETURN
    SKIP

Grammar

Rule 0     S' -> program
Rule 1     type_specifier -> TYPE_BOOL
Rule 2     type_specifier -> TYPE_INT
Rule 3     type_specifier -> TYPE_CHAR
Rule 4     type_specifier -> TYPE_DOUBLE
Rule 5     type_specifier -> TYPE_STRING
Rule 6     empty -> <empty>
Rule 7     arguments -> expression COMMA arguments
Rule 8     function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
Rule 9     conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
Rule 10    struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
Rule 11    variable_declaration_list -> variable_declaration variable_declaration_list
Rule 12    expression_statement -> expression SEMICOLON
Rule 13    expression_statement -> SEMICOLON
Rule 14    statement -> assignment_statement
Rule 15    statement -> expression_statement
Rule 16    statement -> iterative_statement
Rule 17    statement -> conditional_statement
Rule 18    statement -> compound_statement
Rule 19    statement -> print_statement
Rule 20    statement -> function_call
Rule 21    statement -> variable_declaration
Rule 22    iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
Rule 23    iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 24    statement_list -> statement statement_list
Rule 25    print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 26    assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON
Rule 27    compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE
Rule 28    function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
Rule 29    declaration_list -> statement declaration_list
Rule 30    variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON
Rule 31    iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
Rule 32    program -> declaration_list
Rule 33    expression -> IDENTIFIER INCREMENT
Rule 34    factor -> literal
Rule 35    term -> term PRODUCT factor
Rule 36    arguments -> expression
Rule 37    function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
Rule 38    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement
Rule 39    variable_declaration_list -> empty
Rule 40    iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
Rule 41    iterative_statement -> WHILE expression compound_statement
Rule 42    assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 43    declaration_list -> function_declaration declaration_list
Rule 44    variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON
Rule 45    iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
Rule 46    literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
Rule 47    function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
Rule 48    statement_list -> empty
Rule 49    expression -> IDENTIFIER DECREMENT
Rule 50    factor -> LEFT_PAREN expression RIGHT_PAREN
Rule 51    term -> term DIVIDE factor
Rule 52    conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
Rule 53    iterative_statement -> DO compound_statement WHILE expression
Rule 54    assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
Rule 55    declaration_list -> struct_declaration declaration_list
Rule 56    variable_declaration -> type_specifier IDENTIFIER SEMICOLON
Rule 57    iterative_statement -> FOR expression TO expression compound_statement
Rule 58    literal -> IDENTIFIER DOT IDENTIFIER
Rule 59    expression -> MINUS term
Rule 60    term -> factor
Rule 61    iterative_statement -> DO compound_statement WHILE expression SEMICOLON
Rule 62    declaration_list -> empty
Rule 63    variable_declaration -> LET IDENTIFIER SEMICOLON
Rule 64    iterative_statement -> FOR expression TO expression STEP expression compound_statement
Rule 65    literal -> IDENTIFIER
Rule 66    expression -> expression NOT ASSIGN term
Rule 67    variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON
Rule 68    iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
Rule 69    literal -> DOUBLE
Rule 70    literal -> INTEGER
Rule 71    literal -> STRING
Rule 72    literal -> TRUE
Rule 73    literal -> FALSE
Rule 74    expression -> NOT term
Rule 75    iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
Rule 76    expression -> expression EXP term
Rule 77    iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
Rule 78    expression -> expression GTE term
Rule 79    iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
Rule 80    expression -> expression LTE term
Rule 81    expression -> expression IS GREATER THAN term
Rule 82    expression -> expression IS LESS THAN term
Rule 83    expression -> expression GT term
Rule 84    expression -> expression LT term
Rule 85    expression -> expression IS term
Rule 86    expression -> expression EQUALS term
Rule 87    expression -> expression OR term
Rule 88    expression -> expression AND term
Rule 89    expression -> expression PLUS term
Rule 90    expression -> expression MINUS term
Rule 91    expression -> term

Terminals, with rules where they appear

AND                  : 88
ASSIGN               : 30 42 44 54 66
BREAK                : 
COMMA                : 7
DECREMENT            : 49
DIVIDE               : 51
DO                   : 22 40 53 61
DOT                  : 54 58
DOUBLE               : 69
ELSE                 : 9 52
EQUALS               : 86
EXP                  : 76
FALSE                : 73
FOR                  : 31 45 57 64 68 75 77 79
FUNCTION             : 28 47
GREATER              : 81
GT                   : 83
GTE                  : 78
IDENTIFIER           : 8 10 26 28 30 33 37 42 44 46 46 47 49 54 54 56 58 58 63 65 67 67
IF                   : 9 38 52
IN                   : 26
INCREMENT            : 33
INTEGER              : 70
IS                   : 81 82 85
LEFT_BRACE           : 10 27
LEFT_BRACKET         : 46
LEFT_PAREN           : 8 9 22 23 25 28 31 37 38 40 45 47 50 52 68 75 77 79
LESS                 : 82
LET                  : 30 63
LOG                  : 25
LT                   : 84
LTE                  : 80
MINUS                : 59 90
MODULUS              : 
NOT                  : 66 74
OBJECT               : 
OR                   : 87
PLUS                 : 89
PRODUCT              : 35
PUT                  : 26
QUOTE                : 46 46
RETURN               : 
RIGHT_BRACE          : 10 27
RIGHT_BRACKET        : 46
RIGHT_PAREN          : 8 9 22 23 25 28 31 37 38 40 45 47 50 52 68 75 77 79
SEMICOLON            : 8 12 13 25 26 30 37 40 42 44 54 56 61 63 67 68 75 77 77 79 79
SKIP                 : 
STEP                 : 45 64
STRING               : 71
STRUCT               : 10
THAN                 : 81 82
TO                   : 31 45 57 64
TRUE                 : 72
TYPE_BOOL            : 1
TYPE_CHAR            : 3
TYPE_DOUBLE          : 4
TYPE_INT             : 2
TYPE_STRING          : 5
WHILE                : 22 23 40 41 53 61
error                : 

Nonterminals, with rules where they appear

arguments            : 7 25 28 37
assignment_statement : 14 68 77
compound_statement   : 9 9 18 22 23 28 31 38 40 41 45 47 52 53 57 61 64 68 75 77 79
conditional_statement : 17 52
declaration_list     : 29 32 43 55
empty                : 39 48 62
expression           : 7 9 12 22 23 26 30 31 31 36 38 40 41 42 44 45 45 45 50 52 53 54 57 57 61 64 64 64 66 68 75 75 76 77 77 78 79 79 79 80 81 82 83 84 85 86 87 88 89 90
expression_statement : 15
factor               : 35 51 60
function_call        : 20
function_declaration : 43
iterative_statement  : 16
literal              : 34
print_statement      : 19
program              : 0
statement            : 24 29
statement_list       : 24 27
struct_declaration   : 55
term                 : 35 51 59 66 74 76 78 80 81 82 83 84 85 86 87 88 89 90 91
type_specifier       : 44 56
variable_declaration : 11 21 68 75
variable_declaration_list : 10 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (32) program -> . declaration_list
    (29) declaration_list -> . statement declaration_list
    (43) declaration_list -> . function_declaration declaration_list
    (55) declaration_list -> . struct_declaration declaration_list
    (62) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (47) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (40) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (41) iterative_statement -> . WHILE expression compound_statement
    (45) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (53) iterative_statement -> . DO compound_statement WHILE expression
    (57) iterative_statement -> . FOR expression TO expression compound_statement
    (61) iterative_statement -> . DO compound_statement WHILE expression SEMICOLON
    (64) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (68) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    statement                      shift and go to state 3
    function_declaration           shift and go to state 4
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 1

    (0) S' -> program .



state 2

    (32) program -> declaration_list .

    $end            reduce using rule 32 (program -> declaration_list .)


state 3

    (29) declaration_list -> statement . declaration_list
    (29) declaration_list -> . statement declaration_list
    (43) declaration_list -> . function_declaration declaration_list
    (55) declaration_list -> . struct_declaration declaration_list
    (62) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (47) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (40) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (41) iterative_statement -> . WHILE expression compound_statement
    (45) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (53) iterative_statement -> . DO compound_statement WHILE expression
    (57) iterative_statement -> . FOR expression TO expression compound_statement
    (61) iterative_statement -> . DO compound_statement WHILE expression SEMICOLON
    (64) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (68) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement                      shift and go to state 3
    declaration_list               shift and go to state 45
    function_declaration           shift and go to state 4
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 4

    (43) declaration_list -> function_declaration . declaration_list
    (29) declaration_list -> . statement declaration_list
    (43) declaration_list -> . function_declaration declaration_list
    (55) declaration_list -> . struct_declaration declaration_list
    (62) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (47) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (40) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (41) iterative_statement -> . WHILE expression compound_statement
    (45) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (53) iterative_statement -> . DO compound_statement WHILE expression
    (57) iterative_statement -> . FOR expression TO expression compound_statement
    (61) iterative_statement -> . DO compound_statement WHILE expression SEMICOLON
    (64) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (68) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    function_declaration           shift and go to state 4
    declaration_list               shift and go to state 46
    statement                      shift and go to state 3
    struct_declaration             shift and go to state 5
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 5

    (55) declaration_list -> struct_declaration . declaration_list
    (29) declaration_list -> . statement declaration_list
    (43) declaration_list -> . function_declaration declaration_list
    (55) declaration_list -> . struct_declaration declaration_list
    (62) declaration_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (28) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (47) function_declaration -> . FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement
    (10) struct_declaration -> . STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (40) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (41) iterative_statement -> . WHILE expression compound_statement
    (45) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (53) iterative_statement -> . DO compound_statement WHILE expression
    (57) iterative_statement -> . FOR expression TO expression compound_statement
    (61) iterative_statement -> . DO compound_statement WHILE expression SEMICOLON
    (64) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (68) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    FUNCTION        shift and go to state 15
    STRUCT          shift and go to state 18
    $end            reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    struct_declaration             shift and go to state 5
    declaration_list               shift and go to state 47
    statement                      shift and go to state 3
    function_declaration           shift and go to state 4
    empty                          shift and go to state 6
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 6

    (62) declaration_list -> empty .

    $end            reduce using rule 62 (declaration_list -> empty .)


state 7

    (14) statement -> assignment_statement .

    FUNCTION        reduce using rule 14 (statement -> assignment_statement .)
    STRUCT          reduce using rule 14 (statement -> assignment_statement .)
    PUT             reduce using rule 14 (statement -> assignment_statement .)
    IDENTIFIER      reduce using rule 14 (statement -> assignment_statement .)
    SEMICOLON       reduce using rule 14 (statement -> assignment_statement .)
    DO              reduce using rule 14 (statement -> assignment_statement .)
    WHILE           reduce using rule 14 (statement -> assignment_statement .)
    FOR             reduce using rule 14 (statement -> assignment_statement .)
    IF              reduce using rule 14 (statement -> assignment_statement .)
    LEFT_BRACE      reduce using rule 14 (statement -> assignment_statement .)
    LOG             reduce using rule 14 (statement -> assignment_statement .)
    LET             reduce using rule 14 (statement -> assignment_statement .)
    MINUS           reduce using rule 14 (statement -> assignment_statement .)
    NOT             reduce using rule 14 (statement -> assignment_statement .)
    TYPE_BOOL       reduce using rule 14 (statement -> assignment_statement .)
    TYPE_INT        reduce using rule 14 (statement -> assignment_statement .)
    TYPE_CHAR       reduce using rule 14 (statement -> assignment_statement .)
    TYPE_DOUBLE     reduce using rule 14 (statement -> assignment_statement .)
    TYPE_STRING     reduce using rule 14 (statement -> assignment_statement .)
    LEFT_PAREN      reduce using rule 14 (statement -> assignment_statement .)
    DOUBLE          reduce using rule 14 (statement -> assignment_statement .)
    INTEGER         reduce using rule 14 (statement -> assignment_statement .)
    STRING          reduce using rule 14 (statement -> assignment_statement .)
    TRUE            reduce using rule 14 (statement -> assignment_statement .)
    FALSE           reduce using rule 14 (statement -> assignment_statement .)
    $end            reduce using rule 14 (statement -> assignment_statement .)
    RIGHT_BRACE     reduce using rule 14 (statement -> assignment_statement .)


state 8

    (15) statement -> expression_statement .

    FUNCTION        reduce using rule 15 (statement -> expression_statement .)
    STRUCT          reduce using rule 15 (statement -> expression_statement .)
    PUT             reduce using rule 15 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 15 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 15 (statement -> expression_statement .)
    DO              reduce using rule 15 (statement -> expression_statement .)
    WHILE           reduce using rule 15 (statement -> expression_statement .)
    FOR             reduce using rule 15 (statement -> expression_statement .)
    IF              reduce using rule 15 (statement -> expression_statement .)
    LEFT_BRACE      reduce using rule 15 (statement -> expression_statement .)
    LOG             reduce using rule 15 (statement -> expression_statement .)
    LET             reduce using rule 15 (statement -> expression_statement .)
    MINUS           reduce using rule 15 (statement -> expression_statement .)
    NOT             reduce using rule 15 (statement -> expression_statement .)
    TYPE_BOOL       reduce using rule 15 (statement -> expression_statement .)
    TYPE_INT        reduce using rule 15 (statement -> expression_statement .)
    TYPE_CHAR       reduce using rule 15 (statement -> expression_statement .)
    TYPE_DOUBLE     reduce using rule 15 (statement -> expression_statement .)
    TYPE_STRING     reduce using rule 15 (statement -> expression_statement .)
    LEFT_PAREN      reduce using rule 15 (statement -> expression_statement .)
    DOUBLE          reduce using rule 15 (statement -> expression_statement .)
    INTEGER         reduce using rule 15 (statement -> expression_statement .)
    STRING          reduce using rule 15 (statement -> expression_statement .)
    TRUE            reduce using rule 15 (statement -> expression_statement .)
    FALSE           reduce using rule 15 (statement -> expression_statement .)
    $end            reduce using rule 15 (statement -> expression_statement .)
    RIGHT_BRACE     reduce using rule 15 (statement -> expression_statement .)


state 9

    (16) statement -> iterative_statement .

    FUNCTION        reduce using rule 16 (statement -> iterative_statement .)
    STRUCT          reduce using rule 16 (statement -> iterative_statement .)
    PUT             reduce using rule 16 (statement -> iterative_statement .)
    IDENTIFIER      reduce using rule 16 (statement -> iterative_statement .)
    SEMICOLON       reduce using rule 16 (statement -> iterative_statement .)
    DO              reduce using rule 16 (statement -> iterative_statement .)
    WHILE           reduce using rule 16 (statement -> iterative_statement .)
    FOR             reduce using rule 16 (statement -> iterative_statement .)
    IF              reduce using rule 16 (statement -> iterative_statement .)
    LEFT_BRACE      reduce using rule 16 (statement -> iterative_statement .)
    LOG             reduce using rule 16 (statement -> iterative_statement .)
    LET             reduce using rule 16 (statement -> iterative_statement .)
    MINUS           reduce using rule 16 (statement -> iterative_statement .)
    NOT             reduce using rule 16 (statement -> iterative_statement .)
    TYPE_BOOL       reduce using rule 16 (statement -> iterative_statement .)
    TYPE_INT        reduce using rule 16 (statement -> iterative_statement .)
    TYPE_CHAR       reduce using rule 16 (statement -> iterative_statement .)
    TYPE_DOUBLE     reduce using rule 16 (statement -> iterative_statement .)
    TYPE_STRING     reduce using rule 16 (statement -> iterative_statement .)
    LEFT_PAREN      reduce using rule 16 (statement -> iterative_statement .)
    DOUBLE          reduce using rule 16 (statement -> iterative_statement .)
    INTEGER         reduce using rule 16 (statement -> iterative_statement .)
    STRING          reduce using rule 16 (statement -> iterative_statement .)
    TRUE            reduce using rule 16 (statement -> iterative_statement .)
    FALSE           reduce using rule 16 (statement -> iterative_statement .)
    $end            reduce using rule 16 (statement -> iterative_statement .)
    RIGHT_BRACE     reduce using rule 16 (statement -> iterative_statement .)


state 10

    (17) statement -> conditional_statement .

    FUNCTION        reduce using rule 17 (statement -> conditional_statement .)
    STRUCT          reduce using rule 17 (statement -> conditional_statement .)
    PUT             reduce using rule 17 (statement -> conditional_statement .)
    IDENTIFIER      reduce using rule 17 (statement -> conditional_statement .)
    SEMICOLON       reduce using rule 17 (statement -> conditional_statement .)
    DO              reduce using rule 17 (statement -> conditional_statement .)
    WHILE           reduce using rule 17 (statement -> conditional_statement .)
    FOR             reduce using rule 17 (statement -> conditional_statement .)
    IF              reduce using rule 17 (statement -> conditional_statement .)
    LEFT_BRACE      reduce using rule 17 (statement -> conditional_statement .)
    LOG             reduce using rule 17 (statement -> conditional_statement .)
    LET             reduce using rule 17 (statement -> conditional_statement .)
    MINUS           reduce using rule 17 (statement -> conditional_statement .)
    NOT             reduce using rule 17 (statement -> conditional_statement .)
    TYPE_BOOL       reduce using rule 17 (statement -> conditional_statement .)
    TYPE_INT        reduce using rule 17 (statement -> conditional_statement .)
    TYPE_CHAR       reduce using rule 17 (statement -> conditional_statement .)
    TYPE_DOUBLE     reduce using rule 17 (statement -> conditional_statement .)
    TYPE_STRING     reduce using rule 17 (statement -> conditional_statement .)
    LEFT_PAREN      reduce using rule 17 (statement -> conditional_statement .)
    DOUBLE          reduce using rule 17 (statement -> conditional_statement .)
    INTEGER         reduce using rule 17 (statement -> conditional_statement .)
    STRING          reduce using rule 17 (statement -> conditional_statement .)
    TRUE            reduce using rule 17 (statement -> conditional_statement .)
    FALSE           reduce using rule 17 (statement -> conditional_statement .)
    $end            reduce using rule 17 (statement -> conditional_statement .)
    RIGHT_BRACE     reduce using rule 17 (statement -> conditional_statement .)


state 11

    (18) statement -> compound_statement .

    FUNCTION        reduce using rule 18 (statement -> compound_statement .)
    STRUCT          reduce using rule 18 (statement -> compound_statement .)
    PUT             reduce using rule 18 (statement -> compound_statement .)
    IDENTIFIER      reduce using rule 18 (statement -> compound_statement .)
    SEMICOLON       reduce using rule 18 (statement -> compound_statement .)
    DO              reduce using rule 18 (statement -> compound_statement .)
    WHILE           reduce using rule 18 (statement -> compound_statement .)
    FOR             reduce using rule 18 (statement -> compound_statement .)
    IF              reduce using rule 18 (statement -> compound_statement .)
    LEFT_BRACE      reduce using rule 18 (statement -> compound_statement .)
    LOG             reduce using rule 18 (statement -> compound_statement .)
    LET             reduce using rule 18 (statement -> compound_statement .)
    MINUS           reduce using rule 18 (statement -> compound_statement .)
    NOT             reduce using rule 18 (statement -> compound_statement .)
    TYPE_BOOL       reduce using rule 18 (statement -> compound_statement .)
    TYPE_INT        reduce using rule 18 (statement -> compound_statement .)
    TYPE_CHAR       reduce using rule 18 (statement -> compound_statement .)
    TYPE_DOUBLE     reduce using rule 18 (statement -> compound_statement .)
    TYPE_STRING     reduce using rule 18 (statement -> compound_statement .)
    LEFT_PAREN      reduce using rule 18 (statement -> compound_statement .)
    DOUBLE          reduce using rule 18 (statement -> compound_statement .)
    INTEGER         reduce using rule 18 (statement -> compound_statement .)
    STRING          reduce using rule 18 (statement -> compound_statement .)
    TRUE            reduce using rule 18 (statement -> compound_statement .)
    FALSE           reduce using rule 18 (statement -> compound_statement .)
    $end            reduce using rule 18 (statement -> compound_statement .)
    RIGHT_BRACE     reduce using rule 18 (statement -> compound_statement .)


state 12

    (19) statement -> print_statement .

    FUNCTION        reduce using rule 19 (statement -> print_statement .)
    STRUCT          reduce using rule 19 (statement -> print_statement .)
    PUT             reduce using rule 19 (statement -> print_statement .)
    IDENTIFIER      reduce using rule 19 (statement -> print_statement .)
    SEMICOLON       reduce using rule 19 (statement -> print_statement .)
    DO              reduce using rule 19 (statement -> print_statement .)
    WHILE           reduce using rule 19 (statement -> print_statement .)
    FOR             reduce using rule 19 (statement -> print_statement .)
    IF              reduce using rule 19 (statement -> print_statement .)
    LEFT_BRACE      reduce using rule 19 (statement -> print_statement .)
    LOG             reduce using rule 19 (statement -> print_statement .)
    LET             reduce using rule 19 (statement -> print_statement .)
    MINUS           reduce using rule 19 (statement -> print_statement .)
    NOT             reduce using rule 19 (statement -> print_statement .)
    TYPE_BOOL       reduce using rule 19 (statement -> print_statement .)
    TYPE_INT        reduce using rule 19 (statement -> print_statement .)
    TYPE_CHAR       reduce using rule 19 (statement -> print_statement .)
    TYPE_DOUBLE     reduce using rule 19 (statement -> print_statement .)
    TYPE_STRING     reduce using rule 19 (statement -> print_statement .)
    LEFT_PAREN      reduce using rule 19 (statement -> print_statement .)
    DOUBLE          reduce using rule 19 (statement -> print_statement .)
    INTEGER         reduce using rule 19 (statement -> print_statement .)
    STRING          reduce using rule 19 (statement -> print_statement .)
    TRUE            reduce using rule 19 (statement -> print_statement .)
    FALSE           reduce using rule 19 (statement -> print_statement .)
    $end            reduce using rule 19 (statement -> print_statement .)
    RIGHT_BRACE     reduce using rule 19 (statement -> print_statement .)


state 13

    (20) statement -> function_call .

    FUNCTION        reduce using rule 20 (statement -> function_call .)
    STRUCT          reduce using rule 20 (statement -> function_call .)
    PUT             reduce using rule 20 (statement -> function_call .)
    IDENTIFIER      reduce using rule 20 (statement -> function_call .)
    SEMICOLON       reduce using rule 20 (statement -> function_call .)
    DO              reduce using rule 20 (statement -> function_call .)
    WHILE           reduce using rule 20 (statement -> function_call .)
    FOR             reduce using rule 20 (statement -> function_call .)
    IF              reduce using rule 20 (statement -> function_call .)
    LEFT_BRACE      reduce using rule 20 (statement -> function_call .)
    LOG             reduce using rule 20 (statement -> function_call .)
    LET             reduce using rule 20 (statement -> function_call .)
    MINUS           reduce using rule 20 (statement -> function_call .)
    NOT             reduce using rule 20 (statement -> function_call .)
    TYPE_BOOL       reduce using rule 20 (statement -> function_call .)
    TYPE_INT        reduce using rule 20 (statement -> function_call .)
    TYPE_CHAR       reduce using rule 20 (statement -> function_call .)
    TYPE_DOUBLE     reduce using rule 20 (statement -> function_call .)
    TYPE_STRING     reduce using rule 20 (statement -> function_call .)
    LEFT_PAREN      reduce using rule 20 (statement -> function_call .)
    DOUBLE          reduce using rule 20 (statement -> function_call .)
    INTEGER         reduce using rule 20 (statement -> function_call .)
    STRING          reduce using rule 20 (statement -> function_call .)
    TRUE            reduce using rule 20 (statement -> function_call .)
    FALSE           reduce using rule 20 (statement -> function_call .)
    $end            reduce using rule 20 (statement -> function_call .)
    RIGHT_BRACE     reduce using rule 20 (statement -> function_call .)


state 14

    (21) statement -> variable_declaration .

    FUNCTION        reduce using rule 21 (statement -> variable_declaration .)
    STRUCT          reduce using rule 21 (statement -> variable_declaration .)
    PUT             reduce using rule 21 (statement -> variable_declaration .)
    IDENTIFIER      reduce using rule 21 (statement -> variable_declaration .)
    SEMICOLON       reduce using rule 21 (statement -> variable_declaration .)
    DO              reduce using rule 21 (statement -> variable_declaration .)
    WHILE           reduce using rule 21 (statement -> variable_declaration .)
    FOR             reduce using rule 21 (statement -> variable_declaration .)
    IF              reduce using rule 21 (statement -> variable_declaration .)
    LEFT_BRACE      reduce using rule 21 (statement -> variable_declaration .)
    LOG             reduce using rule 21 (statement -> variable_declaration .)
    LET             reduce using rule 21 (statement -> variable_declaration .)
    MINUS           reduce using rule 21 (statement -> variable_declaration .)
    NOT             reduce using rule 21 (statement -> variable_declaration .)
    TYPE_BOOL       reduce using rule 21 (statement -> variable_declaration .)
    TYPE_INT        reduce using rule 21 (statement -> variable_declaration .)
    TYPE_CHAR       reduce using rule 21 (statement -> variable_declaration .)
    TYPE_DOUBLE     reduce using rule 21 (statement -> variable_declaration .)
    TYPE_STRING     reduce using rule 21 (statement -> variable_declaration .)
    LEFT_PAREN      reduce using rule 21 (statement -> variable_declaration .)
    DOUBLE          reduce using rule 21 (statement -> variable_declaration .)
    INTEGER         reduce using rule 21 (statement -> variable_declaration .)
    STRING          reduce using rule 21 (statement -> variable_declaration .)
    TRUE            reduce using rule 21 (statement -> variable_declaration .)
    FALSE           reduce using rule 21 (statement -> variable_declaration .)
    $end            reduce using rule 21 (statement -> variable_declaration .)
    RIGHT_BRACE     reduce using rule 21 (statement -> variable_declaration .)


state 15

    (28) function_declaration -> FUNCTION . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (47) function_declaration -> FUNCTION . IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement

    IDENTIFIER      shift and go to state 48


state 16

    (42) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (54) assignment_statement -> IDENTIFIER . DOT IDENTIFIER ASSIGN expression SEMICOLON
    (8) function_call -> IDENTIFIER . LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (67) variable_declaration -> IDENTIFIER . IDENTIFIER SEMICOLON
    (33) expression -> IDENTIFIER . INCREMENT
    (49) expression -> IDENTIFIER . DECREMENT
    (46) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> IDENTIFIER . DOT IDENTIFIER
    (65) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 50
    DOT             shift and go to state 51
    LEFT_PAREN      shift and go to state 52
    IDENTIFIER      shift and go to state 49
    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    LEFT_BRACKET    shift and go to state 55
    PRODUCT         reduce using rule 65 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 65 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 65 (literal -> IDENTIFIER .)
    NOT             reduce using rule 65 (literal -> IDENTIFIER .)
    EXP             reduce using rule 65 (literal -> IDENTIFIER .)
    GTE             reduce using rule 65 (literal -> IDENTIFIER .)
    LTE             reduce using rule 65 (literal -> IDENTIFIER .)
    IS              reduce using rule 65 (literal -> IDENTIFIER .)
    GT              reduce using rule 65 (literal -> IDENTIFIER .)
    LT              reduce using rule 65 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 65 (literal -> IDENTIFIER .)
    OR              reduce using rule 65 (literal -> IDENTIFIER .)
    AND             reduce using rule 65 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 65 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 65 (literal -> IDENTIFIER .)


state 17

    (50) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 56
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 18

    (10) struct_declaration -> STRUCT . IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE

    IDENTIFIER      shift and go to state 58


state 19

    (27) compound_statement -> LEFT_BRACE . statement_list RIGHT_BRACE
    (24) statement_list -> . statement statement_list
    (48) statement_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (40) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (41) iterative_statement -> . WHILE expression compound_statement
    (45) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (53) iterative_statement -> . DO compound_statement WHILE expression
    (57) iterative_statement -> . FOR expression TO expression compound_statement
    (61) iterative_statement -> . DO compound_statement WHILE expression SEMICOLON
    (64) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (68) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement_list                 shift and go to state 59
    statement                      shift and go to state 60
    empty                          shift and go to state 61
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 20

    (26) assignment_statement -> PUT . expression IN IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 62
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 21

    (12) expression_statement -> expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 63
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 22

    (13) expression_statement -> SEMICOLON .

    FUNCTION        reduce using rule 13 (expression_statement -> SEMICOLON .)
    STRUCT          reduce using rule 13 (expression_statement -> SEMICOLON .)
    PUT             reduce using rule 13 (expression_statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (expression_statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 13 (expression_statement -> SEMICOLON .)
    DO              reduce using rule 13 (expression_statement -> SEMICOLON .)
    WHILE           reduce using rule 13 (expression_statement -> SEMICOLON .)
    FOR             reduce using rule 13 (expression_statement -> SEMICOLON .)
    IF              reduce using rule 13 (expression_statement -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 13 (expression_statement -> SEMICOLON .)
    LOG             reduce using rule 13 (expression_statement -> SEMICOLON .)
    LET             reduce using rule 13 (expression_statement -> SEMICOLON .)
    MINUS           reduce using rule 13 (expression_statement -> SEMICOLON .)
    NOT             reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_BOOL       reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_INT        reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_CHAR       reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 13 (expression_statement -> SEMICOLON .)
    TYPE_STRING     reduce using rule 13 (expression_statement -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 13 (expression_statement -> SEMICOLON .)
    DOUBLE          reduce using rule 13 (expression_statement -> SEMICOLON .)
    INTEGER         reduce using rule 13 (expression_statement -> SEMICOLON .)
    STRING          reduce using rule 13 (expression_statement -> SEMICOLON .)
    TRUE            reduce using rule 13 (expression_statement -> SEMICOLON .)
    FALSE           reduce using rule 13 (expression_statement -> SEMICOLON .)
    $end            reduce using rule 13 (expression_statement -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 13 (expression_statement -> SEMICOLON .)


state 23

    (22) iterative_statement -> DO . compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (40) iterative_statement -> DO . compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (53) iterative_statement -> DO . compound_statement WHILE expression
    (61) iterative_statement -> DO . compound_statement WHILE expression SEMICOLON
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 76

state 24

    (23) iterative_statement -> WHILE . LEFT_PAREN expression RIGHT_PAREN compound_statement
    (41) iterative_statement -> WHILE . expression compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 77
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 78
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 25

    (31) iterative_statement -> FOR . LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (45) iterative_statement -> FOR . LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (57) iterative_statement -> FOR . expression TO expression compound_statement
    (64) iterative_statement -> FOR . expression TO expression STEP expression compound_statement
    (68) iterative_statement -> FOR . LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR . LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> FOR . LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> FOR . LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 79
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 80
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 26

    (9) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> IF . LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement

    LEFT_PAREN      shift and go to state 81


state 27

    (25) print_statement -> LOG . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    LEFT_PAREN      shift and go to state 82


state 28

    (30) variable_declaration -> LET . IDENTIFIER ASSIGN expression SEMICOLON
    (63) variable_declaration -> LET . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 83


state 29

    (44) variable_declaration -> type_specifier . IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> type_specifier . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 84


state 30

    (59) expression -> MINUS . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 85
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 31

    (91) expression -> term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 91 (expression -> term .)
    NOT             reduce using rule 91 (expression -> term .)
    EXP             reduce using rule 91 (expression -> term .)
    GTE             reduce using rule 91 (expression -> term .)
    LTE             reduce using rule 91 (expression -> term .)
    IS              reduce using rule 91 (expression -> term .)
    GT              reduce using rule 91 (expression -> term .)
    LT              reduce using rule 91 (expression -> term .)
    EQUALS          reduce using rule 91 (expression -> term .)
    OR              reduce using rule 91 (expression -> term .)
    AND             reduce using rule 91 (expression -> term .)
    PLUS            reduce using rule 91 (expression -> term .)
    MINUS           reduce using rule 91 (expression -> term .)
    RIGHT_PAREN     reduce using rule 91 (expression -> term .)
    IN              reduce using rule 91 (expression -> term .)
    LEFT_BRACE      reduce using rule 91 (expression -> term .)
    TO              reduce using rule 91 (expression -> term .)
    COMMA           reduce using rule 91 (expression -> term .)
    FUNCTION        reduce using rule 91 (expression -> term .)
    STRUCT          reduce using rule 91 (expression -> term .)
    PUT             reduce using rule 91 (expression -> term .)
    IDENTIFIER      reduce using rule 91 (expression -> term .)
    DO              reduce using rule 91 (expression -> term .)
    WHILE           reduce using rule 91 (expression -> term .)
    FOR             reduce using rule 91 (expression -> term .)
    IF              reduce using rule 91 (expression -> term .)
    LOG             reduce using rule 91 (expression -> term .)
    LET             reduce using rule 91 (expression -> term .)
    TYPE_BOOL       reduce using rule 91 (expression -> term .)
    TYPE_INT        reduce using rule 91 (expression -> term .)
    TYPE_CHAR       reduce using rule 91 (expression -> term .)
    TYPE_DOUBLE     reduce using rule 91 (expression -> term .)
    TYPE_STRING     reduce using rule 91 (expression -> term .)
    LEFT_PAREN      reduce using rule 91 (expression -> term .)
    DOUBLE          reduce using rule 91 (expression -> term .)
    INTEGER         reduce using rule 91 (expression -> term .)
    STRING          reduce using rule 91 (expression -> term .)
    TRUE            reduce using rule 91 (expression -> term .)
    FALSE           reduce using rule 91 (expression -> term .)
    $end            reduce using rule 91 (expression -> term .)
    RIGHT_BRACE     reduce using rule 91 (expression -> term .)
    STEP            reduce using rule 91 (expression -> term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 32

    (74) expression -> NOT . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 89
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 33

    (1) type_specifier -> TYPE_BOOL .

    IDENTIFIER      reduce using rule 1 (type_specifier -> TYPE_BOOL .)


state 34

    (2) type_specifier -> TYPE_INT .

    IDENTIFIER      reduce using rule 2 (type_specifier -> TYPE_INT .)


state 35

    (3) type_specifier -> TYPE_CHAR .

    IDENTIFIER      reduce using rule 3 (type_specifier -> TYPE_CHAR .)


state 36

    (4) type_specifier -> TYPE_DOUBLE .

    IDENTIFIER      reduce using rule 4 (type_specifier -> TYPE_DOUBLE .)


state 37

    (5) type_specifier -> TYPE_STRING .

    IDENTIFIER      reduce using rule 5 (type_specifier -> TYPE_STRING .)


state 38

    (60) term -> factor .

    PRODUCT         reduce using rule 60 (term -> factor .)
    DIVIDE          reduce using rule 60 (term -> factor .)
    SEMICOLON       reduce using rule 60 (term -> factor .)
    NOT             reduce using rule 60 (term -> factor .)
    EXP             reduce using rule 60 (term -> factor .)
    GTE             reduce using rule 60 (term -> factor .)
    LTE             reduce using rule 60 (term -> factor .)
    IS              reduce using rule 60 (term -> factor .)
    GT              reduce using rule 60 (term -> factor .)
    LT              reduce using rule 60 (term -> factor .)
    EQUALS          reduce using rule 60 (term -> factor .)
    OR              reduce using rule 60 (term -> factor .)
    AND             reduce using rule 60 (term -> factor .)
    PLUS            reduce using rule 60 (term -> factor .)
    MINUS           reduce using rule 60 (term -> factor .)
    RIGHT_PAREN     reduce using rule 60 (term -> factor .)
    IN              reduce using rule 60 (term -> factor .)
    LEFT_BRACE      reduce using rule 60 (term -> factor .)
    TO              reduce using rule 60 (term -> factor .)
    COMMA           reduce using rule 60 (term -> factor .)
    FUNCTION        reduce using rule 60 (term -> factor .)
    STRUCT          reduce using rule 60 (term -> factor .)
    PUT             reduce using rule 60 (term -> factor .)
    IDENTIFIER      reduce using rule 60 (term -> factor .)
    DO              reduce using rule 60 (term -> factor .)
    WHILE           reduce using rule 60 (term -> factor .)
    FOR             reduce using rule 60 (term -> factor .)
    IF              reduce using rule 60 (term -> factor .)
    LOG             reduce using rule 60 (term -> factor .)
    LET             reduce using rule 60 (term -> factor .)
    TYPE_BOOL       reduce using rule 60 (term -> factor .)
    TYPE_INT        reduce using rule 60 (term -> factor .)
    TYPE_CHAR       reduce using rule 60 (term -> factor .)
    TYPE_DOUBLE     reduce using rule 60 (term -> factor .)
    TYPE_STRING     reduce using rule 60 (term -> factor .)
    LEFT_PAREN      reduce using rule 60 (term -> factor .)
    DOUBLE          reduce using rule 60 (term -> factor .)
    INTEGER         reduce using rule 60 (term -> factor .)
    STRING          reduce using rule 60 (term -> factor .)
    TRUE            reduce using rule 60 (term -> factor .)
    FALSE           reduce using rule 60 (term -> factor .)
    $end            reduce using rule 60 (term -> factor .)
    RIGHT_BRACE     reduce using rule 60 (term -> factor .)
    STEP            reduce using rule 60 (term -> factor .)


state 39

    (34) factor -> literal .

    PRODUCT         reduce using rule 34 (factor -> literal .)
    DIVIDE          reduce using rule 34 (factor -> literal .)
    SEMICOLON       reduce using rule 34 (factor -> literal .)
    NOT             reduce using rule 34 (factor -> literal .)
    EXP             reduce using rule 34 (factor -> literal .)
    GTE             reduce using rule 34 (factor -> literal .)
    LTE             reduce using rule 34 (factor -> literal .)
    IS              reduce using rule 34 (factor -> literal .)
    GT              reduce using rule 34 (factor -> literal .)
    LT              reduce using rule 34 (factor -> literal .)
    EQUALS          reduce using rule 34 (factor -> literal .)
    OR              reduce using rule 34 (factor -> literal .)
    AND             reduce using rule 34 (factor -> literal .)
    PLUS            reduce using rule 34 (factor -> literal .)
    MINUS           reduce using rule 34 (factor -> literal .)
    RIGHT_PAREN     reduce using rule 34 (factor -> literal .)
    IN              reduce using rule 34 (factor -> literal .)
    LEFT_BRACE      reduce using rule 34 (factor -> literal .)
    TO              reduce using rule 34 (factor -> literal .)
    COMMA           reduce using rule 34 (factor -> literal .)
    FUNCTION        reduce using rule 34 (factor -> literal .)
    STRUCT          reduce using rule 34 (factor -> literal .)
    PUT             reduce using rule 34 (factor -> literal .)
    IDENTIFIER      reduce using rule 34 (factor -> literal .)
    DO              reduce using rule 34 (factor -> literal .)
    WHILE           reduce using rule 34 (factor -> literal .)
    FOR             reduce using rule 34 (factor -> literal .)
    IF              reduce using rule 34 (factor -> literal .)
    LOG             reduce using rule 34 (factor -> literal .)
    LET             reduce using rule 34 (factor -> literal .)
    TYPE_BOOL       reduce using rule 34 (factor -> literal .)
    TYPE_INT        reduce using rule 34 (factor -> literal .)
    TYPE_CHAR       reduce using rule 34 (factor -> literal .)
    TYPE_DOUBLE     reduce using rule 34 (factor -> literal .)
    TYPE_STRING     reduce using rule 34 (factor -> literal .)
    LEFT_PAREN      reduce using rule 34 (factor -> literal .)
    DOUBLE          reduce using rule 34 (factor -> literal .)
    INTEGER         reduce using rule 34 (factor -> literal .)
    STRING          reduce using rule 34 (factor -> literal .)
    TRUE            reduce using rule 34 (factor -> literal .)
    FALSE           reduce using rule 34 (factor -> literal .)
    $end            reduce using rule 34 (factor -> literal .)
    RIGHT_BRACE     reduce using rule 34 (factor -> literal .)
    STEP            reduce using rule 34 (factor -> literal .)


state 40

    (69) literal -> DOUBLE .

    PRODUCT         reduce using rule 69 (literal -> DOUBLE .)
    DIVIDE          reduce using rule 69 (literal -> DOUBLE .)
    SEMICOLON       reduce using rule 69 (literal -> DOUBLE .)
    NOT             reduce using rule 69 (literal -> DOUBLE .)
    EXP             reduce using rule 69 (literal -> DOUBLE .)
    GTE             reduce using rule 69 (literal -> DOUBLE .)
    LTE             reduce using rule 69 (literal -> DOUBLE .)
    IS              reduce using rule 69 (literal -> DOUBLE .)
    GT              reduce using rule 69 (literal -> DOUBLE .)
    LT              reduce using rule 69 (literal -> DOUBLE .)
    EQUALS          reduce using rule 69 (literal -> DOUBLE .)
    OR              reduce using rule 69 (literal -> DOUBLE .)
    AND             reduce using rule 69 (literal -> DOUBLE .)
    PLUS            reduce using rule 69 (literal -> DOUBLE .)
    MINUS           reduce using rule 69 (literal -> DOUBLE .)
    RIGHT_PAREN     reduce using rule 69 (literal -> DOUBLE .)
    IN              reduce using rule 69 (literal -> DOUBLE .)
    LEFT_BRACE      reduce using rule 69 (literal -> DOUBLE .)
    TO              reduce using rule 69 (literal -> DOUBLE .)
    COMMA           reduce using rule 69 (literal -> DOUBLE .)
    FUNCTION        reduce using rule 69 (literal -> DOUBLE .)
    STRUCT          reduce using rule 69 (literal -> DOUBLE .)
    PUT             reduce using rule 69 (literal -> DOUBLE .)
    IDENTIFIER      reduce using rule 69 (literal -> DOUBLE .)
    DO              reduce using rule 69 (literal -> DOUBLE .)
    WHILE           reduce using rule 69 (literal -> DOUBLE .)
    FOR             reduce using rule 69 (literal -> DOUBLE .)
    IF              reduce using rule 69 (literal -> DOUBLE .)
    LOG             reduce using rule 69 (literal -> DOUBLE .)
    LET             reduce using rule 69 (literal -> DOUBLE .)
    TYPE_BOOL       reduce using rule 69 (literal -> DOUBLE .)
    TYPE_INT        reduce using rule 69 (literal -> DOUBLE .)
    TYPE_CHAR       reduce using rule 69 (literal -> DOUBLE .)
    TYPE_DOUBLE     reduce using rule 69 (literal -> DOUBLE .)
    TYPE_STRING     reduce using rule 69 (literal -> DOUBLE .)
    LEFT_PAREN      reduce using rule 69 (literal -> DOUBLE .)
    DOUBLE          reduce using rule 69 (literal -> DOUBLE .)
    INTEGER         reduce using rule 69 (literal -> DOUBLE .)
    STRING          reduce using rule 69 (literal -> DOUBLE .)
    TRUE            reduce using rule 69 (literal -> DOUBLE .)
    FALSE           reduce using rule 69 (literal -> DOUBLE .)
    $end            reduce using rule 69 (literal -> DOUBLE .)
    RIGHT_BRACE     reduce using rule 69 (literal -> DOUBLE .)
    STEP            reduce using rule 69 (literal -> DOUBLE .)


state 41

    (70) literal -> INTEGER .

    PRODUCT         reduce using rule 70 (literal -> INTEGER .)
    DIVIDE          reduce using rule 70 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 70 (literal -> INTEGER .)
    NOT             reduce using rule 70 (literal -> INTEGER .)
    EXP             reduce using rule 70 (literal -> INTEGER .)
    GTE             reduce using rule 70 (literal -> INTEGER .)
    LTE             reduce using rule 70 (literal -> INTEGER .)
    IS              reduce using rule 70 (literal -> INTEGER .)
    GT              reduce using rule 70 (literal -> INTEGER .)
    LT              reduce using rule 70 (literal -> INTEGER .)
    EQUALS          reduce using rule 70 (literal -> INTEGER .)
    OR              reduce using rule 70 (literal -> INTEGER .)
    AND             reduce using rule 70 (literal -> INTEGER .)
    PLUS            reduce using rule 70 (literal -> INTEGER .)
    MINUS           reduce using rule 70 (literal -> INTEGER .)
    RIGHT_PAREN     reduce using rule 70 (literal -> INTEGER .)
    IN              reduce using rule 70 (literal -> INTEGER .)
    LEFT_BRACE      reduce using rule 70 (literal -> INTEGER .)
    TO              reduce using rule 70 (literal -> INTEGER .)
    COMMA           reduce using rule 70 (literal -> INTEGER .)
    FUNCTION        reduce using rule 70 (literal -> INTEGER .)
    STRUCT          reduce using rule 70 (literal -> INTEGER .)
    PUT             reduce using rule 70 (literal -> INTEGER .)
    IDENTIFIER      reduce using rule 70 (literal -> INTEGER .)
    DO              reduce using rule 70 (literal -> INTEGER .)
    WHILE           reduce using rule 70 (literal -> INTEGER .)
    FOR             reduce using rule 70 (literal -> INTEGER .)
    IF              reduce using rule 70 (literal -> INTEGER .)
    LOG             reduce using rule 70 (literal -> INTEGER .)
    LET             reduce using rule 70 (literal -> INTEGER .)
    TYPE_BOOL       reduce using rule 70 (literal -> INTEGER .)
    TYPE_INT        reduce using rule 70 (literal -> INTEGER .)
    TYPE_CHAR       reduce using rule 70 (literal -> INTEGER .)
    TYPE_DOUBLE     reduce using rule 70 (literal -> INTEGER .)
    TYPE_STRING     reduce using rule 70 (literal -> INTEGER .)
    LEFT_PAREN      reduce using rule 70 (literal -> INTEGER .)
    DOUBLE          reduce using rule 70 (literal -> INTEGER .)
    INTEGER         reduce using rule 70 (literal -> INTEGER .)
    STRING          reduce using rule 70 (literal -> INTEGER .)
    TRUE            reduce using rule 70 (literal -> INTEGER .)
    FALSE           reduce using rule 70 (literal -> INTEGER .)
    $end            reduce using rule 70 (literal -> INTEGER .)
    RIGHT_BRACE     reduce using rule 70 (literal -> INTEGER .)
    STEP            reduce using rule 70 (literal -> INTEGER .)


state 42

    (71) literal -> STRING .

    PRODUCT         reduce using rule 71 (literal -> STRING .)
    DIVIDE          reduce using rule 71 (literal -> STRING .)
    SEMICOLON       reduce using rule 71 (literal -> STRING .)
    NOT             reduce using rule 71 (literal -> STRING .)
    EXP             reduce using rule 71 (literal -> STRING .)
    GTE             reduce using rule 71 (literal -> STRING .)
    LTE             reduce using rule 71 (literal -> STRING .)
    IS              reduce using rule 71 (literal -> STRING .)
    GT              reduce using rule 71 (literal -> STRING .)
    LT              reduce using rule 71 (literal -> STRING .)
    EQUALS          reduce using rule 71 (literal -> STRING .)
    OR              reduce using rule 71 (literal -> STRING .)
    AND             reduce using rule 71 (literal -> STRING .)
    PLUS            reduce using rule 71 (literal -> STRING .)
    MINUS           reduce using rule 71 (literal -> STRING .)
    RIGHT_PAREN     reduce using rule 71 (literal -> STRING .)
    IN              reduce using rule 71 (literal -> STRING .)
    LEFT_BRACE      reduce using rule 71 (literal -> STRING .)
    TO              reduce using rule 71 (literal -> STRING .)
    COMMA           reduce using rule 71 (literal -> STRING .)
    FUNCTION        reduce using rule 71 (literal -> STRING .)
    STRUCT          reduce using rule 71 (literal -> STRING .)
    PUT             reduce using rule 71 (literal -> STRING .)
    IDENTIFIER      reduce using rule 71 (literal -> STRING .)
    DO              reduce using rule 71 (literal -> STRING .)
    WHILE           reduce using rule 71 (literal -> STRING .)
    FOR             reduce using rule 71 (literal -> STRING .)
    IF              reduce using rule 71 (literal -> STRING .)
    LOG             reduce using rule 71 (literal -> STRING .)
    LET             reduce using rule 71 (literal -> STRING .)
    TYPE_BOOL       reduce using rule 71 (literal -> STRING .)
    TYPE_INT        reduce using rule 71 (literal -> STRING .)
    TYPE_CHAR       reduce using rule 71 (literal -> STRING .)
    TYPE_DOUBLE     reduce using rule 71 (literal -> STRING .)
    TYPE_STRING     reduce using rule 71 (literal -> STRING .)
    LEFT_PAREN      reduce using rule 71 (literal -> STRING .)
    DOUBLE          reduce using rule 71 (literal -> STRING .)
    INTEGER         reduce using rule 71 (literal -> STRING .)
    STRING          reduce using rule 71 (literal -> STRING .)
    TRUE            reduce using rule 71 (literal -> STRING .)
    FALSE           reduce using rule 71 (literal -> STRING .)
    $end            reduce using rule 71 (literal -> STRING .)
    RIGHT_BRACE     reduce using rule 71 (literal -> STRING .)
    STEP            reduce using rule 71 (literal -> STRING .)


state 43

    (72) literal -> TRUE .

    PRODUCT         reduce using rule 72 (literal -> TRUE .)
    DIVIDE          reduce using rule 72 (literal -> TRUE .)
    SEMICOLON       reduce using rule 72 (literal -> TRUE .)
    NOT             reduce using rule 72 (literal -> TRUE .)
    EXP             reduce using rule 72 (literal -> TRUE .)
    GTE             reduce using rule 72 (literal -> TRUE .)
    LTE             reduce using rule 72 (literal -> TRUE .)
    IS              reduce using rule 72 (literal -> TRUE .)
    GT              reduce using rule 72 (literal -> TRUE .)
    LT              reduce using rule 72 (literal -> TRUE .)
    EQUALS          reduce using rule 72 (literal -> TRUE .)
    OR              reduce using rule 72 (literal -> TRUE .)
    AND             reduce using rule 72 (literal -> TRUE .)
    PLUS            reduce using rule 72 (literal -> TRUE .)
    MINUS           reduce using rule 72 (literal -> TRUE .)
    RIGHT_PAREN     reduce using rule 72 (literal -> TRUE .)
    IN              reduce using rule 72 (literal -> TRUE .)
    LEFT_BRACE      reduce using rule 72 (literal -> TRUE .)
    TO              reduce using rule 72 (literal -> TRUE .)
    COMMA           reduce using rule 72 (literal -> TRUE .)
    FUNCTION        reduce using rule 72 (literal -> TRUE .)
    STRUCT          reduce using rule 72 (literal -> TRUE .)
    PUT             reduce using rule 72 (literal -> TRUE .)
    IDENTIFIER      reduce using rule 72 (literal -> TRUE .)
    DO              reduce using rule 72 (literal -> TRUE .)
    WHILE           reduce using rule 72 (literal -> TRUE .)
    FOR             reduce using rule 72 (literal -> TRUE .)
    IF              reduce using rule 72 (literal -> TRUE .)
    LOG             reduce using rule 72 (literal -> TRUE .)
    LET             reduce using rule 72 (literal -> TRUE .)
    TYPE_BOOL       reduce using rule 72 (literal -> TRUE .)
    TYPE_INT        reduce using rule 72 (literal -> TRUE .)
    TYPE_CHAR       reduce using rule 72 (literal -> TRUE .)
    TYPE_DOUBLE     reduce using rule 72 (literal -> TRUE .)
    TYPE_STRING     reduce using rule 72 (literal -> TRUE .)
    LEFT_PAREN      reduce using rule 72 (literal -> TRUE .)
    DOUBLE          reduce using rule 72 (literal -> TRUE .)
    INTEGER         reduce using rule 72 (literal -> TRUE .)
    STRING          reduce using rule 72 (literal -> TRUE .)
    TRUE            reduce using rule 72 (literal -> TRUE .)
    FALSE           reduce using rule 72 (literal -> TRUE .)
    $end            reduce using rule 72 (literal -> TRUE .)
    RIGHT_BRACE     reduce using rule 72 (literal -> TRUE .)
    STEP            reduce using rule 72 (literal -> TRUE .)


state 44

    (73) literal -> FALSE .

    PRODUCT         reduce using rule 73 (literal -> FALSE .)
    DIVIDE          reduce using rule 73 (literal -> FALSE .)
    SEMICOLON       reduce using rule 73 (literal -> FALSE .)
    NOT             reduce using rule 73 (literal -> FALSE .)
    EXP             reduce using rule 73 (literal -> FALSE .)
    GTE             reduce using rule 73 (literal -> FALSE .)
    LTE             reduce using rule 73 (literal -> FALSE .)
    IS              reduce using rule 73 (literal -> FALSE .)
    GT              reduce using rule 73 (literal -> FALSE .)
    LT              reduce using rule 73 (literal -> FALSE .)
    EQUALS          reduce using rule 73 (literal -> FALSE .)
    OR              reduce using rule 73 (literal -> FALSE .)
    AND             reduce using rule 73 (literal -> FALSE .)
    PLUS            reduce using rule 73 (literal -> FALSE .)
    MINUS           reduce using rule 73 (literal -> FALSE .)
    RIGHT_PAREN     reduce using rule 73 (literal -> FALSE .)
    IN              reduce using rule 73 (literal -> FALSE .)
    LEFT_BRACE      reduce using rule 73 (literal -> FALSE .)
    TO              reduce using rule 73 (literal -> FALSE .)
    COMMA           reduce using rule 73 (literal -> FALSE .)
    FUNCTION        reduce using rule 73 (literal -> FALSE .)
    STRUCT          reduce using rule 73 (literal -> FALSE .)
    PUT             reduce using rule 73 (literal -> FALSE .)
    IDENTIFIER      reduce using rule 73 (literal -> FALSE .)
    DO              reduce using rule 73 (literal -> FALSE .)
    WHILE           reduce using rule 73 (literal -> FALSE .)
    FOR             reduce using rule 73 (literal -> FALSE .)
    IF              reduce using rule 73 (literal -> FALSE .)
    LOG             reduce using rule 73 (literal -> FALSE .)
    LET             reduce using rule 73 (literal -> FALSE .)
    TYPE_BOOL       reduce using rule 73 (literal -> FALSE .)
    TYPE_INT        reduce using rule 73 (literal -> FALSE .)
    TYPE_CHAR       reduce using rule 73 (literal -> FALSE .)
    TYPE_DOUBLE     reduce using rule 73 (literal -> FALSE .)
    TYPE_STRING     reduce using rule 73 (literal -> FALSE .)
    LEFT_PAREN      reduce using rule 73 (literal -> FALSE .)
    DOUBLE          reduce using rule 73 (literal -> FALSE .)
    INTEGER         reduce using rule 73 (literal -> FALSE .)
    STRING          reduce using rule 73 (literal -> FALSE .)
    TRUE            reduce using rule 73 (literal -> FALSE .)
    FALSE           reduce using rule 73 (literal -> FALSE .)
    $end            reduce using rule 73 (literal -> FALSE .)
    RIGHT_BRACE     reduce using rule 73 (literal -> FALSE .)
    STEP            reduce using rule 73 (literal -> FALSE .)


state 45

    (29) declaration_list -> statement declaration_list .

    $end            reduce using rule 29 (declaration_list -> statement declaration_list .)


state 46

    (43) declaration_list -> function_declaration declaration_list .

    $end            reduce using rule 43 (declaration_list -> function_declaration declaration_list .)


state 47

    (55) declaration_list -> struct_declaration declaration_list .

    $end            reduce using rule 55 (declaration_list -> struct_declaration declaration_list .)


state 48

    (28) function_declaration -> FUNCTION IDENTIFIER . LEFT_PAREN arguments RIGHT_PAREN compound_statement
    (47) function_declaration -> FUNCTION IDENTIFIER . LEFT_PAREN RIGHT_PAREN compound_statement

    LEFT_PAREN      shift and go to state 90


state 49

    (67) variable_declaration -> IDENTIFIER IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 91


state 50

    (42) assignment_statement -> IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 92
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 51

    (54) assignment_statement -> IDENTIFIER DOT . IDENTIFIER ASSIGN expression SEMICOLON
    (58) literal -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 93


state 52

    (8) function_call -> IDENTIFIER LEFT_PAREN . RIGHT_PAREN SEMICOLON
    (37) function_call -> IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 94
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 95
    expression                     shift and go to state 96
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 53

    (33) expression -> IDENTIFIER INCREMENT .

    SEMICOLON       reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    NOT             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    EXP             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    GTE             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LTE             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IS              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    GT              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LT              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    EQUALS          reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    OR              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    AND             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    PLUS            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    MINUS           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    RIGHT_PAREN     reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IN              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LEFT_BRACE      reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TO              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    COMMA           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    FUNCTION        reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    STRUCT          reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    PUT             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IDENTIFIER      reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    DO              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    WHILE           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    FOR             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    IF              reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LOG             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LET             reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TYPE_BOOL       reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TYPE_INT        reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TYPE_CHAR       reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TYPE_DOUBLE     reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TYPE_STRING     reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    LEFT_PAREN      reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    DOUBLE          reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    INTEGER         reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    STRING          reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    TRUE            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    FALSE           reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    $end            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    RIGHT_BRACE     reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)
    STEP            reduce using rule 33 (expression -> IDENTIFIER INCREMENT .)


state 54

    (49) expression -> IDENTIFIER DECREMENT .

    SEMICOLON       reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    NOT             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    EXP             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    GTE             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    LTE             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    IS              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    GT              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    LT              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    EQUALS          reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    OR              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    AND             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    PLUS            reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    MINUS           reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    RIGHT_PAREN     reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    IN              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    LEFT_BRACE      reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    TO              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    COMMA           reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    FUNCTION        reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    STRUCT          reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    PUT             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    IDENTIFIER      reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    DO              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    WHILE           reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    FOR             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    IF              reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    LOG             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    LET             reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    TYPE_BOOL       reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    TYPE_INT        reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    TYPE_CHAR       reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    TYPE_DOUBLE     reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    TYPE_STRING     reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    LEFT_PAREN      reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    DOUBLE          reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    INTEGER         reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    STRING          reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    TRUE            reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    FALSE           reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    $end            reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    RIGHT_BRACE     reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)
    STEP            reduce using rule 49 (expression -> IDENTIFIER DECREMENT .)


state 55

    (46) literal -> IDENTIFIER LEFT_BRACKET . QUOTE IDENTIFIER QUOTE RIGHT_BRACKET

    QUOTE           shift and go to state 97


state 56

    (50) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 98
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 57

    (33) expression -> IDENTIFIER . INCREMENT
    (49) expression -> IDENTIFIER . DECREMENT
    (46) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> IDENTIFIER . DOT IDENTIFIER
    (65) literal -> IDENTIFIER .

    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    LEFT_BRACKET    shift and go to state 55
    DOT             shift and go to state 99
    PRODUCT         reduce using rule 65 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 65 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 65 (literal -> IDENTIFIER .)
    NOT             reduce using rule 65 (literal -> IDENTIFIER .)
    EXP             reduce using rule 65 (literal -> IDENTIFIER .)
    GTE             reduce using rule 65 (literal -> IDENTIFIER .)
    LTE             reduce using rule 65 (literal -> IDENTIFIER .)
    IS              reduce using rule 65 (literal -> IDENTIFIER .)
    GT              reduce using rule 65 (literal -> IDENTIFIER .)
    LT              reduce using rule 65 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 65 (literal -> IDENTIFIER .)
    OR              reduce using rule 65 (literal -> IDENTIFIER .)
    AND             reduce using rule 65 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 65 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 65 (literal -> IDENTIFIER .)
    IN              reduce using rule 65 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 65 (literal -> IDENTIFIER .)
    TO              reduce using rule 65 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 65 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 65 (literal -> IDENTIFIER .)
    FUNCTION        reduce using rule 65 (literal -> IDENTIFIER .)
    STRUCT          reduce using rule 65 (literal -> IDENTIFIER .)
    PUT             reduce using rule 65 (literal -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 65 (literal -> IDENTIFIER .)
    DO              reduce using rule 65 (literal -> IDENTIFIER .)
    WHILE           reduce using rule 65 (literal -> IDENTIFIER .)
    FOR             reduce using rule 65 (literal -> IDENTIFIER .)
    IF              reduce using rule 65 (literal -> IDENTIFIER .)
    LOG             reduce using rule 65 (literal -> IDENTIFIER .)
    LET             reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_BOOL       reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_INT        reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_CHAR       reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_DOUBLE     reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_STRING     reduce using rule 65 (literal -> IDENTIFIER .)
    LEFT_PAREN      reduce using rule 65 (literal -> IDENTIFIER .)
    DOUBLE          reduce using rule 65 (literal -> IDENTIFIER .)
    INTEGER         reduce using rule 65 (literal -> IDENTIFIER .)
    STRING          reduce using rule 65 (literal -> IDENTIFIER .)
    TRUE            reduce using rule 65 (literal -> IDENTIFIER .)
    FALSE           reduce using rule 65 (literal -> IDENTIFIER .)
    $end            reduce using rule 65 (literal -> IDENTIFIER .)
    RIGHT_BRACE     reduce using rule 65 (literal -> IDENTIFIER .)
    STEP            reduce using rule 65 (literal -> IDENTIFIER .)


state 58

    (10) struct_declaration -> STRUCT IDENTIFIER . LEFT_BRACE variable_declaration_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 100


state 59

    (27) compound_statement -> LEFT_BRACE statement_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 101


state 60

    (24) statement_list -> statement . statement_list
    (24) statement_list -> . statement statement_list
    (48) statement_list -> . empty
    (14) statement -> . assignment_statement
    (15) statement -> . expression_statement
    (16) statement -> . iterative_statement
    (17) statement -> . conditional_statement
    (18) statement -> . compound_statement
    (19) statement -> . print_statement
    (20) statement -> . function_call
    (21) statement -> . variable_declaration
    (6) empty -> .
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (12) expression_statement -> . expression SEMICOLON
    (13) expression_statement -> . SEMICOLON
    (22) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN
    (23) iterative_statement -> . WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement
    (31) iterative_statement -> . FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement
    (40) iterative_statement -> . DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (41) iterative_statement -> . WHILE expression compound_statement
    (45) iterative_statement -> . FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement
    (53) iterative_statement -> . DO compound_statement WHILE expression
    (57) iterative_statement -> . FOR expression TO expression compound_statement
    (61) iterative_statement -> . DO compound_statement WHILE expression SEMICOLON
    (64) iterative_statement -> . FOR expression TO expression STEP expression compound_statement
    (68) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> . FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> . FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (25) print_statement -> . LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (8) function_call -> . IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON
    (37) function_call -> . IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       shift and go to state 22
    DO              shift and go to state 23
    WHILE           shift and go to state 24
    FOR             shift and go to state 25
    IF              shift and go to state 26
    LEFT_BRACE      shift and go to state 19
    LOG             shift and go to state 27
    LET             shift and go to state 28
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    statement                      shift and go to state 60
    statement_list                 shift and go to state 102
    empty                          shift and go to state 61
    assignment_statement           shift and go to state 7
    expression_statement           shift and go to state 8
    iterative_statement            shift and go to state 9
    conditional_statement          shift and go to state 10
    compound_statement             shift and go to state 11
    print_statement                shift and go to state 12
    function_call                  shift and go to state 13
    variable_declaration           shift and go to state 14
    expression                     shift and go to state 21
    type_specifier                 shift and go to state 29
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 61

    (48) statement_list -> empty .

    RIGHT_BRACE     reduce using rule 48 (statement_list -> empty .)


state 62

    (26) assignment_statement -> PUT expression . IN IDENTIFIER SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    IN              shift and go to state 103
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 63

    (12) expression_statement -> expression SEMICOLON .

    FUNCTION        reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    STRUCT          reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    PUT             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    DO              reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LOG             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LET             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_INT        reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TYPE_STRING     reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    STRING          reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    TRUE            reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    FALSE           reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    $end            reduce using rule 12 (expression_statement -> expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 12 (expression_statement -> expression SEMICOLON .)


state 64

    (66) expression -> expression NOT . ASSIGN term

    ASSIGN          shift and go to state 104


state 65

    (76) expression -> expression EXP . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 105
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 66

    (78) expression -> expression GTE . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 106
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 67

    (80) expression -> expression LTE . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 107
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 68

    (81) expression -> expression IS . GREATER THAN term
    (82) expression -> expression IS . LESS THAN term
    (85) expression -> expression IS . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    GREATER         shift and go to state 108
    LESS            shift and go to state 110
    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 109
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 69

    (83) expression -> expression GT . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 111
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 70

    (84) expression -> expression LT . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 112
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 71

    (86) expression -> expression EQUALS . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 113
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 72

    (87) expression -> expression OR . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 114
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 73

    (88) expression -> expression AND . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 115
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 74

    (89) expression -> expression PLUS . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 116
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 75

    (90) expression -> expression MINUS . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 117
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 76

    (22) iterative_statement -> DO compound_statement . WHILE LEFT_PAREN expression RIGHT_PAREN
    (40) iterative_statement -> DO compound_statement . WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (53) iterative_statement -> DO compound_statement . WHILE expression
    (61) iterative_statement -> DO compound_statement . WHILE expression SEMICOLON

    WHILE           shift and go to state 118


state 77

    (23) iterative_statement -> WHILE LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (50) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 119
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 78

    (41) iterative_statement -> WHILE expression . compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 120

state 79

    (31) iterative_statement -> FOR LEFT_PAREN . expression TO expression RIGHT_PAREN compound_statement
    (45) iterative_statement -> FOR LEFT_PAREN . expression TO expression STEP expression RIGHT_PAREN compound_statement
    (68) iterative_statement -> FOR LEFT_PAREN . variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN . variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> FOR LEFT_PAREN . expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> FOR LEFT_PAREN . expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (50) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 123
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LET             shift and go to state 28
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 121
    variable_declaration           shift and go to state 122
    term                           shift and go to state 31
    type_specifier                 shift and go to state 29
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 80

    (57) iterative_statement -> FOR expression . TO expression compound_statement
    (64) iterative_statement -> FOR expression . TO expression STEP expression compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    TO              shift and go to state 124
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 81

    (9) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> IF LEFT_PAREN . expression RIGHT_PAREN compound_statement ELSE conditional_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 125
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 82

    (25) print_statement -> LOG LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 126
    expression                     shift and go to state 96
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 83

    (30) variable_declaration -> LET IDENTIFIER . ASSIGN expression SEMICOLON
    (63) variable_declaration -> LET IDENTIFIER . SEMICOLON

    ASSIGN          shift and go to state 127
    SEMICOLON       shift and go to state 128


state 84

    (44) variable_declaration -> type_specifier IDENTIFIER . ASSIGN expression SEMICOLON
    (56) variable_declaration -> type_specifier IDENTIFIER . SEMICOLON

    ASSIGN          shift and go to state 129
    SEMICOLON       shift and go to state 130


state 85

    (59) expression -> MINUS term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 59 (expression -> MINUS term .)
    NOT             reduce using rule 59 (expression -> MINUS term .)
    EXP             reduce using rule 59 (expression -> MINUS term .)
    GTE             reduce using rule 59 (expression -> MINUS term .)
    LTE             reduce using rule 59 (expression -> MINUS term .)
    IS              reduce using rule 59 (expression -> MINUS term .)
    GT              reduce using rule 59 (expression -> MINUS term .)
    LT              reduce using rule 59 (expression -> MINUS term .)
    EQUALS          reduce using rule 59 (expression -> MINUS term .)
    OR              reduce using rule 59 (expression -> MINUS term .)
    AND             reduce using rule 59 (expression -> MINUS term .)
    PLUS            reduce using rule 59 (expression -> MINUS term .)
    MINUS           reduce using rule 59 (expression -> MINUS term .)
    RIGHT_PAREN     reduce using rule 59 (expression -> MINUS term .)
    IN              reduce using rule 59 (expression -> MINUS term .)
    LEFT_BRACE      reduce using rule 59 (expression -> MINUS term .)
    TO              reduce using rule 59 (expression -> MINUS term .)
    COMMA           reduce using rule 59 (expression -> MINUS term .)
    FUNCTION        reduce using rule 59 (expression -> MINUS term .)
    STRUCT          reduce using rule 59 (expression -> MINUS term .)
    PUT             reduce using rule 59 (expression -> MINUS term .)
    IDENTIFIER      reduce using rule 59 (expression -> MINUS term .)
    DO              reduce using rule 59 (expression -> MINUS term .)
    WHILE           reduce using rule 59 (expression -> MINUS term .)
    FOR             reduce using rule 59 (expression -> MINUS term .)
    IF              reduce using rule 59 (expression -> MINUS term .)
    LOG             reduce using rule 59 (expression -> MINUS term .)
    LET             reduce using rule 59 (expression -> MINUS term .)
    TYPE_BOOL       reduce using rule 59 (expression -> MINUS term .)
    TYPE_INT        reduce using rule 59 (expression -> MINUS term .)
    TYPE_CHAR       reduce using rule 59 (expression -> MINUS term .)
    TYPE_DOUBLE     reduce using rule 59 (expression -> MINUS term .)
    TYPE_STRING     reduce using rule 59 (expression -> MINUS term .)
    LEFT_PAREN      reduce using rule 59 (expression -> MINUS term .)
    DOUBLE          reduce using rule 59 (expression -> MINUS term .)
    INTEGER         reduce using rule 59 (expression -> MINUS term .)
    STRING          reduce using rule 59 (expression -> MINUS term .)
    TRUE            reduce using rule 59 (expression -> MINUS term .)
    FALSE           reduce using rule 59 (expression -> MINUS term .)
    $end            reduce using rule 59 (expression -> MINUS term .)
    RIGHT_BRACE     reduce using rule 59 (expression -> MINUS term .)
    STEP            reduce using rule 59 (expression -> MINUS term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 86

    (46) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> IDENTIFIER . DOT IDENTIFIER
    (65) literal -> IDENTIFIER .

    LEFT_BRACKET    shift and go to state 55
    DOT             shift and go to state 99
    PRODUCT         reduce using rule 65 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 65 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 65 (literal -> IDENTIFIER .)
    NOT             reduce using rule 65 (literal -> IDENTIFIER .)
    EXP             reduce using rule 65 (literal -> IDENTIFIER .)
    GTE             reduce using rule 65 (literal -> IDENTIFIER .)
    LTE             reduce using rule 65 (literal -> IDENTIFIER .)
    IS              reduce using rule 65 (literal -> IDENTIFIER .)
    GT              reduce using rule 65 (literal -> IDENTIFIER .)
    LT              reduce using rule 65 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 65 (literal -> IDENTIFIER .)
    OR              reduce using rule 65 (literal -> IDENTIFIER .)
    AND             reduce using rule 65 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 65 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 65 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 65 (literal -> IDENTIFIER .)
    IN              reduce using rule 65 (literal -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 65 (literal -> IDENTIFIER .)
    TO              reduce using rule 65 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 65 (literal -> IDENTIFIER .)
    FUNCTION        reduce using rule 65 (literal -> IDENTIFIER .)
    STRUCT          reduce using rule 65 (literal -> IDENTIFIER .)
    PUT             reduce using rule 65 (literal -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 65 (literal -> IDENTIFIER .)
    DO              reduce using rule 65 (literal -> IDENTIFIER .)
    WHILE           reduce using rule 65 (literal -> IDENTIFIER .)
    FOR             reduce using rule 65 (literal -> IDENTIFIER .)
    IF              reduce using rule 65 (literal -> IDENTIFIER .)
    LOG             reduce using rule 65 (literal -> IDENTIFIER .)
    LET             reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_BOOL       reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_INT        reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_CHAR       reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_DOUBLE     reduce using rule 65 (literal -> IDENTIFIER .)
    TYPE_STRING     reduce using rule 65 (literal -> IDENTIFIER .)
    LEFT_PAREN      reduce using rule 65 (literal -> IDENTIFIER .)
    DOUBLE          reduce using rule 65 (literal -> IDENTIFIER .)
    INTEGER         reduce using rule 65 (literal -> IDENTIFIER .)
    STRING          reduce using rule 65 (literal -> IDENTIFIER .)
    TRUE            reduce using rule 65 (literal -> IDENTIFIER .)
    FALSE           reduce using rule 65 (literal -> IDENTIFIER .)
    $end            reduce using rule 65 (literal -> IDENTIFIER .)
    RIGHT_BRACE     reduce using rule 65 (literal -> IDENTIFIER .)
    STEP            reduce using rule 65 (literal -> IDENTIFIER .)


state 87

    (35) term -> term PRODUCT . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    factor                         shift and go to state 131
    literal                        shift and go to state 39

state 88

    (51) term -> term DIVIDE . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    factor                         shift and go to state 132
    literal                        shift and go to state 39

state 89

    (74) expression -> NOT term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 74 (expression -> NOT term .)
    NOT             reduce using rule 74 (expression -> NOT term .)
    EXP             reduce using rule 74 (expression -> NOT term .)
    GTE             reduce using rule 74 (expression -> NOT term .)
    LTE             reduce using rule 74 (expression -> NOT term .)
    IS              reduce using rule 74 (expression -> NOT term .)
    GT              reduce using rule 74 (expression -> NOT term .)
    LT              reduce using rule 74 (expression -> NOT term .)
    EQUALS          reduce using rule 74 (expression -> NOT term .)
    OR              reduce using rule 74 (expression -> NOT term .)
    AND             reduce using rule 74 (expression -> NOT term .)
    PLUS            reduce using rule 74 (expression -> NOT term .)
    MINUS           reduce using rule 74 (expression -> NOT term .)
    RIGHT_PAREN     reduce using rule 74 (expression -> NOT term .)
    IN              reduce using rule 74 (expression -> NOT term .)
    LEFT_BRACE      reduce using rule 74 (expression -> NOT term .)
    TO              reduce using rule 74 (expression -> NOT term .)
    COMMA           reduce using rule 74 (expression -> NOT term .)
    FUNCTION        reduce using rule 74 (expression -> NOT term .)
    STRUCT          reduce using rule 74 (expression -> NOT term .)
    PUT             reduce using rule 74 (expression -> NOT term .)
    IDENTIFIER      reduce using rule 74 (expression -> NOT term .)
    DO              reduce using rule 74 (expression -> NOT term .)
    WHILE           reduce using rule 74 (expression -> NOT term .)
    FOR             reduce using rule 74 (expression -> NOT term .)
    IF              reduce using rule 74 (expression -> NOT term .)
    LOG             reduce using rule 74 (expression -> NOT term .)
    LET             reduce using rule 74 (expression -> NOT term .)
    TYPE_BOOL       reduce using rule 74 (expression -> NOT term .)
    TYPE_INT        reduce using rule 74 (expression -> NOT term .)
    TYPE_CHAR       reduce using rule 74 (expression -> NOT term .)
    TYPE_DOUBLE     reduce using rule 74 (expression -> NOT term .)
    TYPE_STRING     reduce using rule 74 (expression -> NOT term .)
    LEFT_PAREN      reduce using rule 74 (expression -> NOT term .)
    DOUBLE          reduce using rule 74 (expression -> NOT term .)
    INTEGER         reduce using rule 74 (expression -> NOT term .)
    STRING          reduce using rule 74 (expression -> NOT term .)
    TRUE            reduce using rule 74 (expression -> NOT term .)
    FALSE           reduce using rule 74 (expression -> NOT term .)
    $end            reduce using rule 74 (expression -> NOT term .)
    RIGHT_BRACE     reduce using rule 74 (expression -> NOT term .)
    STEP            reduce using rule 74 (expression -> NOT term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 90

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN . arguments RIGHT_PAREN compound_statement
    (47) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN . RIGHT_PAREN compound_statement
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    RIGHT_PAREN     shift and go to state 134
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    arguments                      shift and go to state 133
    expression                     shift and go to state 96
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 91

    (67) variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    DO              reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    IF              reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LET             reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    $end            reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 67 (variable_declaration -> IDENTIFIER IDENTIFIER SEMICOLON .)


state 92

    (42) assignment_statement -> IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 135
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 93

    (54) assignment_statement -> IDENTIFIER DOT IDENTIFIER . ASSIGN expression SEMICOLON
    (58) literal -> IDENTIFIER DOT IDENTIFIER .

    ASSIGN          shift and go to state 136
    PRODUCT         reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    NOT             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EXP             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GTE             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LTE             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IS              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GT              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LT              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EQUALS          reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    OR              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    AND             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    MINUS           reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)


state 94

    (8) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 137


state 95

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 138


state 96

    (7) arguments -> expression . COMMA arguments
    (36) arguments -> expression .
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    COMMA           shift and go to state 139
    RIGHT_PAREN     reduce using rule 36 (arguments -> expression .)
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 97

    (46) literal -> IDENTIFIER LEFT_BRACKET QUOTE . IDENTIFIER QUOTE RIGHT_BRACKET

    IDENTIFIER      shift and go to state 140


state 98

    (50) factor -> LEFT_PAREN expression RIGHT_PAREN .

    PRODUCT         reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EXP             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GTE             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LTE             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IS              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GT              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LT              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IN              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TO              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    COMMA           reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FUNCTION        reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    STRUCT          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PUT             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IDENTIFIER      reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DO              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    WHILE           reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FOR             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IF              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LOG             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LET             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_BOOL       reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_INT        reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_CHAR       reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_DOUBLE     reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_STRING     reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DOUBLE          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    INTEGER         reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    STRING          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    TRUE            reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    FALSE           reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    $end            reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    STEP            reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)


state 99

    (58) literal -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 141


state 100

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE . variable_declaration_list RIGHT_BRACE
    (11) variable_declaration_list -> . variable_declaration variable_declaration_list
    (39) variable_declaration_list -> . empty
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (6) empty -> .
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING

    LET             shift and go to state 28
    IDENTIFIER      shift and go to state 142
    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37

    variable_declaration_list      shift and go to state 143
    variable_declaration           shift and go to state 144
    empty                          shift and go to state 145
    type_specifier                 shift and go to state 29

state 101

    (27) compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .

    FUNCTION        reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRUCT          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    PUT             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DO              reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    WHILE           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FOR             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    IF              reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LOG             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LET             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    MINUS           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    NOT             reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_BOOL       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_INT        reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_CHAR       reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_DOUBLE     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TYPE_STRING     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    INTEGER         reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    STRING          reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    TRUE            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    FALSE           reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    $end            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)
    ELSE            reduce using rule 27 (compound_statement -> LEFT_BRACE statement_list RIGHT_BRACE .)


state 102

    (24) statement_list -> statement statement_list .

    RIGHT_BRACE     reduce using rule 24 (statement_list -> statement statement_list .)


state 103

    (26) assignment_statement -> PUT expression IN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 146


state 104

    (66) expression -> expression NOT ASSIGN . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 147
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 105

    (76) expression -> expression EXP term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 76 (expression -> expression EXP term .)
    NOT             reduce using rule 76 (expression -> expression EXP term .)
    EXP             reduce using rule 76 (expression -> expression EXP term .)
    GTE             reduce using rule 76 (expression -> expression EXP term .)
    LTE             reduce using rule 76 (expression -> expression EXP term .)
    IS              reduce using rule 76 (expression -> expression EXP term .)
    GT              reduce using rule 76 (expression -> expression EXP term .)
    LT              reduce using rule 76 (expression -> expression EXP term .)
    EQUALS          reduce using rule 76 (expression -> expression EXP term .)
    OR              reduce using rule 76 (expression -> expression EXP term .)
    AND             reduce using rule 76 (expression -> expression EXP term .)
    PLUS            reduce using rule 76 (expression -> expression EXP term .)
    MINUS           reduce using rule 76 (expression -> expression EXP term .)
    RIGHT_PAREN     reduce using rule 76 (expression -> expression EXP term .)
    IN              reduce using rule 76 (expression -> expression EXP term .)
    LEFT_BRACE      reduce using rule 76 (expression -> expression EXP term .)
    TO              reduce using rule 76 (expression -> expression EXP term .)
    COMMA           reduce using rule 76 (expression -> expression EXP term .)
    FUNCTION        reduce using rule 76 (expression -> expression EXP term .)
    STRUCT          reduce using rule 76 (expression -> expression EXP term .)
    PUT             reduce using rule 76 (expression -> expression EXP term .)
    IDENTIFIER      reduce using rule 76 (expression -> expression EXP term .)
    DO              reduce using rule 76 (expression -> expression EXP term .)
    WHILE           reduce using rule 76 (expression -> expression EXP term .)
    FOR             reduce using rule 76 (expression -> expression EXP term .)
    IF              reduce using rule 76 (expression -> expression EXP term .)
    LOG             reduce using rule 76 (expression -> expression EXP term .)
    LET             reduce using rule 76 (expression -> expression EXP term .)
    TYPE_BOOL       reduce using rule 76 (expression -> expression EXP term .)
    TYPE_INT        reduce using rule 76 (expression -> expression EXP term .)
    TYPE_CHAR       reduce using rule 76 (expression -> expression EXP term .)
    TYPE_DOUBLE     reduce using rule 76 (expression -> expression EXP term .)
    TYPE_STRING     reduce using rule 76 (expression -> expression EXP term .)
    LEFT_PAREN      reduce using rule 76 (expression -> expression EXP term .)
    DOUBLE          reduce using rule 76 (expression -> expression EXP term .)
    INTEGER         reduce using rule 76 (expression -> expression EXP term .)
    STRING          reduce using rule 76 (expression -> expression EXP term .)
    TRUE            reduce using rule 76 (expression -> expression EXP term .)
    FALSE           reduce using rule 76 (expression -> expression EXP term .)
    $end            reduce using rule 76 (expression -> expression EXP term .)
    RIGHT_BRACE     reduce using rule 76 (expression -> expression EXP term .)
    STEP            reduce using rule 76 (expression -> expression EXP term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 106

    (78) expression -> expression GTE term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 78 (expression -> expression GTE term .)
    NOT             reduce using rule 78 (expression -> expression GTE term .)
    EXP             reduce using rule 78 (expression -> expression GTE term .)
    GTE             reduce using rule 78 (expression -> expression GTE term .)
    LTE             reduce using rule 78 (expression -> expression GTE term .)
    IS              reduce using rule 78 (expression -> expression GTE term .)
    GT              reduce using rule 78 (expression -> expression GTE term .)
    LT              reduce using rule 78 (expression -> expression GTE term .)
    EQUALS          reduce using rule 78 (expression -> expression GTE term .)
    OR              reduce using rule 78 (expression -> expression GTE term .)
    AND             reduce using rule 78 (expression -> expression GTE term .)
    PLUS            reduce using rule 78 (expression -> expression GTE term .)
    MINUS           reduce using rule 78 (expression -> expression GTE term .)
    RIGHT_PAREN     reduce using rule 78 (expression -> expression GTE term .)
    IN              reduce using rule 78 (expression -> expression GTE term .)
    LEFT_BRACE      reduce using rule 78 (expression -> expression GTE term .)
    TO              reduce using rule 78 (expression -> expression GTE term .)
    COMMA           reduce using rule 78 (expression -> expression GTE term .)
    FUNCTION        reduce using rule 78 (expression -> expression GTE term .)
    STRUCT          reduce using rule 78 (expression -> expression GTE term .)
    PUT             reduce using rule 78 (expression -> expression GTE term .)
    IDENTIFIER      reduce using rule 78 (expression -> expression GTE term .)
    DO              reduce using rule 78 (expression -> expression GTE term .)
    WHILE           reduce using rule 78 (expression -> expression GTE term .)
    FOR             reduce using rule 78 (expression -> expression GTE term .)
    IF              reduce using rule 78 (expression -> expression GTE term .)
    LOG             reduce using rule 78 (expression -> expression GTE term .)
    LET             reduce using rule 78 (expression -> expression GTE term .)
    TYPE_BOOL       reduce using rule 78 (expression -> expression GTE term .)
    TYPE_INT        reduce using rule 78 (expression -> expression GTE term .)
    TYPE_CHAR       reduce using rule 78 (expression -> expression GTE term .)
    TYPE_DOUBLE     reduce using rule 78 (expression -> expression GTE term .)
    TYPE_STRING     reduce using rule 78 (expression -> expression GTE term .)
    LEFT_PAREN      reduce using rule 78 (expression -> expression GTE term .)
    DOUBLE          reduce using rule 78 (expression -> expression GTE term .)
    INTEGER         reduce using rule 78 (expression -> expression GTE term .)
    STRING          reduce using rule 78 (expression -> expression GTE term .)
    TRUE            reduce using rule 78 (expression -> expression GTE term .)
    FALSE           reduce using rule 78 (expression -> expression GTE term .)
    $end            reduce using rule 78 (expression -> expression GTE term .)
    RIGHT_BRACE     reduce using rule 78 (expression -> expression GTE term .)
    STEP            reduce using rule 78 (expression -> expression GTE term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 107

    (80) expression -> expression LTE term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 80 (expression -> expression LTE term .)
    NOT             reduce using rule 80 (expression -> expression LTE term .)
    EXP             reduce using rule 80 (expression -> expression LTE term .)
    GTE             reduce using rule 80 (expression -> expression LTE term .)
    LTE             reduce using rule 80 (expression -> expression LTE term .)
    IS              reduce using rule 80 (expression -> expression LTE term .)
    GT              reduce using rule 80 (expression -> expression LTE term .)
    LT              reduce using rule 80 (expression -> expression LTE term .)
    EQUALS          reduce using rule 80 (expression -> expression LTE term .)
    OR              reduce using rule 80 (expression -> expression LTE term .)
    AND             reduce using rule 80 (expression -> expression LTE term .)
    PLUS            reduce using rule 80 (expression -> expression LTE term .)
    MINUS           reduce using rule 80 (expression -> expression LTE term .)
    RIGHT_PAREN     reduce using rule 80 (expression -> expression LTE term .)
    IN              reduce using rule 80 (expression -> expression LTE term .)
    LEFT_BRACE      reduce using rule 80 (expression -> expression LTE term .)
    TO              reduce using rule 80 (expression -> expression LTE term .)
    COMMA           reduce using rule 80 (expression -> expression LTE term .)
    FUNCTION        reduce using rule 80 (expression -> expression LTE term .)
    STRUCT          reduce using rule 80 (expression -> expression LTE term .)
    PUT             reduce using rule 80 (expression -> expression LTE term .)
    IDENTIFIER      reduce using rule 80 (expression -> expression LTE term .)
    DO              reduce using rule 80 (expression -> expression LTE term .)
    WHILE           reduce using rule 80 (expression -> expression LTE term .)
    FOR             reduce using rule 80 (expression -> expression LTE term .)
    IF              reduce using rule 80 (expression -> expression LTE term .)
    LOG             reduce using rule 80 (expression -> expression LTE term .)
    LET             reduce using rule 80 (expression -> expression LTE term .)
    TYPE_BOOL       reduce using rule 80 (expression -> expression LTE term .)
    TYPE_INT        reduce using rule 80 (expression -> expression LTE term .)
    TYPE_CHAR       reduce using rule 80 (expression -> expression LTE term .)
    TYPE_DOUBLE     reduce using rule 80 (expression -> expression LTE term .)
    TYPE_STRING     reduce using rule 80 (expression -> expression LTE term .)
    LEFT_PAREN      reduce using rule 80 (expression -> expression LTE term .)
    DOUBLE          reduce using rule 80 (expression -> expression LTE term .)
    INTEGER         reduce using rule 80 (expression -> expression LTE term .)
    STRING          reduce using rule 80 (expression -> expression LTE term .)
    TRUE            reduce using rule 80 (expression -> expression LTE term .)
    FALSE           reduce using rule 80 (expression -> expression LTE term .)
    $end            reduce using rule 80 (expression -> expression LTE term .)
    RIGHT_BRACE     reduce using rule 80 (expression -> expression LTE term .)
    STEP            reduce using rule 80 (expression -> expression LTE term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 108

    (81) expression -> expression IS GREATER . THAN term

    THAN            shift and go to state 148


state 109

    (85) expression -> expression IS term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 85 (expression -> expression IS term .)
    NOT             reduce using rule 85 (expression -> expression IS term .)
    EXP             reduce using rule 85 (expression -> expression IS term .)
    GTE             reduce using rule 85 (expression -> expression IS term .)
    LTE             reduce using rule 85 (expression -> expression IS term .)
    IS              reduce using rule 85 (expression -> expression IS term .)
    GT              reduce using rule 85 (expression -> expression IS term .)
    LT              reduce using rule 85 (expression -> expression IS term .)
    EQUALS          reduce using rule 85 (expression -> expression IS term .)
    OR              reduce using rule 85 (expression -> expression IS term .)
    AND             reduce using rule 85 (expression -> expression IS term .)
    PLUS            reduce using rule 85 (expression -> expression IS term .)
    MINUS           reduce using rule 85 (expression -> expression IS term .)
    RIGHT_PAREN     reduce using rule 85 (expression -> expression IS term .)
    IN              reduce using rule 85 (expression -> expression IS term .)
    LEFT_BRACE      reduce using rule 85 (expression -> expression IS term .)
    TO              reduce using rule 85 (expression -> expression IS term .)
    COMMA           reduce using rule 85 (expression -> expression IS term .)
    FUNCTION        reduce using rule 85 (expression -> expression IS term .)
    STRUCT          reduce using rule 85 (expression -> expression IS term .)
    PUT             reduce using rule 85 (expression -> expression IS term .)
    IDENTIFIER      reduce using rule 85 (expression -> expression IS term .)
    DO              reduce using rule 85 (expression -> expression IS term .)
    WHILE           reduce using rule 85 (expression -> expression IS term .)
    FOR             reduce using rule 85 (expression -> expression IS term .)
    IF              reduce using rule 85 (expression -> expression IS term .)
    LOG             reduce using rule 85 (expression -> expression IS term .)
    LET             reduce using rule 85 (expression -> expression IS term .)
    TYPE_BOOL       reduce using rule 85 (expression -> expression IS term .)
    TYPE_INT        reduce using rule 85 (expression -> expression IS term .)
    TYPE_CHAR       reduce using rule 85 (expression -> expression IS term .)
    TYPE_DOUBLE     reduce using rule 85 (expression -> expression IS term .)
    TYPE_STRING     reduce using rule 85 (expression -> expression IS term .)
    LEFT_PAREN      reduce using rule 85 (expression -> expression IS term .)
    DOUBLE          reduce using rule 85 (expression -> expression IS term .)
    INTEGER         reduce using rule 85 (expression -> expression IS term .)
    STRING          reduce using rule 85 (expression -> expression IS term .)
    TRUE            reduce using rule 85 (expression -> expression IS term .)
    FALSE           reduce using rule 85 (expression -> expression IS term .)
    $end            reduce using rule 85 (expression -> expression IS term .)
    RIGHT_BRACE     reduce using rule 85 (expression -> expression IS term .)
    STEP            reduce using rule 85 (expression -> expression IS term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 110

    (82) expression -> expression IS LESS . THAN term

    THAN            shift and go to state 149


state 111

    (83) expression -> expression GT term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 83 (expression -> expression GT term .)
    NOT             reduce using rule 83 (expression -> expression GT term .)
    EXP             reduce using rule 83 (expression -> expression GT term .)
    GTE             reduce using rule 83 (expression -> expression GT term .)
    LTE             reduce using rule 83 (expression -> expression GT term .)
    IS              reduce using rule 83 (expression -> expression GT term .)
    GT              reduce using rule 83 (expression -> expression GT term .)
    LT              reduce using rule 83 (expression -> expression GT term .)
    EQUALS          reduce using rule 83 (expression -> expression GT term .)
    OR              reduce using rule 83 (expression -> expression GT term .)
    AND             reduce using rule 83 (expression -> expression GT term .)
    PLUS            reduce using rule 83 (expression -> expression GT term .)
    MINUS           reduce using rule 83 (expression -> expression GT term .)
    RIGHT_PAREN     reduce using rule 83 (expression -> expression GT term .)
    IN              reduce using rule 83 (expression -> expression GT term .)
    LEFT_BRACE      reduce using rule 83 (expression -> expression GT term .)
    TO              reduce using rule 83 (expression -> expression GT term .)
    COMMA           reduce using rule 83 (expression -> expression GT term .)
    FUNCTION        reduce using rule 83 (expression -> expression GT term .)
    STRUCT          reduce using rule 83 (expression -> expression GT term .)
    PUT             reduce using rule 83 (expression -> expression GT term .)
    IDENTIFIER      reduce using rule 83 (expression -> expression GT term .)
    DO              reduce using rule 83 (expression -> expression GT term .)
    WHILE           reduce using rule 83 (expression -> expression GT term .)
    FOR             reduce using rule 83 (expression -> expression GT term .)
    IF              reduce using rule 83 (expression -> expression GT term .)
    LOG             reduce using rule 83 (expression -> expression GT term .)
    LET             reduce using rule 83 (expression -> expression GT term .)
    TYPE_BOOL       reduce using rule 83 (expression -> expression GT term .)
    TYPE_INT        reduce using rule 83 (expression -> expression GT term .)
    TYPE_CHAR       reduce using rule 83 (expression -> expression GT term .)
    TYPE_DOUBLE     reduce using rule 83 (expression -> expression GT term .)
    TYPE_STRING     reduce using rule 83 (expression -> expression GT term .)
    LEFT_PAREN      reduce using rule 83 (expression -> expression GT term .)
    DOUBLE          reduce using rule 83 (expression -> expression GT term .)
    INTEGER         reduce using rule 83 (expression -> expression GT term .)
    STRING          reduce using rule 83 (expression -> expression GT term .)
    TRUE            reduce using rule 83 (expression -> expression GT term .)
    FALSE           reduce using rule 83 (expression -> expression GT term .)
    $end            reduce using rule 83 (expression -> expression GT term .)
    RIGHT_BRACE     reduce using rule 83 (expression -> expression GT term .)
    STEP            reduce using rule 83 (expression -> expression GT term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 112

    (84) expression -> expression LT term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 84 (expression -> expression LT term .)
    NOT             reduce using rule 84 (expression -> expression LT term .)
    EXP             reduce using rule 84 (expression -> expression LT term .)
    GTE             reduce using rule 84 (expression -> expression LT term .)
    LTE             reduce using rule 84 (expression -> expression LT term .)
    IS              reduce using rule 84 (expression -> expression LT term .)
    GT              reduce using rule 84 (expression -> expression LT term .)
    LT              reduce using rule 84 (expression -> expression LT term .)
    EQUALS          reduce using rule 84 (expression -> expression LT term .)
    OR              reduce using rule 84 (expression -> expression LT term .)
    AND             reduce using rule 84 (expression -> expression LT term .)
    PLUS            reduce using rule 84 (expression -> expression LT term .)
    MINUS           reduce using rule 84 (expression -> expression LT term .)
    RIGHT_PAREN     reduce using rule 84 (expression -> expression LT term .)
    IN              reduce using rule 84 (expression -> expression LT term .)
    LEFT_BRACE      reduce using rule 84 (expression -> expression LT term .)
    TO              reduce using rule 84 (expression -> expression LT term .)
    COMMA           reduce using rule 84 (expression -> expression LT term .)
    FUNCTION        reduce using rule 84 (expression -> expression LT term .)
    STRUCT          reduce using rule 84 (expression -> expression LT term .)
    PUT             reduce using rule 84 (expression -> expression LT term .)
    IDENTIFIER      reduce using rule 84 (expression -> expression LT term .)
    DO              reduce using rule 84 (expression -> expression LT term .)
    WHILE           reduce using rule 84 (expression -> expression LT term .)
    FOR             reduce using rule 84 (expression -> expression LT term .)
    IF              reduce using rule 84 (expression -> expression LT term .)
    LOG             reduce using rule 84 (expression -> expression LT term .)
    LET             reduce using rule 84 (expression -> expression LT term .)
    TYPE_BOOL       reduce using rule 84 (expression -> expression LT term .)
    TYPE_INT        reduce using rule 84 (expression -> expression LT term .)
    TYPE_CHAR       reduce using rule 84 (expression -> expression LT term .)
    TYPE_DOUBLE     reduce using rule 84 (expression -> expression LT term .)
    TYPE_STRING     reduce using rule 84 (expression -> expression LT term .)
    LEFT_PAREN      reduce using rule 84 (expression -> expression LT term .)
    DOUBLE          reduce using rule 84 (expression -> expression LT term .)
    INTEGER         reduce using rule 84 (expression -> expression LT term .)
    STRING          reduce using rule 84 (expression -> expression LT term .)
    TRUE            reduce using rule 84 (expression -> expression LT term .)
    FALSE           reduce using rule 84 (expression -> expression LT term .)
    $end            reduce using rule 84 (expression -> expression LT term .)
    RIGHT_BRACE     reduce using rule 84 (expression -> expression LT term .)
    STEP            reduce using rule 84 (expression -> expression LT term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 113

    (86) expression -> expression EQUALS term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 86 (expression -> expression EQUALS term .)
    NOT             reduce using rule 86 (expression -> expression EQUALS term .)
    EXP             reduce using rule 86 (expression -> expression EQUALS term .)
    GTE             reduce using rule 86 (expression -> expression EQUALS term .)
    LTE             reduce using rule 86 (expression -> expression EQUALS term .)
    IS              reduce using rule 86 (expression -> expression EQUALS term .)
    GT              reduce using rule 86 (expression -> expression EQUALS term .)
    LT              reduce using rule 86 (expression -> expression EQUALS term .)
    EQUALS          reduce using rule 86 (expression -> expression EQUALS term .)
    OR              reduce using rule 86 (expression -> expression EQUALS term .)
    AND             reduce using rule 86 (expression -> expression EQUALS term .)
    PLUS            reduce using rule 86 (expression -> expression EQUALS term .)
    MINUS           reduce using rule 86 (expression -> expression EQUALS term .)
    RIGHT_PAREN     reduce using rule 86 (expression -> expression EQUALS term .)
    IN              reduce using rule 86 (expression -> expression EQUALS term .)
    LEFT_BRACE      reduce using rule 86 (expression -> expression EQUALS term .)
    TO              reduce using rule 86 (expression -> expression EQUALS term .)
    COMMA           reduce using rule 86 (expression -> expression EQUALS term .)
    FUNCTION        reduce using rule 86 (expression -> expression EQUALS term .)
    STRUCT          reduce using rule 86 (expression -> expression EQUALS term .)
    PUT             reduce using rule 86 (expression -> expression EQUALS term .)
    IDENTIFIER      reduce using rule 86 (expression -> expression EQUALS term .)
    DO              reduce using rule 86 (expression -> expression EQUALS term .)
    WHILE           reduce using rule 86 (expression -> expression EQUALS term .)
    FOR             reduce using rule 86 (expression -> expression EQUALS term .)
    IF              reduce using rule 86 (expression -> expression EQUALS term .)
    LOG             reduce using rule 86 (expression -> expression EQUALS term .)
    LET             reduce using rule 86 (expression -> expression EQUALS term .)
    TYPE_BOOL       reduce using rule 86 (expression -> expression EQUALS term .)
    TYPE_INT        reduce using rule 86 (expression -> expression EQUALS term .)
    TYPE_CHAR       reduce using rule 86 (expression -> expression EQUALS term .)
    TYPE_DOUBLE     reduce using rule 86 (expression -> expression EQUALS term .)
    TYPE_STRING     reduce using rule 86 (expression -> expression EQUALS term .)
    LEFT_PAREN      reduce using rule 86 (expression -> expression EQUALS term .)
    DOUBLE          reduce using rule 86 (expression -> expression EQUALS term .)
    INTEGER         reduce using rule 86 (expression -> expression EQUALS term .)
    STRING          reduce using rule 86 (expression -> expression EQUALS term .)
    TRUE            reduce using rule 86 (expression -> expression EQUALS term .)
    FALSE           reduce using rule 86 (expression -> expression EQUALS term .)
    $end            reduce using rule 86 (expression -> expression EQUALS term .)
    RIGHT_BRACE     reduce using rule 86 (expression -> expression EQUALS term .)
    STEP            reduce using rule 86 (expression -> expression EQUALS term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 114

    (87) expression -> expression OR term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 87 (expression -> expression OR term .)
    NOT             reduce using rule 87 (expression -> expression OR term .)
    EXP             reduce using rule 87 (expression -> expression OR term .)
    GTE             reduce using rule 87 (expression -> expression OR term .)
    LTE             reduce using rule 87 (expression -> expression OR term .)
    IS              reduce using rule 87 (expression -> expression OR term .)
    GT              reduce using rule 87 (expression -> expression OR term .)
    LT              reduce using rule 87 (expression -> expression OR term .)
    EQUALS          reduce using rule 87 (expression -> expression OR term .)
    OR              reduce using rule 87 (expression -> expression OR term .)
    AND             reduce using rule 87 (expression -> expression OR term .)
    PLUS            reduce using rule 87 (expression -> expression OR term .)
    MINUS           reduce using rule 87 (expression -> expression OR term .)
    RIGHT_PAREN     reduce using rule 87 (expression -> expression OR term .)
    IN              reduce using rule 87 (expression -> expression OR term .)
    LEFT_BRACE      reduce using rule 87 (expression -> expression OR term .)
    TO              reduce using rule 87 (expression -> expression OR term .)
    COMMA           reduce using rule 87 (expression -> expression OR term .)
    FUNCTION        reduce using rule 87 (expression -> expression OR term .)
    STRUCT          reduce using rule 87 (expression -> expression OR term .)
    PUT             reduce using rule 87 (expression -> expression OR term .)
    IDENTIFIER      reduce using rule 87 (expression -> expression OR term .)
    DO              reduce using rule 87 (expression -> expression OR term .)
    WHILE           reduce using rule 87 (expression -> expression OR term .)
    FOR             reduce using rule 87 (expression -> expression OR term .)
    IF              reduce using rule 87 (expression -> expression OR term .)
    LOG             reduce using rule 87 (expression -> expression OR term .)
    LET             reduce using rule 87 (expression -> expression OR term .)
    TYPE_BOOL       reduce using rule 87 (expression -> expression OR term .)
    TYPE_INT        reduce using rule 87 (expression -> expression OR term .)
    TYPE_CHAR       reduce using rule 87 (expression -> expression OR term .)
    TYPE_DOUBLE     reduce using rule 87 (expression -> expression OR term .)
    TYPE_STRING     reduce using rule 87 (expression -> expression OR term .)
    LEFT_PAREN      reduce using rule 87 (expression -> expression OR term .)
    DOUBLE          reduce using rule 87 (expression -> expression OR term .)
    INTEGER         reduce using rule 87 (expression -> expression OR term .)
    STRING          reduce using rule 87 (expression -> expression OR term .)
    TRUE            reduce using rule 87 (expression -> expression OR term .)
    FALSE           reduce using rule 87 (expression -> expression OR term .)
    $end            reduce using rule 87 (expression -> expression OR term .)
    RIGHT_BRACE     reduce using rule 87 (expression -> expression OR term .)
    STEP            reduce using rule 87 (expression -> expression OR term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 115

    (88) expression -> expression AND term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 88 (expression -> expression AND term .)
    NOT             reduce using rule 88 (expression -> expression AND term .)
    EXP             reduce using rule 88 (expression -> expression AND term .)
    GTE             reduce using rule 88 (expression -> expression AND term .)
    LTE             reduce using rule 88 (expression -> expression AND term .)
    IS              reduce using rule 88 (expression -> expression AND term .)
    GT              reduce using rule 88 (expression -> expression AND term .)
    LT              reduce using rule 88 (expression -> expression AND term .)
    EQUALS          reduce using rule 88 (expression -> expression AND term .)
    OR              reduce using rule 88 (expression -> expression AND term .)
    AND             reduce using rule 88 (expression -> expression AND term .)
    PLUS            reduce using rule 88 (expression -> expression AND term .)
    MINUS           reduce using rule 88 (expression -> expression AND term .)
    RIGHT_PAREN     reduce using rule 88 (expression -> expression AND term .)
    IN              reduce using rule 88 (expression -> expression AND term .)
    LEFT_BRACE      reduce using rule 88 (expression -> expression AND term .)
    TO              reduce using rule 88 (expression -> expression AND term .)
    COMMA           reduce using rule 88 (expression -> expression AND term .)
    FUNCTION        reduce using rule 88 (expression -> expression AND term .)
    STRUCT          reduce using rule 88 (expression -> expression AND term .)
    PUT             reduce using rule 88 (expression -> expression AND term .)
    IDENTIFIER      reduce using rule 88 (expression -> expression AND term .)
    DO              reduce using rule 88 (expression -> expression AND term .)
    WHILE           reduce using rule 88 (expression -> expression AND term .)
    FOR             reduce using rule 88 (expression -> expression AND term .)
    IF              reduce using rule 88 (expression -> expression AND term .)
    LOG             reduce using rule 88 (expression -> expression AND term .)
    LET             reduce using rule 88 (expression -> expression AND term .)
    TYPE_BOOL       reduce using rule 88 (expression -> expression AND term .)
    TYPE_INT        reduce using rule 88 (expression -> expression AND term .)
    TYPE_CHAR       reduce using rule 88 (expression -> expression AND term .)
    TYPE_DOUBLE     reduce using rule 88 (expression -> expression AND term .)
    TYPE_STRING     reduce using rule 88 (expression -> expression AND term .)
    LEFT_PAREN      reduce using rule 88 (expression -> expression AND term .)
    DOUBLE          reduce using rule 88 (expression -> expression AND term .)
    INTEGER         reduce using rule 88 (expression -> expression AND term .)
    STRING          reduce using rule 88 (expression -> expression AND term .)
    TRUE            reduce using rule 88 (expression -> expression AND term .)
    FALSE           reduce using rule 88 (expression -> expression AND term .)
    $end            reduce using rule 88 (expression -> expression AND term .)
    RIGHT_BRACE     reduce using rule 88 (expression -> expression AND term .)
    STEP            reduce using rule 88 (expression -> expression AND term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 116

    (89) expression -> expression PLUS term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 89 (expression -> expression PLUS term .)
    NOT             reduce using rule 89 (expression -> expression PLUS term .)
    EXP             reduce using rule 89 (expression -> expression PLUS term .)
    GTE             reduce using rule 89 (expression -> expression PLUS term .)
    LTE             reduce using rule 89 (expression -> expression PLUS term .)
    IS              reduce using rule 89 (expression -> expression PLUS term .)
    GT              reduce using rule 89 (expression -> expression PLUS term .)
    LT              reduce using rule 89 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 89 (expression -> expression PLUS term .)
    OR              reduce using rule 89 (expression -> expression PLUS term .)
    AND             reduce using rule 89 (expression -> expression PLUS term .)
    PLUS            reduce using rule 89 (expression -> expression PLUS term .)
    MINUS           reduce using rule 89 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 89 (expression -> expression PLUS term .)
    IN              reduce using rule 89 (expression -> expression PLUS term .)
    LEFT_BRACE      reduce using rule 89 (expression -> expression PLUS term .)
    TO              reduce using rule 89 (expression -> expression PLUS term .)
    COMMA           reduce using rule 89 (expression -> expression PLUS term .)
    FUNCTION        reduce using rule 89 (expression -> expression PLUS term .)
    STRUCT          reduce using rule 89 (expression -> expression PLUS term .)
    PUT             reduce using rule 89 (expression -> expression PLUS term .)
    IDENTIFIER      reduce using rule 89 (expression -> expression PLUS term .)
    DO              reduce using rule 89 (expression -> expression PLUS term .)
    WHILE           reduce using rule 89 (expression -> expression PLUS term .)
    FOR             reduce using rule 89 (expression -> expression PLUS term .)
    IF              reduce using rule 89 (expression -> expression PLUS term .)
    LOG             reduce using rule 89 (expression -> expression PLUS term .)
    LET             reduce using rule 89 (expression -> expression PLUS term .)
    TYPE_BOOL       reduce using rule 89 (expression -> expression PLUS term .)
    TYPE_INT        reduce using rule 89 (expression -> expression PLUS term .)
    TYPE_CHAR       reduce using rule 89 (expression -> expression PLUS term .)
    TYPE_DOUBLE     reduce using rule 89 (expression -> expression PLUS term .)
    TYPE_STRING     reduce using rule 89 (expression -> expression PLUS term .)
    LEFT_PAREN      reduce using rule 89 (expression -> expression PLUS term .)
    DOUBLE          reduce using rule 89 (expression -> expression PLUS term .)
    INTEGER         reduce using rule 89 (expression -> expression PLUS term .)
    STRING          reduce using rule 89 (expression -> expression PLUS term .)
    TRUE            reduce using rule 89 (expression -> expression PLUS term .)
    FALSE           reduce using rule 89 (expression -> expression PLUS term .)
    $end            reduce using rule 89 (expression -> expression PLUS term .)
    RIGHT_BRACE     reduce using rule 89 (expression -> expression PLUS term .)
    STEP            reduce using rule 89 (expression -> expression PLUS term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 117

    (90) expression -> expression MINUS term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 90 (expression -> expression MINUS term .)
    NOT             reduce using rule 90 (expression -> expression MINUS term .)
    EXP             reduce using rule 90 (expression -> expression MINUS term .)
    GTE             reduce using rule 90 (expression -> expression MINUS term .)
    LTE             reduce using rule 90 (expression -> expression MINUS term .)
    IS              reduce using rule 90 (expression -> expression MINUS term .)
    GT              reduce using rule 90 (expression -> expression MINUS term .)
    LT              reduce using rule 90 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 90 (expression -> expression MINUS term .)
    OR              reduce using rule 90 (expression -> expression MINUS term .)
    AND             reduce using rule 90 (expression -> expression MINUS term .)
    PLUS            reduce using rule 90 (expression -> expression MINUS term .)
    MINUS           reduce using rule 90 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 90 (expression -> expression MINUS term .)
    IN              reduce using rule 90 (expression -> expression MINUS term .)
    LEFT_BRACE      reduce using rule 90 (expression -> expression MINUS term .)
    TO              reduce using rule 90 (expression -> expression MINUS term .)
    COMMA           reduce using rule 90 (expression -> expression MINUS term .)
    FUNCTION        reduce using rule 90 (expression -> expression MINUS term .)
    STRUCT          reduce using rule 90 (expression -> expression MINUS term .)
    PUT             reduce using rule 90 (expression -> expression MINUS term .)
    IDENTIFIER      reduce using rule 90 (expression -> expression MINUS term .)
    DO              reduce using rule 90 (expression -> expression MINUS term .)
    WHILE           reduce using rule 90 (expression -> expression MINUS term .)
    FOR             reduce using rule 90 (expression -> expression MINUS term .)
    IF              reduce using rule 90 (expression -> expression MINUS term .)
    LOG             reduce using rule 90 (expression -> expression MINUS term .)
    LET             reduce using rule 90 (expression -> expression MINUS term .)
    TYPE_BOOL       reduce using rule 90 (expression -> expression MINUS term .)
    TYPE_INT        reduce using rule 90 (expression -> expression MINUS term .)
    TYPE_CHAR       reduce using rule 90 (expression -> expression MINUS term .)
    TYPE_DOUBLE     reduce using rule 90 (expression -> expression MINUS term .)
    TYPE_STRING     reduce using rule 90 (expression -> expression MINUS term .)
    LEFT_PAREN      reduce using rule 90 (expression -> expression MINUS term .)
    DOUBLE          reduce using rule 90 (expression -> expression MINUS term .)
    INTEGER         reduce using rule 90 (expression -> expression MINUS term .)
    STRING          reduce using rule 90 (expression -> expression MINUS term .)
    TRUE            reduce using rule 90 (expression -> expression MINUS term .)
    FALSE           reduce using rule 90 (expression -> expression MINUS term .)
    $end            reduce using rule 90 (expression -> expression MINUS term .)
    RIGHT_BRACE     reduce using rule 90 (expression -> expression MINUS term .)
    STEP            reduce using rule 90 (expression -> expression MINUS term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 118

    (22) iterative_statement -> DO compound_statement WHILE . LEFT_PAREN expression RIGHT_PAREN
    (40) iterative_statement -> DO compound_statement WHILE . LEFT_PAREN expression RIGHT_PAREN SEMICOLON
    (53) iterative_statement -> DO compound_statement WHILE . expression
    (61) iterative_statement -> DO compound_statement WHILE . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 150
    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 151
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 119

    (23) iterative_statement -> WHILE LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (50) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 152
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 120

    (41) iterative_statement -> WHILE expression compound_statement .

    FUNCTION        reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    STRUCT          reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    PUT             reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    IDENTIFIER      reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    SEMICOLON       reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    DO              reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    WHILE           reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    FOR             reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    IF              reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    LEFT_BRACE      reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    LOG             reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    LET             reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    MINUS           reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    NOT             reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    TYPE_BOOL       reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    TYPE_INT        reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    TYPE_CHAR       reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    TYPE_STRING     reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    LEFT_PAREN      reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    DOUBLE          reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    INTEGER         reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    STRING          reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    TRUE            reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    FALSE           reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    $end            reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)
    RIGHT_BRACE     reduce using rule 41 (iterative_statement -> WHILE expression compound_statement .)


state 121

    (31) iterative_statement -> FOR LEFT_PAREN expression . TO expression RIGHT_PAREN compound_statement
    (45) iterative_statement -> FOR LEFT_PAREN expression . TO expression STEP expression RIGHT_PAREN compound_statement
    (77) iterative_statement -> FOR LEFT_PAREN expression . SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> FOR LEFT_PAREN expression . SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement
    (50) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    TO              shift and go to state 153
    SEMICOLON       shift and go to state 154
    RIGHT_PAREN     shift and go to state 98
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 122

    (68) iterative_statement -> FOR LEFT_PAREN variable_declaration . expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN variable_declaration . expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 155
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 123

    (33) expression -> IDENTIFIER . INCREMENT
    (49) expression -> IDENTIFIER . DECREMENT
    (67) variable_declaration -> IDENTIFIER . IDENTIFIER SEMICOLON
    (46) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> IDENTIFIER . DOT IDENTIFIER
    (65) literal -> IDENTIFIER .

    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    IDENTIFIER      shift and go to state 49
    LEFT_BRACKET    shift and go to state 55
    DOT             shift and go to state 99
    PRODUCT         reduce using rule 65 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 65 (literal -> IDENTIFIER .)
    TO              reduce using rule 65 (literal -> IDENTIFIER .)
    SEMICOLON       reduce using rule 65 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 65 (literal -> IDENTIFIER .)
    NOT             reduce using rule 65 (literal -> IDENTIFIER .)
    EXP             reduce using rule 65 (literal -> IDENTIFIER .)
    GTE             reduce using rule 65 (literal -> IDENTIFIER .)
    LTE             reduce using rule 65 (literal -> IDENTIFIER .)
    IS              reduce using rule 65 (literal -> IDENTIFIER .)
    GT              reduce using rule 65 (literal -> IDENTIFIER .)
    LT              reduce using rule 65 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 65 (literal -> IDENTIFIER .)
    OR              reduce using rule 65 (literal -> IDENTIFIER .)
    AND             reduce using rule 65 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 65 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 65 (literal -> IDENTIFIER .)


state 124

    (57) iterative_statement -> FOR expression TO . expression compound_statement
    (64) iterative_statement -> FOR expression TO . expression STEP expression compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 156
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 125

    (9) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement
    (52) conditional_statement -> IF LEFT_PAREN expression . RIGHT_PAREN compound_statement ELSE conditional_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 157
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 126

    (25) print_statement -> LOG LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN     shift and go to state 158


state 127

    (30) variable_declaration -> LET IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 159
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 128

    (63) variable_declaration -> LET IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    DO              reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    IF              reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LET             reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    $end            reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 63 (variable_declaration -> LET IDENTIFIER SEMICOLON .)


state 129

    (44) variable_declaration -> type_specifier IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 160
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 130

    (56) variable_declaration -> type_specifier IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DO              reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    IF              reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LET             reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    $end            reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 56 (variable_declaration -> type_specifier IDENTIFIER SEMICOLON .)


state 131

    (35) term -> term PRODUCT factor .

    PRODUCT         reduce using rule 35 (term -> term PRODUCT factor .)
    DIVIDE          reduce using rule 35 (term -> term PRODUCT factor .)
    SEMICOLON       reduce using rule 35 (term -> term PRODUCT factor .)
    NOT             reduce using rule 35 (term -> term PRODUCT factor .)
    EXP             reduce using rule 35 (term -> term PRODUCT factor .)
    GTE             reduce using rule 35 (term -> term PRODUCT factor .)
    LTE             reduce using rule 35 (term -> term PRODUCT factor .)
    IS              reduce using rule 35 (term -> term PRODUCT factor .)
    GT              reduce using rule 35 (term -> term PRODUCT factor .)
    LT              reduce using rule 35 (term -> term PRODUCT factor .)
    EQUALS          reduce using rule 35 (term -> term PRODUCT factor .)
    OR              reduce using rule 35 (term -> term PRODUCT factor .)
    AND             reduce using rule 35 (term -> term PRODUCT factor .)
    PLUS            reduce using rule 35 (term -> term PRODUCT factor .)
    MINUS           reduce using rule 35 (term -> term PRODUCT factor .)
    RIGHT_PAREN     reduce using rule 35 (term -> term PRODUCT factor .)
    IN              reduce using rule 35 (term -> term PRODUCT factor .)
    LEFT_BRACE      reduce using rule 35 (term -> term PRODUCT factor .)
    TO              reduce using rule 35 (term -> term PRODUCT factor .)
    COMMA           reduce using rule 35 (term -> term PRODUCT factor .)
    FUNCTION        reduce using rule 35 (term -> term PRODUCT factor .)
    STRUCT          reduce using rule 35 (term -> term PRODUCT factor .)
    PUT             reduce using rule 35 (term -> term PRODUCT factor .)
    IDENTIFIER      reduce using rule 35 (term -> term PRODUCT factor .)
    DO              reduce using rule 35 (term -> term PRODUCT factor .)
    WHILE           reduce using rule 35 (term -> term PRODUCT factor .)
    FOR             reduce using rule 35 (term -> term PRODUCT factor .)
    IF              reduce using rule 35 (term -> term PRODUCT factor .)
    LOG             reduce using rule 35 (term -> term PRODUCT factor .)
    LET             reduce using rule 35 (term -> term PRODUCT factor .)
    TYPE_BOOL       reduce using rule 35 (term -> term PRODUCT factor .)
    TYPE_INT        reduce using rule 35 (term -> term PRODUCT factor .)
    TYPE_CHAR       reduce using rule 35 (term -> term PRODUCT factor .)
    TYPE_DOUBLE     reduce using rule 35 (term -> term PRODUCT factor .)
    TYPE_STRING     reduce using rule 35 (term -> term PRODUCT factor .)
    LEFT_PAREN      reduce using rule 35 (term -> term PRODUCT factor .)
    DOUBLE          reduce using rule 35 (term -> term PRODUCT factor .)
    INTEGER         reduce using rule 35 (term -> term PRODUCT factor .)
    STRING          reduce using rule 35 (term -> term PRODUCT factor .)
    TRUE            reduce using rule 35 (term -> term PRODUCT factor .)
    FALSE           reduce using rule 35 (term -> term PRODUCT factor .)
    $end            reduce using rule 35 (term -> term PRODUCT factor .)
    RIGHT_BRACE     reduce using rule 35 (term -> term PRODUCT factor .)
    STEP            reduce using rule 35 (term -> term PRODUCT factor .)


state 132

    (51) term -> term DIVIDE factor .

    PRODUCT         reduce using rule 51 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 51 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 51 (term -> term DIVIDE factor .)
    NOT             reduce using rule 51 (term -> term DIVIDE factor .)
    EXP             reduce using rule 51 (term -> term DIVIDE factor .)
    GTE             reduce using rule 51 (term -> term DIVIDE factor .)
    LTE             reduce using rule 51 (term -> term DIVIDE factor .)
    IS              reduce using rule 51 (term -> term DIVIDE factor .)
    GT              reduce using rule 51 (term -> term DIVIDE factor .)
    LT              reduce using rule 51 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 51 (term -> term DIVIDE factor .)
    OR              reduce using rule 51 (term -> term DIVIDE factor .)
    AND             reduce using rule 51 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 51 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 51 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 51 (term -> term DIVIDE factor .)
    IN              reduce using rule 51 (term -> term DIVIDE factor .)
    LEFT_BRACE      reduce using rule 51 (term -> term DIVIDE factor .)
    TO              reduce using rule 51 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 51 (term -> term DIVIDE factor .)
    FUNCTION        reduce using rule 51 (term -> term DIVIDE factor .)
    STRUCT          reduce using rule 51 (term -> term DIVIDE factor .)
    PUT             reduce using rule 51 (term -> term DIVIDE factor .)
    IDENTIFIER      reduce using rule 51 (term -> term DIVIDE factor .)
    DO              reduce using rule 51 (term -> term DIVIDE factor .)
    WHILE           reduce using rule 51 (term -> term DIVIDE factor .)
    FOR             reduce using rule 51 (term -> term DIVIDE factor .)
    IF              reduce using rule 51 (term -> term DIVIDE factor .)
    LOG             reduce using rule 51 (term -> term DIVIDE factor .)
    LET             reduce using rule 51 (term -> term DIVIDE factor .)
    TYPE_BOOL       reduce using rule 51 (term -> term DIVIDE factor .)
    TYPE_INT        reduce using rule 51 (term -> term DIVIDE factor .)
    TYPE_CHAR       reduce using rule 51 (term -> term DIVIDE factor .)
    TYPE_DOUBLE     reduce using rule 51 (term -> term DIVIDE factor .)
    TYPE_STRING     reduce using rule 51 (term -> term DIVIDE factor .)
    LEFT_PAREN      reduce using rule 51 (term -> term DIVIDE factor .)
    DOUBLE          reduce using rule 51 (term -> term DIVIDE factor .)
    INTEGER         reduce using rule 51 (term -> term DIVIDE factor .)
    STRING          reduce using rule 51 (term -> term DIVIDE factor .)
    TRUE            reduce using rule 51 (term -> term DIVIDE factor .)
    FALSE           reduce using rule 51 (term -> term DIVIDE factor .)
    $end            reduce using rule 51 (term -> term DIVIDE factor .)
    RIGHT_BRACE     reduce using rule 51 (term -> term DIVIDE factor .)
    STEP            reduce using rule 51 (term -> term DIVIDE factor .)


state 133

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 161


state 134

    (47) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 162

state 135

    (42) assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_PAREN     reduce using rule 42 (assignment_statement -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 136

    (54) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 163
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 137

    (8) function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 8 (function_call -> IDENTIFIER LEFT_PAREN RIGHT_PAREN SEMICOLON .)


state 138

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 164


state 139

    (7) arguments -> expression COMMA . arguments
    (7) arguments -> . expression COMMA arguments
    (36) arguments -> . expression
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 96
    arguments                      shift and go to state 165
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 140

    (46) literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER . QUOTE RIGHT_BRACKET

    QUOTE           shift and go to state 166


state 141

    (58) literal -> IDENTIFIER DOT IDENTIFIER .

    PRODUCT         reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    NOT             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EXP             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GTE             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LTE             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IS              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    GT              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LT              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    EQUALS          reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    OR              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    AND             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    MINUS           reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IN              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LEFT_BRACE      reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TO              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    COMMA           reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    FUNCTION        reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    STRUCT          reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    PUT             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DO              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    WHILE           reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    FOR             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    IF              reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LOG             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LET             reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TYPE_BOOL       reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TYPE_INT        reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TYPE_CHAR       reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TYPE_DOUBLE     reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TYPE_STRING     reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    LEFT_PAREN      reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    DOUBLE          reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    INTEGER         reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    STRING          reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    TRUE            reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    FALSE           reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    $end            reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    RIGHT_BRACE     reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)
    STEP            reduce using rule 58 (literal -> IDENTIFIER DOT IDENTIFIER .)


state 142

    (67) variable_declaration -> IDENTIFIER . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 49


state 143

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list . RIGHT_BRACE

    RIGHT_BRACE     shift and go to state 167


state 144

    (11) variable_declaration_list -> variable_declaration . variable_declaration_list
    (11) variable_declaration_list -> . variable_declaration variable_declaration_list
    (39) variable_declaration_list -> . empty
    (30) variable_declaration -> . LET IDENTIFIER ASSIGN expression SEMICOLON
    (44) variable_declaration -> . type_specifier IDENTIFIER ASSIGN expression SEMICOLON
    (56) variable_declaration -> . type_specifier IDENTIFIER SEMICOLON
    (63) variable_declaration -> . LET IDENTIFIER SEMICOLON
    (67) variable_declaration -> . IDENTIFIER IDENTIFIER SEMICOLON
    (6) empty -> .
    (1) type_specifier -> . TYPE_BOOL
    (2) type_specifier -> . TYPE_INT
    (3) type_specifier -> . TYPE_CHAR
    (4) type_specifier -> . TYPE_DOUBLE
    (5) type_specifier -> . TYPE_STRING

    LET             shift and go to state 28
    IDENTIFIER      shift and go to state 142
    RIGHT_BRACE     reduce using rule 6 (empty -> .)
    TYPE_BOOL       shift and go to state 33
    TYPE_INT        shift and go to state 34
    TYPE_CHAR       shift and go to state 35
    TYPE_DOUBLE     shift and go to state 36
    TYPE_STRING     shift and go to state 37

    variable_declaration           shift and go to state 144
    variable_declaration_list      shift and go to state 168
    empty                          shift and go to state 145
    type_specifier                 shift and go to state 29

state 145

    (39) variable_declaration_list -> empty .

    RIGHT_BRACE     reduce using rule 39 (variable_declaration_list -> empty .)


state 146

    (26) assignment_statement -> PUT expression IN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 169


state 147

    (66) expression -> expression NOT ASSIGN term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    NOT             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    EXP             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    GTE             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LTE             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    IS              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    GT              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LT              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    EQUALS          reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    OR              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    AND             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    PLUS            reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    MINUS           reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    RIGHT_PAREN     reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    IN              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LEFT_BRACE      reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TO              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    COMMA           reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    FUNCTION        reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    STRUCT          reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    PUT             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    IDENTIFIER      reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    DO              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    WHILE           reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    FOR             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    IF              reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LOG             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LET             reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TYPE_BOOL       reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TYPE_INT        reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TYPE_CHAR       reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TYPE_DOUBLE     reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TYPE_STRING     reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    LEFT_PAREN      reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    DOUBLE          reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    INTEGER         reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    STRING          reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    TRUE            reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    FALSE           reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    $end            reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    RIGHT_BRACE     reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    STEP            reduce using rule 66 (expression -> expression NOT ASSIGN term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 148

    (81) expression -> expression IS GREATER THAN . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 170
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 149

    (82) expression -> expression IS LESS THAN . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    LEFT_PAREN      shift and go to state 17
    IDENTIFIER      shift and go to state 86
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    term                           shift and go to state 171
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 150

    (22) iterative_statement -> DO compound_statement WHILE LEFT_PAREN . expression RIGHT_PAREN
    (40) iterative_statement -> DO compound_statement WHILE LEFT_PAREN . expression RIGHT_PAREN SEMICOLON
    (50) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 172
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 151

    (53) iterative_statement -> DO compound_statement WHILE expression .
    (61) iterative_statement -> DO compound_statement WHILE expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    FUNCTION        reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    STRUCT          reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    PUT             reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    IDENTIFIER      reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    DO              reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    WHILE           reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    FOR             reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    IF              reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    LEFT_BRACE      reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    LOG             reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    LET             reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    TYPE_BOOL       reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    TYPE_INT        reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    TYPE_CHAR       reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    TYPE_DOUBLE     reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    TYPE_STRING     reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    LEFT_PAREN      reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    DOUBLE          reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    INTEGER         reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    STRING          reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    TRUE            reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    FALSE           reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    $end            reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    RIGHT_BRACE     reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .)
    SEMICOLON       shift and go to state 173
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75

  ! SEMICOLON       [ reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .) ]
  ! MINUS           [ reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .) ]
  ! NOT             [ reduce using rule 53 (iterative_statement -> DO compound_statement WHILE expression .) ]


state 152

    (23) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (50) factor -> LEFT_PAREN expression RIGHT_PAREN .
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

  ! shift/reduce conflict for LEFT_BRACE resolved as shift
    PRODUCT         reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EXP             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GTE             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LTE             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IS              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GT              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LT              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      shift and go to state 19

  ! LEFT_BRACE      [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]

    compound_statement             shift and go to state 174

state 153

    (31) iterative_statement -> FOR LEFT_PAREN expression TO . expression RIGHT_PAREN compound_statement
    (45) iterative_statement -> FOR LEFT_PAREN expression TO . expression STEP expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 175
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 154

    (77) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON . expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON . expression SEMICOLON expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 176
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 155

    (68) iterative_statement -> FOR LEFT_PAREN variable_declaration expression . SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN variable_declaration expression . SEMICOLON expression RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 177
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 156

    (57) iterative_statement -> FOR expression TO expression . compound_statement
    (64) iterative_statement -> FOR expression TO expression . STEP expression compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    STEP            shift and go to state 179
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 178

state 157

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement
    (52) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN . compound_statement ELSE conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 180

state 158

    (25) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 181


state 159

    (30) variable_declaration -> LET IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 182
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 160

    (44) variable_declaration -> type_specifier IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 183
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 161

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 184

state 162

    (47) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DO              reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    IF              reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LET             reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)
    $end            reduce using rule 47 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_statement .)


state 163

    (54) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression . SEMICOLON
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 185
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 164

    (37) function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 37 (function_call -> IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 165

    (7) arguments -> expression COMMA arguments .

    RIGHT_PAREN     reduce using rule 7 (arguments -> expression COMMA arguments .)


state 166

    (46) literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE . RIGHT_BRACKET

    RIGHT_BRACKET   shift and go to state 186


state 167

    (10) struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .

    FUNCTION        reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    STRUCT          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    PUT             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    DO              reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    WHILE           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    FOR             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    IF              reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LOG             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LET             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    MINUS           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    NOT             reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_BOOL       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_INT        reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_CHAR       reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_DOUBLE     reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TYPE_STRING     reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    DOUBLE          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    INTEGER         reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    STRING          reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    TRUE            reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    FALSE           reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)
    $end            reduce using rule 10 (struct_declaration -> STRUCT IDENTIFIER LEFT_BRACE variable_declaration_list RIGHT_BRACE .)


state 168

    (11) variable_declaration_list -> variable_declaration variable_declaration_list .

    RIGHT_BRACE     reduce using rule 11 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 169

    (26) assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .

    FUNCTION        reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRUCT          reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    PUT             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DO              reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LOG             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LET             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_BOOL       reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_INT        reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_CHAR       reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TYPE_STRING     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    $end            reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)
    RIGHT_PAREN     reduce using rule 26 (assignment_statement -> PUT expression IN IDENTIFIER SEMICOLON .)


state 170

    (81) expression -> expression IS GREATER THAN term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    NOT             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    EXP             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    GTE             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    LTE             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    IS              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    GT              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    LT              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    EQUALS          reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    OR              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    AND             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    PLUS            reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    MINUS           reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    RIGHT_PAREN     reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    IN              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    LEFT_BRACE      reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    TO              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    COMMA           reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    FUNCTION        reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    STRUCT          reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    PUT             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    IDENTIFIER      reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    DO              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    WHILE           reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    FOR             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    IF              reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    LOG             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    LET             reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    TYPE_BOOL       reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    TYPE_INT        reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    TYPE_CHAR       reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    TYPE_DOUBLE     reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    TYPE_STRING     reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    LEFT_PAREN      reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    DOUBLE          reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    INTEGER         reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    STRING          reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    TRUE            reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    FALSE           reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    $end            reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    RIGHT_BRACE     reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    STEP            reduce using rule 81 (expression -> expression IS GREATER THAN term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 171

    (82) expression -> expression IS LESS THAN term .
    (35) term -> term . PRODUCT factor
    (51) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 82 (expression -> expression IS LESS THAN term .)
    NOT             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    EXP             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    GTE             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    LTE             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    IS              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    GT              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    LT              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    EQUALS          reduce using rule 82 (expression -> expression IS LESS THAN term .)
    OR              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    AND             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    PLUS            reduce using rule 82 (expression -> expression IS LESS THAN term .)
    MINUS           reduce using rule 82 (expression -> expression IS LESS THAN term .)
    RIGHT_PAREN     reduce using rule 82 (expression -> expression IS LESS THAN term .)
    IN              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    LEFT_BRACE      reduce using rule 82 (expression -> expression IS LESS THAN term .)
    TO              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    COMMA           reduce using rule 82 (expression -> expression IS LESS THAN term .)
    FUNCTION        reduce using rule 82 (expression -> expression IS LESS THAN term .)
    STRUCT          reduce using rule 82 (expression -> expression IS LESS THAN term .)
    PUT             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    IDENTIFIER      reduce using rule 82 (expression -> expression IS LESS THAN term .)
    DO              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    WHILE           reduce using rule 82 (expression -> expression IS LESS THAN term .)
    FOR             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    IF              reduce using rule 82 (expression -> expression IS LESS THAN term .)
    LOG             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    LET             reduce using rule 82 (expression -> expression IS LESS THAN term .)
    TYPE_BOOL       reduce using rule 82 (expression -> expression IS LESS THAN term .)
    TYPE_INT        reduce using rule 82 (expression -> expression IS LESS THAN term .)
    TYPE_CHAR       reduce using rule 82 (expression -> expression IS LESS THAN term .)
    TYPE_DOUBLE     reduce using rule 82 (expression -> expression IS LESS THAN term .)
    TYPE_STRING     reduce using rule 82 (expression -> expression IS LESS THAN term .)
    LEFT_PAREN      reduce using rule 82 (expression -> expression IS LESS THAN term .)
    DOUBLE          reduce using rule 82 (expression -> expression IS LESS THAN term .)
    INTEGER         reduce using rule 82 (expression -> expression IS LESS THAN term .)
    STRING          reduce using rule 82 (expression -> expression IS LESS THAN term .)
    TRUE            reduce using rule 82 (expression -> expression IS LESS THAN term .)
    FALSE           reduce using rule 82 (expression -> expression IS LESS THAN term .)
    $end            reduce using rule 82 (expression -> expression IS LESS THAN term .)
    RIGHT_BRACE     reduce using rule 82 (expression -> expression IS LESS THAN term .)
    STEP            reduce using rule 82 (expression -> expression IS LESS THAN term .)
    PRODUCT         shift and go to state 87
    DIVIDE          shift and go to state 88


state 172

    (22) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression . RIGHT_PAREN
    (40) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression . RIGHT_PAREN SEMICOLON
    (50) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 187
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 173

    (61) iterative_statement -> DO compound_statement WHILE expression SEMICOLON .

    FUNCTION        reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    STRUCT          reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    PUT             reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    IDENTIFIER      reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    SEMICOLON       reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    DO              reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    WHILE           reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    FOR             reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    IF              reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    LOG             reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    LET             reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    MINUS           reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    NOT             reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    TYPE_INT        reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    TYPE_STRING     reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    DOUBLE          reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    INTEGER         reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    STRING          reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    TRUE            reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    FALSE           reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    $end            reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 61 (iterative_statement -> DO compound_statement WHILE expression SEMICOLON .)


state 174

    (23) iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 23 (iterative_statement -> WHILE LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 175

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression . RIGHT_PAREN compound_statement
    (45) iterative_statement -> FOR LEFT_PAREN expression TO expression . STEP expression RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 188
    STEP            shift and go to state 189
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 176

    (77) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression . SEMICOLON assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression . SEMICOLON expression RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 190
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 177

    (68) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON . assignment_statement RIGHT_PAREN compound_statement
    (75) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON . expression RIGHT_PAREN compound_statement
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 193
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 191
    assignment_statement           shift and go to state 192
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 178

    (57) iterative_statement -> FOR expression TO expression compound_statement .

    FUNCTION        reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRUCT          reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    PUT             reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    IDENTIFIER      reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    SEMICOLON       reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    DO              reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    WHILE           reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    FOR             reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    IF              reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_BRACE      reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    LOG             reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    LET             reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    MINUS           reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    NOT             reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_BOOL       reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_INT        reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_CHAR       reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    TYPE_STRING     reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    LEFT_PAREN      reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    DOUBLE          reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    INTEGER         reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    STRING          reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    TRUE            reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    FALSE           reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    $end            reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)
    RIGHT_BRACE     reduce using rule 57 (iterative_statement -> FOR expression TO expression compound_statement .)


state 179

    (64) iterative_statement -> FOR expression TO expression STEP . expression compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 194
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 180

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE compound_statement
    (38) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .
    (52) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement . ELSE conditional_statement

    ELSE            shift and go to state 195
    FUNCTION        reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 38 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement .)


state 181

    (25) print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 25 (print_statement -> LOG LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .)


state 182

    (30) variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 30 (variable_declaration -> LET IDENTIFIER ASSIGN expression SEMICOLON .)


state 183

    (44) variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 44 (variable_declaration -> type_specifier IDENTIFIER ASSIGN expression SEMICOLON .)


state 184

    (28) function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DO              reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    IF              reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LET             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)
    $end            reduce using rule 28 (function_declaration -> FUNCTION IDENTIFIER LEFT_PAREN arguments RIGHT_PAREN compound_statement .)


state 185

    (54) assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .

    FUNCTION        reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    STRUCT          reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    PUT             reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    DO              reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_BRACE      reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LOG             reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LET             reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    MINUS           reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_BOOL       reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_INT        reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_CHAR       reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TYPE_STRING     reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    LEFT_PAREN      reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    INTEGER         reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_BRACE     reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)
    RIGHT_PAREN     reduce using rule 54 (assignment_statement -> IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON .)


state 186

    (46) literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .

    PRODUCT         reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    DIVIDE          reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    SEMICOLON       reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    NOT             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    EXP             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    GTE             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LTE             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    IS              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    GT              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LT              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    EQUALS          reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    OR              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    AND             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    PLUS            reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    MINUS           reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    IN              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LEFT_BRACE      reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TO              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    COMMA           reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    FUNCTION        reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    STRUCT          reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    PUT             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    IDENTIFIER      reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    DO              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    WHILE           reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    FOR             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    IF              reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LOG             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LET             reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TYPE_BOOL       reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TYPE_INT        reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TYPE_CHAR       reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TYPE_DOUBLE     reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TYPE_STRING     reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    LEFT_PAREN      reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    DOUBLE          reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    INTEGER         reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    STRING          reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    TRUE            reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    FALSE           reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    $end            reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    RIGHT_BRACE     reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)
    STEP            reduce using rule 46 (literal -> IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET .)


state 187

    (22) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .
    (40) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN . SEMICOLON
    (50) factor -> LEFT_PAREN expression RIGHT_PAREN .

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! reduce/reduce conflict for NOT resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for MINUS resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for STRUCT resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for PUT resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for DO resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for WHILE resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for IF resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for LEFT_BRACE resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for LOG resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for LET resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for TYPE_BOOL resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for TYPE_INT resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for TYPE_CHAR resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for TYPE_DOUBLE resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for TYPE_STRING resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for LEFT_PAREN resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for INTEGER resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for STRING resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for TRUE resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for FALSE resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for $end resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
  ! reduce/reduce conflict for RIGHT_BRACE resolved using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FUNCTION        reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRUCT          reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    PUT             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IDENTIFIER      reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DO              reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    WHILE           reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FOR             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    IF              reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_BRACE      reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LOG             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LET             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    NOT             reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_BOOL       reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_INT        reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_CHAR       reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_DOUBLE     reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TYPE_STRING     reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    LEFT_PAREN      reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    DOUBLE          reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    INTEGER         reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    STRING          reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    TRUE            reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    FALSE           reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    $end            reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_BRACE     reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       shift and go to state 196
    PRODUCT         reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EXP             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GTE             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LTE             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    IS              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    GT              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    LT              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    EQUALS          reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    OR              reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    AND             reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .)

  ! SEMICOLON       [ reduce using rule 22 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN .) ]
  ! SEMICOLON       [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! NOT             [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! MINUS           [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! FUNCTION        [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! STRUCT          [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! PUT             [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! IDENTIFIER      [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! DO              [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! WHILE           [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! FOR             [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! IF              [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! LEFT_BRACE      [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! LOG             [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! LET             [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! TYPE_BOOL       [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! TYPE_INT        [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! TYPE_CHAR       [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! TYPE_DOUBLE     [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! TYPE_STRING     [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! LEFT_PAREN      [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! DOUBLE          [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! INTEGER         [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! STRING          [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! TRUE            [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! FALSE           [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! $end            [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]
  ! RIGHT_BRACE     [ reduce using rule 50 (factor -> LEFT_PAREN expression RIGHT_PAREN .) ]


state 188

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 197

state 189

    (45) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP . expression RIGHT_PAREN compound_statement
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    IDENTIFIER      shift and go to state 57
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 198
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 190

    (77) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON . assignment_statement RIGHT_PAREN compound_statement
    (79) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON . expression RIGHT_PAREN compound_statement
    (26) assignment_statement -> . PUT expression IN IDENTIFIER SEMICOLON
    (42) assignment_statement -> . IDENTIFIER ASSIGN expression SEMICOLON
    (54) assignment_statement -> . IDENTIFIER DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> . IDENTIFIER INCREMENT
    (49) expression -> . IDENTIFIER DECREMENT
    (59) expression -> . MINUS term
    (66) expression -> . expression NOT ASSIGN term
    (74) expression -> . NOT term
    (76) expression -> . expression EXP term
    (78) expression -> . expression GTE term
    (80) expression -> . expression LTE term
    (81) expression -> . expression IS GREATER THAN term
    (82) expression -> . expression IS LESS THAN term
    (83) expression -> . expression GT term
    (84) expression -> . expression LT term
    (85) expression -> . expression IS term
    (86) expression -> . expression EQUALS term
    (87) expression -> . expression OR term
    (88) expression -> . expression AND term
    (89) expression -> . expression PLUS term
    (90) expression -> . expression MINUS term
    (91) expression -> . term
    (35) term -> . term PRODUCT factor
    (51) term -> . term DIVIDE factor
    (60) term -> . factor
    (34) factor -> . literal
    (50) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (46) literal -> . IDENTIFIER LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> . IDENTIFIER DOT IDENTIFIER
    (65) literal -> . IDENTIFIER
    (69) literal -> . DOUBLE
    (70) literal -> . INTEGER
    (71) literal -> . STRING
    (72) literal -> . TRUE
    (73) literal -> . FALSE

    PUT             shift and go to state 20
    IDENTIFIER      shift and go to state 193
    MINUS           shift and go to state 30
    NOT             shift and go to state 32
    LEFT_PAREN      shift and go to state 17
    DOUBLE          shift and go to state 40
    INTEGER         shift and go to state 41
    STRING          shift and go to state 42
    TRUE            shift and go to state 43
    FALSE           shift and go to state 44

    expression                     shift and go to state 199
    assignment_statement           shift and go to state 200
    term                           shift and go to state 31
    factor                         shift and go to state 38
    literal                        shift and go to state 39

state 191

    (75) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression . RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 201
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 192

    (68) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 202


state 193

    (42) assignment_statement -> IDENTIFIER . ASSIGN expression SEMICOLON
    (54) assignment_statement -> IDENTIFIER . DOT IDENTIFIER ASSIGN expression SEMICOLON
    (33) expression -> IDENTIFIER . INCREMENT
    (49) expression -> IDENTIFIER . DECREMENT
    (46) literal -> IDENTIFIER . LEFT_BRACKET QUOTE IDENTIFIER QUOTE RIGHT_BRACKET
    (58) literal -> IDENTIFIER . DOT IDENTIFIER
    (65) literal -> IDENTIFIER .

    ASSIGN          shift and go to state 50
    DOT             shift and go to state 51
    INCREMENT       shift and go to state 53
    DECREMENT       shift and go to state 54
    LEFT_BRACKET    shift and go to state 55
    PRODUCT         reduce using rule 65 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 65 (literal -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 65 (literal -> IDENTIFIER .)
    NOT             reduce using rule 65 (literal -> IDENTIFIER .)
    EXP             reduce using rule 65 (literal -> IDENTIFIER .)
    GTE             reduce using rule 65 (literal -> IDENTIFIER .)
    LTE             reduce using rule 65 (literal -> IDENTIFIER .)
    IS              reduce using rule 65 (literal -> IDENTIFIER .)
    GT              reduce using rule 65 (literal -> IDENTIFIER .)
    LT              reduce using rule 65 (literal -> IDENTIFIER .)
    EQUALS          reduce using rule 65 (literal -> IDENTIFIER .)
    OR              reduce using rule 65 (literal -> IDENTIFIER .)
    AND             reduce using rule 65 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 65 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 65 (literal -> IDENTIFIER .)


state 194

    (64) iterative_statement -> FOR expression TO expression STEP expression . compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75
    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 203

state 195

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . compound_statement
    (52) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE . conditional_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE
    (9) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement
    (38) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement
    (52) conditional_statement -> . IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement

    LEFT_BRACE      shift and go to state 19
    IF              shift and go to state 26

    compound_statement             shift and go to state 204
    conditional_statement          shift and go to state 205

state 196

    (40) iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .

    FUNCTION        reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    STRUCT          reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    PUT             reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    DO              reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    FOR             reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LOG             reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LET             reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    TYPE_BOOL       reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    TYPE_INT        reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    TYPE_CHAR       reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    TYPE_DOUBLE     reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    TYPE_STRING     reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    DOUBLE          reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    INTEGER         reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    STRING          reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    TRUE            reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    FALSE           reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    $end            reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 40 (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON .)


state 197

    (31) iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 31 (iterative_statement -> FOR LEFT_PAREN expression TO expression RIGHT_PAREN compound_statement .)


state 198

    (45) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression . RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 206
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 199

    (79) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression . RIGHT_PAREN compound_statement
    (66) expression -> expression . NOT ASSIGN term
    (76) expression -> expression . EXP term
    (78) expression -> expression . GTE term
    (80) expression -> expression . LTE term
    (81) expression -> expression . IS GREATER THAN term
    (82) expression -> expression . IS LESS THAN term
    (83) expression -> expression . GT term
    (84) expression -> expression . LT term
    (85) expression -> expression . IS term
    (86) expression -> expression . EQUALS term
    (87) expression -> expression . OR term
    (88) expression -> expression . AND term
    (89) expression -> expression . PLUS term
    (90) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 207
    NOT             shift and go to state 64
    EXP             shift and go to state 65
    GTE             shift and go to state 66
    LTE             shift and go to state 67
    IS              shift and go to state 68
    GT              shift and go to state 69
    LT              shift and go to state 70
    EQUALS          shift and go to state 71
    OR              shift and go to state 72
    AND             shift and go to state 73
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 200

    (77) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement . RIGHT_PAREN compound_statement

    RIGHT_PAREN     shift and go to state 208


state 201

    (75) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 209

state 202

    (68) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 210

state 203

    (64) iterative_statement -> FOR expression TO expression STEP expression compound_statement .

    FUNCTION        reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRUCT          reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    PUT             reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IDENTIFIER      reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    SEMICOLON       reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DO              reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    WHILE           reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FOR             reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    IF              reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_BRACE      reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LOG             reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LET             reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    MINUS           reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    NOT             reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_BOOL       reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_INT        reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_CHAR       reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_DOUBLE     reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TYPE_STRING     reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    LEFT_PAREN      reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    DOUBLE          reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    INTEGER         reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    STRING          reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    TRUE            reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    FALSE           reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    $end            reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)
    RIGHT_BRACE     reduce using rule 64 (iterative_statement -> FOR expression TO expression STEP expression compound_statement .)


state 204

    (9) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .

    FUNCTION        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRUCT          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    PUT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IDENTIFIER      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    SEMICOLON       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DO              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    WHILE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FOR             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    IF              reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_BRACE      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LOG             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LET             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    MINUS           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    NOT             reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_BOOL       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_INT        reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_CHAR       reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_DOUBLE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TYPE_STRING     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    LEFT_PAREN      reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    DOUBLE          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    INTEGER         reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    STRING          reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    TRUE            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    FALSE           reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    $end            reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)
    RIGHT_BRACE     reduce using rule 9 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE compound_statement .)


state 205

    (52) conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .

    FUNCTION        reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    STRUCT          reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    PUT             reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    IDENTIFIER      reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    SEMICOLON       reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    DO              reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    WHILE           reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    FOR             reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    IF              reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LEFT_BRACE      reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LOG             reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LET             reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    MINUS           reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    NOT             reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_BOOL       reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_INT        reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_CHAR       reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_DOUBLE     reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TYPE_STRING     reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    LEFT_PAREN      reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    DOUBLE          reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    INTEGER         reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    STRING          reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    TRUE            reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    FALSE           reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    $end            reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)
    RIGHT_BRACE     reduce using rule 52 (conditional_statement -> IF LEFT_PAREN expression RIGHT_PAREN compound_statement ELSE conditional_statement .)


state 206

    (45) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 211

state 207

    (79) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 212

state 208

    (77) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN . compound_statement
    (27) compound_statement -> . LEFT_BRACE statement_list RIGHT_BRACE

    LEFT_BRACE      shift and go to state 19

    compound_statement             shift and go to state 213

state 209

    (75) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 75 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON expression RIGHT_PAREN compound_statement .)


state 210

    (68) iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DO              reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IF              reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LET             reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    $end            reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 68 (iterative_statement -> FOR LEFT_PAREN variable_declaration expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)


state 211

    (45) iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 45 (iterative_statement -> FOR LEFT_PAREN expression TO expression STEP expression RIGHT_PAREN compound_statement .)


state 212

    (79) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DO              reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    IF              reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LET             reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    $end            reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 79 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON expression RIGHT_PAREN compound_statement .)


state 213

    (77) iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .

    FUNCTION        reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRUCT          reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    PUT             reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IDENTIFIER      reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    SEMICOLON       reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DO              reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    WHILE           reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FOR             reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    IF              reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_BRACE      reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LOG             reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LET             reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    MINUS           reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    NOT             reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_BOOL       reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_INT        reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_CHAR       reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_DOUBLE     reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TYPE_STRING     reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    LEFT_PAREN      reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    DOUBLE          reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    INTEGER         reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    STRING          reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    TRUE            reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    FALSE           reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    $end            reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)
    RIGHT_BRACE     reduce using rule 77 (iterative_statement -> FOR LEFT_PAREN expression SEMICOLON expression SEMICOLON assignment_statement RIGHT_PAREN compound_statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 151 resolved as shift
WARNING: shift/reduce conflict for NOT in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for LEFT_BRACE in state 152 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 187 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 187 resolved as shift
WARNING: reduce/reduce conflict in state 187 resolved using rule (iterative_statement -> DO compound_statement WHILE LEFT_PAREN expression RIGHT_PAREN)
WARNING: rejected rule (factor -> LEFT_PAREN expression RIGHT_PAREN) in state 187
